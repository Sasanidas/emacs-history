These untested patches in src/syntax.c might fix a bug
in forward-comment that would show up if you use lisp/c++-mode1.el.

***************
*** 564,575 ****
  }
  
  DEFUN ("forward-comment", Fforward_comment, Sforward_comment, 1, 1, 0,
    "Move forward across up to N comments.  If N is negative, move backward.\n\
  Stop scanning if we find something other than a comment or whitespace.\n\
- Set point to where scanning stops.\n\
  If N comments are found as expected, with nothing except whitespace\n\
! between them, return t; otherwise return nil.")
!   (count)
!      Lisp_Object count;
  {
    register int from;
--- 653,831 ----
  }
  
+ static int
+ find_start_of_comment (from, stop, mask)
+     int from, stop, mask;
+ {
+     int c;
+     enum syntaxcode code;
+ 
+     /* Look back, counting the parity of string-quotes,
+        and recording the comment-starters seen.
+        When we reach a safe place, assume that's not in a string;
+        then step the main scan to the earliest comment-starter seen
+        an even number of string quotes away from the safe place.
+        
+        OFROM[I] is position of the earliest comment-starter seen
+        which is I+2X quotes from the comment-end.
+        PARITY is current parity of quotes from the comment end.  */
+     int parity = 0;
+     char my_stringend = 0;
+     int string_lossage = 0;
+     int comment_end = from;
+     int comstart_pos = 0;
+     int comstart_parity = 0;
+     int styles_match_p = 0;
+ 
+     /* At beginning of range to scan, we're outside of strings;
+        that determines quote parity to the comment-end.  */
+     while (from != stop)
+     {
+ 	/* Move back and examine a character.  */
+ 	from--;
+ 
+ 	c = FETCH_CHAR (from);
+ 	code = SYNTAX (c);
+ 
+ 	/* is this a 1-char comment end sequence? if so, try
+ 	   to see if style matches previously extracted mask */
+ 	if (code == Sendcomment)
+ 	{
+ 	    styles_match_p = SYNTAX_STYLES_MATCH_1CHAR_P (c, mask);
+ 	}
+ 
+ 	/* otherwise, is this a 2-char comment end sequence?
+ 	   if so, back up, and see if style matches previously
+ 	   extracted mask */
+ 	else if (from > stop
+ 		 && SYNTAX_END_P (FETCH_CHAR (from-1), c))
+ 	{
+ 	    code = Sendcomment;
+ 	    styles_match_p =
+ 	      SYNTAX_STYLES_MATCH_END_P (FETCH_CHAR (from-1), c, mask);
+ 
+ 	    from--;
+ 	}
+ 			
+ 	/* or are we looking at a 1-char comment start sequence
+ 	   of the style matching mask? */
+ 	else if (code == Scomment
+ 		 && SYNTAX_STYLES_MATCH_1CHAR_P (c, mask))
+ 	{
+ 	    styles_match_p = 1;
+ 	}
+ 		    
+ 	/* or possibly, a 2-char comment start sequence */
+ 	else if (from > stop
+ 		 && SYNTAX_STYLES_MATCH_START_P (FETCH_CHAR (from-1), c, mask))
+ 	{
+ 	    code = Scomment;
+ 	    from--;
+ 	    styles_match_p = 1;
+ 	}
+ 
+ 	/* Ignore escaped characters.  */
+ 	if (char_quoted (from))
+ 	    continue;
+ 
+ 	/* Track parity of quotes.  */
+ 	if (code == Sstring)
+ 	{
+ 	    parity ^= 1;
+ 	    if (my_stringend == 0)
+ 		my_stringend = c;
+ 	    /* If we have two kinds of string delimiters.
+ 	       There's no way to grok this scanning backwards.  */
+ 	    else if (my_stringend != c)
+ 		string_lossage = 1;
+ 	}
+ 
+ 	/* Record comment-starters according to that
+ 	   quote-parity to the comment-end.  */
+ 	if (code == Scomment && styles_match_p)
+ 	{
+ 	    comstart_parity = parity;
+ 	    comstart_pos = from;
+ 	}
+ 
+ 	/* If we find another earlier comment-ender,
+ 	   any comment-starts earier than that don't count
+ 	   (because they go with the earlier comment-ender).  */
+ 	if (code == Sendcomment && styles_match_p)
+ 	    break;
+ 
+ 	/* Assume a defun-start point is outside of strings.  */
+ 	if (code == Sopen
+ 	    && (from == stop || FETCH_CHAR (from - 1) == '\n'))
+ 	    break;
+     }
+ 
+     if (comstart_pos == 0)
+ 	from = comment_end;
+     /* If the earliest comment starter
+        is followed by uniform paired string quotes or none,
+        we know it can't be inside a string
+        since if it were then the comment ender would be inside one.
+        So it does start a comment.  Skip back to it.  */
+     else if (comstart_parity == 0 && !string_lossage)
+ 	from = comstart_pos;
+     else
+     {
+ 	/* We had two kinds of string delimiters mixed up
+ 	   together.  Decode this going forwards.
+ 	   Scan fwd from the previous comment ender
+ 	   to the one in question; this records where we
+ 	   last passed a comment starter.  */
+ 	struct lisp_parse_state state;
+ 	scan_sexps_forward (&state, find_defun_start (comment_end),
+ 			    comment_end - 1, -10000, 0, Qnil);
+ 	if (state.incomment)
+ 	    from = state.comstart;
+ 	else
+ 	/* We can't grok this as a comment; scan it normally.  */
+ 	    from = comment_end;
+     }
+     return from;
+ }  
+ 
+ static int
+ find_end_of_comment (from, stop, mask)
+      int from, stop, mask;
+ {
+   int c;
+ 
+   while (1)
+     {
+       if (from == stop)
+ 	{
+ 	  return -1;
+ 	}
+       c = FETCH_CHAR (from);
+       if (SYNTAX (c) == Sendcomment
+ 	  && SYNTAX_STYLES_MATCH_1CHAR_P (c, mask))
+ 	/* we have encountered a comment end of the same style
+ 	   as the comment sequence which began this comment
+ 	   section */
+ 	break;
+ 
+       from++;
+       if (from < stop
+ 	  && SYNTAX_STYLES_MATCH_END_P (c, FETCH_CHAR (from), mask))
+ 	/* we have encountered a comment end of the same style
+ 	   as the comment sequence which began this comment
+ 	   section */
+ 	{ from++; break; }
+     }
+   return from;
+ }
+ 
+ 
  DEFUN ("forward-comment", Fforward_comment, Sforward_comment, 1, 1, 0,
    "Move forward across up to N comments.  If N is negative, move backward.\n\
+ Set point to the far end of the last comment found.\n\
  Stop scanning if we find something other than a comment or whitespace.\n\
  If N comments are found as expected, with nothing except whitespace\n\
! between them, return t; otherwise return nil. Point is set in either case.")
!   (cntarg)
!      Lisp_Object cntarg;
  {
    register int from;
***************
*** 577,586 ****
    register int c;
    register enum syntaxcode code;
!   int comstyle = 0;	    /* style of comment encountered */
!   int found;
!   int count1;
  
!   CHECK_NUMBER (count, 0);
!   count1 = XINT (count);
  
    immediate_quit = 1;
--- 833,841 ----
    register int c;
    register enum syntaxcode code;
!   int count;
!   int mask = 0x0;			     /* mask for matching comments */
  
!   CHECK_NUMBER (cntarg, 0);
!   count = XINT (cntarg);
  
    immediate_quit = 1;
***************
*** 589,593 ****
    from = PT;
  
!   while (count1 > 0)
      {
        stop = ZV;
--- 844,848 ----
    from = PT;
  
!   while (count > 0)
      {
        stop = ZV;
***************
*** 594,605 ****
        while (from < stop)
  	{
  	  c = FETCH_CHAR (from);
  	  code = SYNTAX (c);
! 	  from++;
! 	  comstyle = 0;
! 	  if (from < stop && SYNTAX_COMSTART_FIRST (c)
! 	      && SYNTAX_COMSTART_SECOND (FETCH_CHAR (from)))
  	    {
! 	      /* we have encountered a comment start sequence and we 
  		 are ignoring all text inside comments. we must record
  		 the comment style this sequence begins so that later,
--- 849,872 ----
        while (from < stop)
  	{
+ 	  if (char_quoted (from))
+ 	    { from++; continue; }
+ 
  	  c = FETCH_CHAR (from);
  	  code = SYNTAX (c);
! 	  mask = 0x0;
! 
! 	  if (code == Scomment)
  	    {
! 	      /* we have encountered a single character comment start
! 		 sequence, and we are ignoring all text inside comments.
! 		 we must record the comment style this character begins
! 		 so that later, only a comment end of the same style actually
! 		 ends the comment section */
! 	      mask = SYNTAX_COMMENT_1CHAR_MASK (c);
! 	    }
! 
! 	  else if (from < stop && SYNTAX_START_P (c, FETCH_CHAR (from+1)))
! 	    {
! 	      /* we have encountered a 2char comment start sequence and we 
  		 are ignoring all text inside comments. we must record
  		 the comment style this sequence begins so that later,
***************
*** 607,611 ****
  		 the comment section */
  	      code = Scomment;
! 	      comstyle = SYNTAX_COMMENT_STYLE (FETCH_CHAR (from));
  	      from++;
  	    }
--- 874,878 ----
  		 the comment section */
  	      code = Scomment;
! 	      mask = SYNTAX_COMMENT_MASK_START (c, FETCH_CHAR (from+1));
  	      from++;
  	    }
***************
*** 613,656 ****
  	  if (code == Scomment)
  	    {
! 	      while (1)
  		{
! 		  if (from == stop)
! 		    {
! 		      immediate_quit = 0;
! 		      SET_PT (from);
! 		      return Qnil;
! 		    }
! 		  c = FETCH_CHAR (from);
! 		  if (SYNTAX (c) == Sendcomment
! 		      && SYNTAX_COMMENT_STYLE (c) == comstyle)
! 		    /* we have encountered a comment end of the same style
! 		       as the comment sequence which began this comment
! 		       section */
! 		    break;
! 		  from++;
! 		  if (from < stop && SYNTAX_COMEND_FIRST (c)
! 		      && SYNTAX_COMEND_SECOND (FETCH_CHAR (from))
! 		      && SYNTAX_COMMENT_STYLE (c) == comstyle)
! 		    /* we have encountered a comment end of the same style
! 		       as the comment sequence which began this comment
! 		       section */
! 		    { from++; break; }
  		}
  	      /* We have skipped one comment.  */
  	      break;
  	    }
! 	  else if (code != Swhitespace && code != Sendcomment)
  	    {
  	      immediate_quit = 0;
! 	      SET_PT (from - 1);
  	      return Qnil;
  	    }
  	}
  
        /* End of comment reached */
!       count1--;
      }
  
!   while (count1 < 0)
      {
        stop = BEGV;
--- 880,914 ----
  	  if (code == Scomment)
  	    {
! 	      int newfrom;
! 
! 	      newfrom = find_end_of_comment (from, stop, mask);
! 	      if (newfrom < 0)
  		{
! 		  /* we stopped because from==stop */
! 		  immediate_quit = 0;
! 		  SET_PT (stop);
! 		  return Qnil;
  		}
+ 	      from = newfrom;
+ 
  	      /* We have skipped one comment.  */
  	      break;
  	    }
! 	  else if (code != Swhitespace &&
! 		   code != Sendcomment &&
! 		   code != Scomment )
  	    {
  	      immediate_quit = 0;
! 	      SET_PT (from);
  	      return Qnil;
  	    }
+ 	  from++;
  	}
  
        /* End of comment reached */
!       count--;
      }
  
!   while (count < 0)
      {
        stop = BEGV;
***************
*** 660,672 ****
  
  	  from--;
! 	  quoted = char_quoted (from);
! 	  if (quoted)
! 	    from--;
  	  c = FETCH_CHAR (from);
  	  code = SYNTAX (c);
! 	  comstyle = 0;
! 	  if (from > stop && SYNTAX_COMEND_SECOND (c)
! 	      && SYNTAX_COMEND_FIRST (FETCH_CHAR (from - 1))
! 	      && !char_quoted (from - 1))
  	    {
  	      /* we must record the comment style encountered so that
--- 918,939 ----
  
  	  from--;
! 	  if (char_quoted (from))
! 	    { from--; continue; }
! 
  	  c = FETCH_CHAR (from);
  	  code = SYNTAX (c);
! 	  mask = 0x0;
! 
! 	  if (code == Sendcomment)
! 	    {
! 	      /* we have found a single char end comment. we must record
! 		 the comment style encountered so that later, we can match
! 		 only the proper comment begin sequence of the same style */
! 	      mask = SYNTAX_COMMENT_1CHAR_MASK (c);
! 	    }
! 
! 	  else if (from > stop
! 		   && SYNTAX_END_P (FETCH_CHAR (from-1), c)
! 		   && !char_quoted (from - 1))
  	    {
  	      /* we must record the comment style encountered so that
***************
*** 674,821 ****
  		 sequence of the same style */
  	      code = Sendcomment;
! 	      comstyle = SYNTAX_COMMENT_STYLE (FETCH_CHAR (from - 1));
  	      from--;
  	    }
  
! 	  if (code == Sendcomment && !quoted)
! 	    {
! 	      if (code != SYNTAX (c))
! 		/* For a two-char comment ender, we can assume
! 		   it does end a comment.  So scan back in a simple way.  */
! 		{
! 		  if (from != stop) from--;
! 		  while (1)
! 		    {
! 		      if (SYNTAX (c = FETCH_CHAR (from)) == Scomment
! 			  && SYNTAX_COMMENT_STYLE (c) == comstyle)
! 			break;
! 		      if (from == stop)
! 			{
! 			  immediate_quit = 0;
! 			  SET_PT (from);
! 			  return Qnil;
! 			}
! 		      from--;
! 		      if (SYNTAX_COMSTART_SECOND (c)
! 			  && SYNTAX_COMSTART_FIRST (FETCH_CHAR (from))
! 			  && SYNTAX_COMMENT_STYLE (c) == comstyle
! 			  && !char_quoted (from))
! 			break;
! 		    }
! 		  break;
! 		}
! 
! 	      /* Look back, counting the parity of string-quotes,
! 		 and recording the comment-starters seen.
! 		 When we reach a safe place, assume that's not in a string;
! 		 then step the main scan to the earliest comment-starter seen
! 		 an even number of string quotes away from the safe place.
! 
! 		 OFROM[I] is position of the earliest comment-starter seen
! 		 which is I+2X quotes from the comment-end.
! 		 PARITY is current parity of quotes from the comment end.  */
! 	      {
! 		int parity = 0;
! 		char my_stringend = 0;
! 		int string_lossage = 0;
! 		int comment_end = from;
! 		int comstart_pos = 0;
! 		int comstart_parity = 0;
! 
! 		/* At beginning of range to scan, we're outside of strings;
! 		   that determines quote parity to the comment-end.  */
! 		while (from != stop)
! 		  {
! 		    /* Move back and examine a character.  */
! 		    from--;
! 
! 		    c = FETCH_CHAR (from);
! 		    code = SYNTAX (c);
! 
! 		    /* If this char is the second of a 2-char comment sequence,
! 		       back up and give the pair the appropriate syntax.  */
! 		    if (from > stop && SYNTAX_COMEND_SECOND (c)
! 			&& SYNTAX_COMEND_FIRST (FETCH_CHAR (from - 1)))
! 		      {
! 			code = Sendcomment;
! 			from--;
! 		      }
! 			
! 		    else if (from > stop && SYNTAX_COMSTART_SECOND (c)
! 			     && SYNTAX_COMSTART_FIRST (FETCH_CHAR (from - 1))
! 			     && comstyle == SYNTAX_COMMENT_STYLE (c))
! 		      {
! 			code = Scomment;
! 			from--;
! 		      }
! 
! 		    /* Ignore escaped characters.  */
! 		    if (char_quoted (from))
! 		      continue;
! 
! 		    /* Track parity of quotes.  */
! 		    if (code == Sstring)
! 		      {
! 			parity ^= 1;
! 			if (my_stringend == 0)
! 			  my_stringend = c;
! 			/* If we have two kinds of string delimiters.
! 			   There's no way to grok this scanning backwards.  */
! 			else if (my_stringend != c)
! 			  string_lossage = 1;
! 		      }
! 
! 		    /* Record comment-starters according to that
! 		       quote-parity to the comment-end.  */
! 		    if (code == Scomment)
! 		      {
! 			comstart_parity = parity;
! 			comstart_pos = from;
! 		      }
! 
! 		    /* If we find another earlier comment-ender,
! 		       any comment-starts earier than that don't count
! 		       (because they go with the earlier comment-ender).  */
! 		    if (code == Sendcomment
! 			&& SYNTAX_COMMENT_STYLE (FETCH_CHAR (from)) == comstyle)
! 		      break;
! 
! 		    /* Assume a defun-start point is outside of strings.  */
! 		    if (code == Sopen
! 			&& (from == stop || FETCH_CHAR (from - 1) == '\n'))
! 		      break;
! 		  }
  
! 		if (comstart_pos == 0)
! 		  from = comment_end;
! 		/* If the earliest comment starter
! 		   is followed by uniform paired string quotes or none,
! 		   we know it can't be inside a string
! 		   since if it were then the comment ender would be inside one.
! 		   So it does start a comment.  Skip back to it.  */
! 		else if (comstart_parity == 0 && !string_lossage)
! 		  from = comstart_pos;
! 		else
! 		  {
! 		    /* We had two kinds of string delimiters mixed up
! 		       together.  Decode this going forwards.
! 		       Scan fwd from the previous comment ender
! 		       to the one in question; this records where we
! 		       last passed a comment starter.  */
! 		    struct lisp_parse_state state;
! 		    scan_sexps_forward (&state, find_defun_start (comment_end),
! 					comment_end - 1, -10000, 0, Qnil);
! 		    if (state.incomment)
! 		      from = state.comstart;
! 		    else
! 		      /* We can't grok this as a comment; scan it normally.  */
! 		      from = comment_end;
! 		  }
! 	      }
! 	    }
! 	  else if ((code != Swhitespace && code != Scomment) || quoted)
  	    {
  	      immediate_quit = 0;
! 	      SET_PT (from + 1);
  	      return Qnil;
  	    }
--- 941,957 ----
  		 sequence of the same style */
  	      code = Sendcomment;
! 	      mask = SYNTAX_COMMENT_MASK_END (FETCH_CHAR (from-1), c);
  	      from--;
  	    }
  
! 	  if (code == Sendcomment)
! 	    from = find_start_of_comment (from, stop, mask);
  
! 	  else if (code != Swhitespace &&
! 		   SYNTAX (c) != Scomment &&
! 		   SYNTAX (c) != Sendcomment)
  	    {
  	      immediate_quit = 0;
! 	      SET_PT (from);
  	      return Qnil;
  	    }
***************
*** 822,826 ****
  	}
  
!       count1++;
      }
  
--- 958,962 ----
  	}
  
!       count++;
      }
  
