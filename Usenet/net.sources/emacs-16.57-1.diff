Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Posting-Version: version B 2.10.3 4.3bsd-beta 6/6/85; site ucbvax.ARPA
Path: utzoo!watmath!clyde!burl!ulysses!ucbvax!phr
From: p...@ucbvax.ARPA (Paul Rubin)
Newsgroups: net.sources
Subject: GNU Emacs diffs 16.56=>16.60, part 1 of 2
Message-ID: <10463@ucbvax.ARPA>
Date: Wed, 25-Sep-85 02:51:29 EDT
Article-I.D.: ucbvax.10463
Posted: Wed Sep 25 02:51:29 1985
Date-Received: Thu, 26-Sep-85 07:45:51 EDT
Organization: University of California at Berkeley
Lines: 1600

Changes to .c files in emacs/src directory
to fix bugs in advertised features since 16.56.
After installing these changes, rebuild Emacs.
You will get version 16.57.

The patches to .el files follow at the end, with a line
of equal-signs to separate them.  The two sets of patches
must be used together, or bad things will happen.

This is supposed to be a long line.  If it does not end in "foo", it means you have done something to truncate it, and will lose.  Foo!

diff -cbr /u2/emacs/dist-16.56/src/abbrev.c /u2/emacs/dist/src/abbrev.c
*** /u2/emacs/dist-16.56/src/abbrev.c	Sun Jul 14 02:36:51 1985
--- /u2/emacs/dist/src/abbrev.c	Mon Sep 16 16:03:12 1985
***************
*** 137,143
    (name, expansion)
       Lisp_Object name, expansion;
  {
!   Fdefine_abbrev (Vglobal_abbrev_table, name, expansion, Qnil);
    return name;
  }
  

--- 137,143 -----
    (name, expansion)
       Lisp_Object name, expansion;
  {
!   Fdefine_abbrev (Vglobal_abbrev_table, name, expansion, Qnil, make_number (0));
    return name;
  }
  
***************
*** 150,156
    if (NULL (bf_cur->abbrev_table))
      error ("No local abbrev table associated with this buffer");
  
!   Fdefine_abbrev (bf_cur->abbrev_table, name, expansion, Qnil);
    return name;
  }
  

--- 150,156 -----
    if (NULL (bf_cur->abbrev_table))
      error ("No local abbrev table associated with this buffer");
  
!   Fdefine_abbrev (bf_cur->abbrev_table, name, expansion, Qnil, make_number (0));
    return name;
  }
  
***************
*** 355,361
        Findent_to (make_number (45), one);
        Fprin1 (XSYMBOL (sym)->function, stream);
      }
!   Fterpri (Qnil);
  }
  
  DEFUN ("insert-abbrev-table-description",

--- 355,361 -----
        Findent_to (make_number (45), one);
        Fprin1 (XSYMBOL (sym)->function, stream);
      }
!   Fterpri (stream);
  }
  
  DEFUN ("insert-abbrev-table-description",
diff -cbr /u2/emacs/dist-16.56/src/buffer.c /u2/emacs/dist/src/buffer.c
*** /u2/emacs/dist-16.56/src/buffer.c	Mon Jul 15 13:35:10 1985
--- /u2/emacs/dist/src/buffer.c	Mon Sep 16 16:03:17 1985
***************
*** 522,528
    record_buffer (buf);
  
    Fshow_buffer (EQ (selected_window, minibuf_window)
! 		  ? Fnext_window (minibuf_window) : selected_window,
  		buf);
  
    return Qnil;

--- 522,528 -----
    record_buffer (buf);
  
    Fshow_buffer (EQ (selected_window, minibuf_window)
! 		  ? Fnext_window (minibuf_window, Qnil) : selected_window,
  		buf);
  
    return Qnil;
***************
*** 650,656
    /* Vcheck_symbol is set up to the symbol paragraph-start
       in order to check for the bug that clobbers it.  */
    if (c && EQ (c->major_mode, Qlisp_mode)
!       && Vcheck_symbol
        && !NULL (Vcheck_symbol))
      {
        valcontents = XSYMBOL (Vcheck_symbol)->value;

--- 650,656 -----
    /* Vcheck_symbol is set up to the symbol paragraph-start
       in order to check for the bug that clobbers it.  */
    if (c && EQ (c->major_mode, Qlisp_mode)
!       && XFASTINT (Vcheck_symbol) != 0
        && !NULL (Vcheck_symbol))
      {
        valcontents = XSYMBOL (Vcheck_symbol)->value;
***************
*** 912,918
  
  init_buffer ()
  {
!   char buf[MAXPATHLEN];
  
    Fset_buffer (Fget_buffer_create (build_string ("*scratch*")));
    getwd(buf);

--- 912,918 -----
  
  init_buffer ()
  {
!   char buf[MAXPATHLEN+1];
  
    Fset_buffer (Fget_buffer_create (build_string ("*scratch*")));
    getwd(buf);
diff -cbr /u2/emacs/dist-16.56/src/dired.c /u2/emacs/dist/src/dired.c
*** /u2/emacs/dist-16.56/src/dired.c	Thu Jun 13 23:23:13 1985
--- /u2/emacs/dist/src/dired.c	Mon Sep 16 16:03:22 1985
***************
*** 197,202
  		  p2 = (unsigned char *) dp->d_name;
  		  for (matchsize = 0; matchsize < compare; matchsize++)
  		    if (p1[matchsize] != p2[matchsize]) break;
  		  if (directoryp  &&
  		      (bestmatchsize > matchsize) &&
  		      (p1[matchsize + 1] == '/'))

--- 197,204 -----
  		  p2 = (unsigned char *) dp->d_name;
  		  for (matchsize = 0; matchsize < compare; matchsize++)
  		    if (p1[matchsize] != p2[matchsize]) break;
+ 		  /* If this dirname all matches,
+ 		     see if implicit following slash does too.  */
  		  if (directoryp  &&
  		      compare == matchsize &&
  		      bestmatchsize > matchsize &&
***************
*** 198,205
  		  for (matchsize = 0; matchsize < compare; matchsize++)
  		    if (p1[matchsize] != p2[matchsize]) break;
  		  if (directoryp  &&
! 		      (bestmatchsize > matchsize) &&
! 		      (p1[matchsize + 1] == '/'))
  		    matchsize++;
  		  bestmatchsize = min (matchsize, bestmatchsize);
  		}

--- 200,208 -----
  		  /* If this dirname all matches,
  		     see if implicit following slash does too.  */
  		  if (directoryp  &&
! 		      compare == matchsize &&
! 		      bestmatchsize > matchsize &&
! 		      p1[matchsize] == '/')
  		    matchsize++;
  		  bestmatchsize = min (matchsize, bestmatchsize);
  		}
diff -cbr /u2/emacs/dist-16.56/src/dispnew.c /u2/emacs/dist/src/dispnew.c
*** /u2/emacs/dist-16.56/src/dispnew.c	Mon Jul 15 14:38:43 1985
--- /u2/emacs/dist/src/dispnew.c	Mon Sep 16 16:03:25 1985
***************
*** 604,613
    register int i;
  
    int free_at_end_vpos = screen_height;
-   if (scroll_region_ok)
-     free_at_end_vpos -= unchanged_at_bottom;
-   else if (memory_below_screen)
-     free_at_end_vpos = -1;
    
    /* Compute hash codes of all the lines.
       Also calculate number of changed lines,

--- 604,609 -----
    register int i;
  
    int free_at_end_vpos = screen_height;
    
    /* Compute hash codes of all the lines.
       Also calculate number of changed lines,
***************
*** 642,647
  
    window_size = screen_height - unchanged_at_top - unchanged_at_bottom;
  
    /* If large window, fast terminal and few lines in common between
       PhysScreen and DesiredScreen, don't bother with i/d calc.  */
    if (window_size >= 18 && baud_rate > 2400

--- 638,648 -----
  
    window_size = screen_height - unchanged_at_top - unchanged_at_bottom;
  
+   if (scroll_region_ok)
+     free_at_end_vpos -= unchanged_at_bottom;
+   else if (memory_below_screen)
+     free_at_end_vpos = -1;
+ 
    /* If large window, fast terminal and few lines in common between
       PhysScreen and DesiredScreen, don't bother with i/d calc.  */
    if (window_size >= 18 && baud_rate > 2400
***************
*** 815,820
        topos (vpos, nsp + m1);
        if (!m2 || nlen == olen)
  	{
  	  /* If the text reaches to the right margin,
  	     it will lose one way or another (depending on AutoWrap)
  	     to clear to end of line after outputting all the text.

--- 816,832 -----
        topos (vpos, nsp + m1);
        if (!m2 || nlen == olen)
  	{
+ 	  /* If new text being written reaches right margin,
+ 	     there is no need to do clear-to-eol at the end.
+ 	     (and it would not be safe, since cursor is not
+ 	     going to be "at the margin" after the text is done) */
+ 	  if (nlen == screen_width)
+ 	    olen = 0;
+ 	  write_chars (nbody + nsp + m1, nlen - tem);
+ #ifdef obsolete
+ /* the following code loses disastrously if tem == nlen.
+    Rather than trying to fix that case, I am trying the simpler
+    solution found above.  */
  	  /* If the text reaches to the right margin,
  	     it will lose one way or another (depending on AutoWrap)
  	     to clear to end of line after outputting all the text.
***************
*** 829,834
  	    }
  	  else
  	    write_chars (nbody + nsp + m1, nlen - tem);
  	}
        else if (nlen > olen)
  	{

--- 841,847 -----
  	    }
  	  else
  	    write_chars (nbody + nsp + m1, nlen - tem);
+ #endif
  	}
        else if (nlen > olen)
  	{
diff -cbr /u2/emacs/dist-16.56/src/doc.c /u2/emacs/dist/src/doc.c
*** /u2/emacs/dist-16.56/src/doc.c	Tue Jul  2 01:00:24 1985
--- /u2/emacs/dist/src/doc.c	Mon Sep 16 18:16:50 1985
***************
*** 202,207
    return Qnil;
  }
  
  DEFUN ("substitute-command-keys", Fsubstitute_command_keys,
    Ssubstitute_command_keys, 1, 1, 0,
    "Return the STRING with substrings of the form \\=\\[COMMAND]\n\

--- 202,209 -----
    return Qnil;
  }
  
+ extern Lisp_Object where_is_in_buffer ();
+ 
  DEFUN ("substitute-command-keys", Fsubstitute_command_keys,
    Ssubstitute_command_keys, 1, 1, 0,
    "Return the STRING with substrings of the form \\=\\[COMMAND]\n\
***************
*** 253,259
  	  func = strp - funp;
  
  	  key = Fintern (make_string (funp, func), Qnil);
! 	  key = Fcar (Fwhere_is_internal (key));
  	  strp++;			/* skip ] */
  
  	win:

--- 255,261 -----
  	  func = strp - funp;
  
  	  key = Fintern (make_string (funp, func), Qnil);
! 	  key = Fcar (where_is_in_buffer (key, bf_cur));
  	  strp++;			/* skip ] */
  
  	win:
diff -cbr /u2/emacs/dist-16.56/src/editfns.c /u2/emacs/dist/src/editfns.c
*** /u2/emacs/dist-16.56/src/editfns.c	Sun Jul 14 05:41:31 1985
--- /u2/emacs/dist/src/editfns.c	Mon Sep 16 16:03:30 1985
***************
*** 67,73
    strncpy (user_full_name, USER_FULL_NAME, sizeof user_full_name);
    p = index (user_full_name, ',');
    if (p) *p = 0;
! #endif
  
  #ifdef AMPERSAND_FULL_NAME
    p = pw->pw_gecos; q = user_full_name; r = USER_FULL_NAME; first = 1;

--- 67,74 -----
    strncpy (user_full_name, USER_FULL_NAME, sizeof user_full_name);
    p = index (user_full_name, ',');
    if (p) *p = 0;
! #else
!   p = pw->pw_gecos; q = user_full_name; r = user_name; first = 1;
  
    for (; (*p != 0) && (*p != ','); p++)
      {
***************
*** 69,78
    if (p) *p = 0;
  #endif
  
! #ifdef AMPERSAND_FULL_NAME
!   p = pw->pw_gecos; q = user_full_name; r = USER_FULL_NAME; first = 1;
! 
!   while (1)
      {
        switch (*p)
  	{

--- 70,76 -----
  #else
    p = pw->pw_gecos; q = user_full_name; r = user_name; first = 1;
  
!   for (; (*p != 0) && (*p != ','); p++)
      {
        if (*p == '&')
  	{
***************
*** 74,80
  
    while (1)
      {
!       switch (*p)
  	{
  	case 0:
  	  break;

--- 72,78 -----
  
    for (; (*p != 0) && (*p != ','); p++)
      {
!       if (*p == '&')
  	{
  	  if (*r != 0)
  	    {
***************
*** 76,89
      {
        switch (*p)
  	{
! 	case 0:
! 	  break;
! 	case ',':
! 	  c = 0; break;
! 	case '&':
! 	  c = *r++;
! 	  if ((! --first) && (c > 'Z')) c -= 32;
! 	  if (c == 0)
  	    {
  	      p++;
  	      c = -1;

--- 74,80 -----
      {
        if (*p == '&')
  	{
! 	  if (*r != 0)
  	    {
  	      *q = *r++;
  	      if ((*q >= 'a') && (*q <= 'z'))
***************
*** 85,93
  	  if ((! --first) && (c > 'Z')) c -= 32;
  	  if (c == 0)
  	    {
! 	      p++;
! 	      c = -1;
! 	    }
  	  break;
  	default:
  	  c = *p++;

--- 76,87 -----
  	{
  	  if (*r != 0)
  	    {
! 	      *q = *r++;
! 	      if ((*q >= 'a') && (*q <= 'z'))
! 		*q -= 32;
! 	      for (q++; *r != 0; r++)
! 		{
! 		  if (q == &user_full_name[sizeof user_full_name - 1])
  	  break;
  		  *q++ = *r;
  	}
***************
*** 89,96
  	      c = -1;
  	    }
  	  break;
! 	default:
! 	  c = *p++;
  	}
        /*Putnextchar:*/
        if (c >= 0)

--- 83,89 -----
  		{
  		  if (q == &user_full_name[sizeof user_full_name - 1])
  	  break;
! 		  *q++ = *r;
  	}
  	    }
  	}
***************
*** 92,101
  	default:
  	  c = *p++;
  	}
!       /*Putnextchar:*/
!       if (c >= 0)
! 	*q++ = c;
!       if (c == 0 || q == &user_full_name[sizeof user_full_name - 1])
  	break;
      }
    *q = 0;

--- 85,95 -----
  	  break;
  		  *q++ = *r;
  	}
! 	    }
! 	}
!       else
! 	*q++ = *p;
!       if (q == &user_full_name[sizeof user_full_name - 2])
  	break;
      }
    *q = 0;
diff -cbr /u2/emacs/dist-16.56/src/minibuf.c /u2/emacs/dist/src/minibuf.c
*** /u2/emacs/dist-16.56/src/minibuf.c	Mon Jul 15 14:46:38 1985
--- /u2/emacs/dist/src/minibuf.c	Mon Sep 16 16:03:35 1985
***************
*** 199,205
    Vhelp_form = minibuf_save_vector[MinibufDepth].help_form;
  }
  
! DEFUN ("read-from-minibuffer", Fread_from_minibuffer, Sread_from_minibuffer, 1, 3, 0,
    "Read a string from the minibuffer, prompting with string PROMPT.\n\
  If optional second arg INITIAL-CONTENTS is non-nil, it is a string\n\
    to be inserted into the minibuffer before reading input.\n\

--- 199,205 -----
    Vhelp_form = minibuf_save_vector[MinibufDepth].help_form;
  }
  
! DEFUN ("read-from-minibuffer", Fread_from_minibuffer, Sread_from_minibuffer, 1, 4, 0,
    "Read a string from the minibuffer, prompting with string PROMPT.\n\
  If optional second arg INITIAL-CONTENTS is non-nil, it is a string\n\
    to be inserted into the minibuffer before reading input.\n\
diff -cbr /u2/emacs/dist-16.56/src/print.c /u2/emacs/dist/src/print.c
*** /u2/emacs/dist-16.56/src/print.c	Tue Jun 11 18:57:32 1985
--- /u2/emacs/dist/src/print.c	Mon Sep 16 16:03:37 1985
***************
*** 34,39
  /* Avoid actual stack overflow in print.  */
  int print_depth;
  
  /* Nonzero means print newline before next minibuffer message.  */
  
  int noninteractive_need_newline;

--- 34,44 -----
  /* Avoid actual stack overflow in print.  */
  int print_depth;
  
+ /* Maximum length of list to print in full; noninteger means
+    effectively infinity */
+ 
+ Lisp_Object Vprint_length;
+ 
  /* Nonzero means print newline before next minibuffer message.  */
  
  int noninteractive_need_newline;
***************
*** 454,460
      case Lisp_Cons:
        PRINTCHAR ('(');
        {
! 	int i = 0;
  	while (LISTP (obj))
  	  {
  	    if (i++)

--- 459,469 -----
      case Lisp_Cons:
        PRINTCHAR ('(');
        {
! 	register int i = 0;
! 	register int max = 0;
! 
! 	if (XTYPE (Vprint_length) == Lisp_Int)
! 	  max = XINT (Vprint_length);
  	while (LISTP (obj))
  	  {
  	    if (i++)
***************
*** 459,464
  	  {
  	    if (i++)
  	      PRINTCHAR (' ');
  	    print (Fcar (obj), printcharfun, escapeflag, 0);
  	    obj = Fcdr (obj);
  	  }

--- 468,478 -----
  	  {
  	    if (i++)
  	      PRINTCHAR (' ');
+ 	    if (max && i >= max)
+ 	      {
+ 		strout ("...", 3, printcharfun);
+ 		break;
+ 	      }
  	    print (Fcar (obj), printcharfun, escapeflag, 0);
  	    obj = Fcdr (obj);
  	  }
***************
*** 463,469
  	    obj = Fcdr (obj);
  	  }
        }
!       if (!NULL (obj))
  	{
  	  strout (" . ", 3, printcharfun);
  	  print (obj, printcharfun, escapeflag, 0);

--- 477,483 -----
  	    obj = Fcdr (obj);
  	  }
        }
!       if (!NULL (obj) && !LISTP (obj))
  	{
  	  strout (" . ", 3, printcharfun);
  	  print (obj, printcharfun, escapeflag, 0);
***************
*** 557,562
    Vstandard_output = Qt;
    Qstandard_output = intern ("standard-output");
    staticpro (&Qstandard_output);
    
    /* prin1_to_string_buffer initialized in init_buffer_once in buffer.c */
    staticpro (&Vprin1_to_string_buffer);

--- 571,581 -----
    Vstandard_output = Qt;
    Qstandard_output = intern ("standard-output");
    staticpro (&Qstandard_output);
+ 
+   DefLispVar ("print-length", &Vprint_length,
+     "Maximum length of list to print before abbreviating.\
+ `nil' means no limit.");
+   Vprint_length = Qnil;
    
    /* prin1_to_string_buffer initialized in init_buffer_once in buffer.c */
    staticpro (&Vprin1_to_string_buffer);
diff -cbr /u2/emacs/dist-16.56/src/process.c /u2/emacs/dist/src/process.c
*** /u2/emacs/dist-16.56/src/process.c	Thu Jul 11 13:36:52 1985
--- /u2/emacs/dist/src/process.c	Mon Sep 16 16:03:43 1985
***************
*** 38,43
  #include "window.h"
  #include "buffer.h"
  #include "process.h"
  
  extern errno;
  extern sys_nerr;

--- 38,47 -----
  #include "window.h"
  #include "buffer.h"
  #include "process.h"
+   
+ #ifdef howmany				/* in sys/types.h under 4.3 BSD */
+ #undef howmany
+ #endif
  
  extern errno;
  extern sys_nerr;
***************
*** 685,691
  deactivate_process (proc)
       Lisp_Object proc;
  {
!   register int inchannel;
    register struct Lisp_Process *p = XPROCESS (proc);
  
    inchannel = XFASTINT (p->infd);

--- 689,695 -----
  deactivate_process (proc)
       Lisp_Object proc;
  {
!   register int inchannel, outchannel;
    register struct Lisp_Process *p = XPROCESS (proc);
  
    inchannel = XFASTINT (p->infd);
***************
*** 689,694
    register struct Lisp_Process *p = XPROCESS (proc);
  
    inchannel = XFASTINT (p->infd);
  
    if (inchannel)
      {

--- 693,699 -----
    register struct Lisp_Process *p = XPROCESS (proc);
  
    inchannel = XFASTINT (p->infd);
+   outchannel = XFASTINT (p->outfd);
  
    if (inchannel)
      {
***************
*** 694,701
      {
        ioctl (inchannel, TIOCFLUSH, 0);	/* flush any pending output */
        close (inchannel);
!       if (XFASTINT (p->outfd) != inchannel)
! 	close (XFASTINT (p->outfd));
  
        XFASTINT (p->infd) = 0;
        XFASTINT (p->outfd) = 0;

--- 699,706 -----
      {
        ioctl (inchannel, TIOCFLUSH, 0);	/* flush any pending output */
        close (inchannel);
!       if (outchannel  &&  outchannel != inchannel)
!  	close (outchannel);
  
        XFASTINT (p->infd) = 0;
        XFASTINT (p->outfd) = 0;
***************
*** 802,807
  	{
  	  if (errno == EINTR)
  	    Available = 0;
  	  else
  	    error("select error: %s", sys_errlist[errno]);
  	}

--- 807,814 -----
  	{
  	  if (errno == EINTR)
  	    Available = 0;
+ 	  else if (errno == EBADF)
+ 	    abort ();
  	  else
  	    error("select error: %s", sys_errlist[errno]);
  	}
***************
*** 911,916
      {
        Fset_buffer (p->buffer);
        odot = dot;
        SetDot (NumCharacters + 1);
        if (odot == dot) odot = -1;
        InsCStr (chars, howmany);

--- 918,930 -----
      {
        Fset_buffer (p->buffer);
        odot = dot;
+ 
+       /* Insert new output into buffer
+ 	 at the current end-of-output marker,
+ 	 thus preserving logical ordering of input and output.  */
+       if (XMARKER (p->mark)->buffer)
+ 	SetDot (marker_position (p->mark));
+       else
        SetDot (NumCharacters + 1);
        if (dot <= odot)
  	odot += howmany;
***************
*** 912,918
        Fset_buffer (p->buffer);
        odot = dot;
        SetDot (NumCharacters + 1);
!       if (odot == dot) odot = -1;
        InsCStr (chars, howmany);
        Fset_marker (p->mark, make_number (dot), p->buffer);
        RedoModes++;

--- 926,934 -----
  	SetDot (marker_position (p->mark));
        else
        SetDot (NumCharacters + 1);
!       if (dot <= odot)
! 	odot += howmany;
! 
        InsCStr (chars, howmany);
        Fset_marker (p->mark, make_number (dot), p->buffer);
        RedoModes++;
***************
*** 917,923
        Fset_marker (p->mark, make_number (dot), p->buffer);
        RedoModes++;
  
-       if (odot >= 0)
  	SetDot (odot);
        SetBfp (old);
      }

--- 933,938 -----
        Fset_marker (p->mark, make_number (dot), p->buffer);
        RedoModes++;
  
  	SetDot (odot);
        SetBfp (old);
      }
diff -cbr /u2/emacs/dist-16.56/src/regex.c /u2/emacs/dist/src/regex.c
*** /u2/emacs/dist-16.56/src/regex.c	Mon Jul 15 15:33:02 1985
--- /u2/emacs/dist/src/regex.c	Mon Sep 16 16:03:49 1985
***************
*** 764,770
       int size, startpos, range;
       struct re_registers *regs;
  {
!   return re_search_2 (pbufp, 0, 0, string, size, startpos, range, regs);
  }
  
  /* Like re_match_2 but tries first a match starting at index `startpos',

--- 764,770 -----
       int size, startpos, range;
       struct re_registers *regs;
  {
!   return re_search_2 (pbufp, 0, 0, string, size, startpos, range, regs, size);
  }
  
  /* Like re_match_2 but tries first a match starting at index `startpos',
***************
*** 779,785
   or -1 if no match was found. */
  
  int
! re_search_2 (pbufp, string1, size1, string2, size2, startpos, range, regs)
       struct re_pattern_buffer *pbufp;
       char *string1, *string2;
       int size1, size2;

--- 779,785 -----
   or -1 if no match was found. */
  
  int
! re_search_2 (pbufp, string1, size1, string2, size2, startpos, range, regs, mstop)
       struct re_pattern_buffer *pbufp;
       char *string1, *string2;
       int size1, size2;
***************
*** 786,791
       int startpos;
       register int range;
       struct re_registers *regs;
  {
    register char *fastmap = pbufp->fastmap;
    register char *translate = pbufp->translate;

--- 786,792 -----
       int startpos;
       register int range;
       struct re_registers *regs;
+      int mstop;
  {
    register char *fastmap = pbufp->fastmap;
    register char *translate = pbufp->translate;
***************
*** 841,847
  	  && fastmap && !pbufp->can_be_null)
  	return -1;
  
!       if (0 <= re_match_2 (pbufp, string1, size1, string2, size2, startpos, regs))
  	return startpos;
  
      advance:

--- 842,848 -----
  	  && fastmap && !pbufp->can_be_null)
  	return -1;
  
!       if (0 <= re_match_2 (pbufp, string1, size1, string2, size2, startpos, regs, mstop))
  	return startpos;
  
      advance:
***************
*** 857,863
       int size, pos;
       struct re_registers *regs;
  {
!   return re_match_2 (pbufp, 0, 0, string, size, pos, regs);
  }
  
  /* Match the pattern described by `pbufp'

--- 858,864 -----
       int size, pos;
       struct re_registers *regs;
  {
!   return re_match_2 (pbufp, 0, 0, string, size, pos, regs, size);
  }
  
  /* Match the pattern described by `pbufp'
***************
*** 863,868
  /* Match the pattern described by `pbufp'
    against data which is the virtual concatenation of `string1' and `string2'.
    `size1' and `size2' are the sizes of the two data strings.
  
    If pbufp->fastmap is nonzero, then it had better be up to date.
  

--- 864,871 -----
  /* Match the pattern described by `pbufp'
    against data which is the virtual concatenation of `string1' and `string2'.
    `size1' and `size2' are the sizes of the two data strings.
+   Start the match at position `pos'.
+   Do not consider matching past the position `mstop'.
  
    If pbufp->fastmap is nonzero, then it had better be up to date.
  
***************
*** 875,881
  */
  
  int
! re_match_2 (pbufp, string1, size1, string2, size2, pos, regs)
       struct re_pattern_buffer *pbufp;
       char *string1, *string2;
       int size1, size2;

--- 878,884 -----
  */
  
  int
! re_match_2 (pbufp, string1, size1, string2, size2, pos, regs, mstop)
       struct re_pattern_buffer *pbufp;
       char *string1, *string2;
       int size1, size2;
***************
*** 881,886
       int size1, size2;
       int pos;
       struct re_registers *regs;
  {
    register char *p = pbufp->buffer;
    register char *pend = p + pbufp->used;

--- 884,890 -----
       int size1, size2;
       int pos;
       struct re_registers *regs;
+      int mstop;
  {
    register char *p = pbufp->buffer;
    register char *pend = p + pbufp->used;
***************
*** 888,893
    char *end1;
    /* End of second string */
    char *end2;
    register char *d, *dend;
    register int mcnt;
    char *translate = pbufp->translate;

--- 892,899 -----
    char *end1;
    /* End of second string */
    char *end2;
+   /* Pointer just past last char to consider matching */
+   char *end_match_1, *end_match_2;
    register char *d, *dend;
    register int mcnt;
    char *translate = pbufp->translate;
***************
*** 932,937
    end1 = string1 + size1;
    end2 = string2 + size2;
  
    bzero (regstart, sizeof regstart);
  
    /* `p' scans through the pattern as `d' scans through the data.

--- 938,955 -----
    end1 = string1 + size1;
    end2 = string2 + size2;
  
+   /* Compute where to stop matching, within the two strings */
+   if (mstop <= size1)
+     {
+       end_match_1 = string1 + mstop;
+       end_match_2 = string2;
+     }
+   else
+     {
+       end_match_1 = end1;
+       end_match_2 = string2 + mstop - size1;
+     }
+ 
    bzero (regstart, sizeof regstart);
  
    /* `p' scans through the pattern as `d' scans through the data.
***************
*** 943,949
       but it cannot equal string2.  */
  
    if (pos <= size1)
!     d = string1 + pos, dend = end1;
    else
      d = string2 + pos - size1, dend = end2;
  

--- 961,967 -----
       but it cannot equal string2.  */
  
    if (pos <= size1)
!     d = string1 + pos, dend = end_match_1;
    else
      d = string2 + pos - size1, dend = end_match_2;
  
***************
*** 945,951
    if (pos <= size1)
      d = string1 + pos, dend = end1;
    else
!     d = string2 + pos - size1, dend = end2;
  
  /* Write PREFETCH; just before fetching a character with *d.  */
  #define PREFETCH \

--- 963,969 -----
    if (pos <= size1)
      d = string1 + pos, dend = end_match_1;
    else
!     d = string2 + pos - size1, dend = end_match_2;
  
  /* Write PREFETCH; just before fetching a character with *d.  */
  #define PREFETCH \
***************
*** 950,956
  /* Write PREFETCH; just before fetching a character with *d.  */
  #define PREFETCH \
   while (d == dend)						    \
!   { if (dend == end2) goto fail;  /* end of string2 => failure */   \
      d = string2;  /* end of string1 => advance to string2. */       \
      dend = end2; }
  

--- 968,974 -----
  /* Write PREFETCH; just before fetching a character with *d.  */
  #define PREFETCH \
   while (d == dend)						    \
!   { if (dend == end_match_2) goto fail;  /* end of string2 => failure */   \
      d = string2;  /* end of string1 => advance to string2. */       \
      dend = end_match_2; }
  
***************
*** 952,958
   while (d == dend)						    \
    { if (dend == end2) goto fail;  /* end of string2 => failure */   \
      d = string2;  /* end of string1 => advance to string2. */       \
!     dend = end2; }
  
    /* This loop loops over pattern commands.
       It exits by returning from the function if match is complete,

--- 970,976 -----
   while (d == dend)						    \
    { if (dend == end_match_2) goto fail;  /* end of string2 => failure */   \
      d = string2;  /* end of string1 => advance to string2. */       \
!     dend = end_match_2; }
  
    /* This loop loops over pattern commands.
       It exits by returning from the function if match is complete,
***************
*** 1024,1030
  		/* Advance to next segment in register contents, if necessary */
  		while (d2 == dend2)
  		  {
! 		    if (dend2 == end2) break;
  		    if (dend2 == regend[regno]) break;
  		    d2 = string2, dend2 = regend[regno];  /* end of string1 => advance to string2. */
  		  }

--- 1042,1048 -----
  		/* Advance to next segment in register contents, if necessary */
  		while (d2 == dend2)
  		  {
! 		    if (dend2 == end_match_2) break;
  		    if (dend2 == regend[regno]) break;
  		    d2 = string2, dend2 = regend[regno];  /* end of string1 => advance to string2. */
  		  }
***************
*** 1088,1095
  	  goto fail;
  
  	case endline:
! 	  if (d == dend ? (d == end2 || size2 == 0 || *string2 == '\n')
! 	      : *d == '\n')
  	    break;
  	  goto fail;
  

--- 1106,1113 -----
  	  goto fail;
  
  	case endline:
! 	  if (d == end2
! 	      || (d == end1 ? (size2 == 0 || *string2 == '\n') : *d == '\n'))
  	    break;
  	  goto fail;
  
***************
*** 1177,1183
  
  	case wordbound:
  	  if (d == string1  /* Points to first char */
! 	      || (d == dend && (d == end2 || size2 == 0)))  /* to end */
  	    break;
  	  if ((SYNTAX (d[-1]) == Sword)
  	      != (SYNTAX (d == end1 ? *string2 : *d) == Sword))

--- 1195,1202 -----
  
  	case wordbound:
  	  if (d == string1  /* Points to first char */
! 	      || d == end2  /* Points to end */
! 	      || (d == end1 && size2 == 0)) /* Points to end */
  	    break;
  	  if ((SYNTAX (d[-1]) == Sword)
  	      != (SYNTAX (d == end1 ? *string2 : *d) == Sword))
***************
*** 1186,1192
  
  	case notwordbound:
  	  if (d == string1  /* Points to first char */
! 	      || (d == dend && (d == end2 || size2 == 0)))  /* to end */
  	    goto fail;
  	  if ((SYNTAX (d[-1]) == Sword)
  	      != (SYNTAX (d == end1 ? *string2 : *d) == Sword))

--- 1205,1212 -----
  
  	case notwordbound:
  	  if (d == string1  /* Points to first char */
! 	      || d == end2  /* Points to end */
! 	      || (d == end1 && size2 == 0)) /* Points to end */
  	    goto fail;
  	  if ((SYNTAX (d[-1]) == Sword)
  	      != (SYNTAX (d == end1 ? *string2 : *d) == Sword))
***************
*** 1194,1200
  	  break;
  
  	case wordbeg:
! 	  if ((d == dend && (d == end2 || size2 == 0))  /* to end */
  	      || SYNTAX (d == end1 ? *string2 : *d) != Sword) /* Next char not a letter */
  	    goto fail;
  	  if (d == string1  /* Points to first char */

--- 1214,1221 -----
  	  break;
  
  	case wordbeg:
! 	  if (d == end2  /* Points to end */
! 	      || (d == end1 && size2 == 0) /* Points to end */
  	      || SYNTAX (d == end1 ? *string2 : *d) != Sword) /* Next char not a letter */
  	    goto fail;
  	  if (d == string1  /* Points to first char */
***************
*** 1206,1212
  	  if (d == string1  /* Points to first char */
  	      || SYNTAX (d[-1]) != Sword)  /* prev char not letter */
  	    goto fail;
! 	  if ((d == dend && (d == end2 || size2 == 0))  /* to end */
  	      || SYNTAX (d == end1 ? *string2 : *d) != Sword) /* Next char not a letter */
  	    break;
  	  goto fail;

--- 1227,1234 -----
  	  if (d == string1  /* Points to first char */
  	      || SYNTAX (d[-1]) != Sword)  /* prev char not letter */
  	    goto fail;
! 	  if (d == end2  /* Points to end */
! 	      || (d == end1 && size2 == 0) /* Points to end */
  	      || SYNTAX (d == end1 ? *string2 : *d) != Sword) /* Next char not a letter */
  	    break;
  	  goto fail;
***************
*** 1213,1219
  
  #ifdef emacs
  	case before_dot:
! 	  if (((dend == end2) ? d - (char *) bf_p2 : d - (char *) bf_p1) >= dot)
  	    goto fail;
  	  break;
  

--- 1235,1243 -----
  
  #ifdef emacs
  	case before_dot:
! 	  if (((d - string2 <= (unsigned) size2)
! 	       ? d - (char *) bf_p2 : d - (char *) bf_p1)
! 	      <= dot)
  	    goto fail;
  	  break;
  
***************
*** 1218,1224
  	  break;
  
  	case at_dot:
! 	  if (((dend == end2) ? d - (char *) bf_p2 : d - (char *) bf_p1) == dot)
  	    goto fail;
  	  break;
  

--- 1242,1250 -----
  	  break;
  
  	case at_dot:
! 	  if (((d - string2 <= (unsigned) size2)
! 	       ? d - (char *) bf_p2 : d - (char *) bf_p1)
! 	      == dot)
  	    goto fail;
  	  break;
  
***************
*** 1223,1229
  	  break;
  
  	case after_dot:
! 	  if (((dend == end2) ? d - (char *) bf_p2 : d - (char *) bf_p1) <= dot)
  	    goto fail;
  	  break;
  

--- 1249,1257 -----
  	  break;
  
  	case after_dot:
! 	  if (((d - string2 <= (unsigned) size2)
! 	       ? d - (char *) bf_p2 : d - (char *) bf_p1)
! 	      >= dot)
  	    goto fail;
  	  break;
  
***************
*** 1266,1272
  	  goto fail;
  
  	case endbuf:
! 	  if (d == dend && (d == end2 || size2 == 0))
  	    break;
  	  goto fail;
  

--- 1294,1300 -----
  	  goto fail;
  
  	case endbuf:
! 	  if (d == end2 || (d == end1 && size2 == 0))
  	    break;
  	  goto fail;
  
***************
*** 1309,1315
  	  d = *--stackp;
  	  p = *--stackp;
  	  if (d >= string1 && d <= end1)
! 	    dend = end1;
  	}
        else break;   /* Matching at this starting point really fails! */
      }

--- 1337,1343 -----
  	  d = *--stackp;
  	  p = *--stackp;
  	  if (d >= string1 && d <= end1)
! 	    dend = end_match_1;
  	}
        else break;   /* Matching at this starting point really fails! */
      }
diff -cbr /u2/emacs/dist-16.56/src/search.c /u2/emacs/dist/src/search.c
*** /u2/emacs/dist-16.56/src/search.c	Sat Jun 22 18:41:48 1985
--- /u2/emacs/dist/src/search.c	Mon Sep 16 16:13:57 1985
***************
*** 46,52
  
  /* Compile a regexp and signal a Lisp error if anything goes wrong.  */
  
! compile_pattern (pattern, bufp)
       Lisp_Object pattern;
       struct re_pattern_buffer *bufp;
  {

--- 46,52 -----
  
  /* Compile a regexp and signal a Lisp error if anything goes wrong.  */
  
! compile_pattern (pattern, bufp, translate)
       Lisp_Object pattern;
       struct re_pattern_buffer *bufp;
       char *translate;
***************
*** 49,54
  compile_pattern (pattern, bufp)
       Lisp_Object pattern;
       struct re_pattern_buffer *bufp;
  {
    char *val;
  

--- 49,55 -----
  compile_pattern (pattern, bufp, translate)
       Lisp_Object pattern;
       struct re_pattern_buffer *bufp;
+      char *translate;
  {
    char *val;
  
***************
*** 52,58
  {
    char *val;
  
!   if (EQ (pattern, last_regexp))
      return;
    last_regexp = Qnil;
    val = re_compile_pattern (XSTRING (pattern)->data,

--- 53,60 -----
  {
    char *val;
  
!   if (EQ (pattern, last_regexp)
!       && translate == bufp->translate)
      return;
    last_regexp = Qnil;
    bufp->translate = translate;
***************
*** 55,60
    if (EQ (pattern, last_regexp))
      return;
    last_regexp = Qnil;
    val = re_compile_pattern (XSTRING (pattern)->data,
  			    XSTRING (pattern)->size,
  			    bufp);

--- 57,63 -----
        && translate == bufp->translate)
      return;
    last_regexp = Qnil;
+   bufp->translate = translate;
    val = re_compile_pattern (XSTRING (pattern)->data,
  			    XSTRING (pattern)->size,
  			    bufp);
***************
*** 83,90
    register int i;
  
    CHECK_STRING (string, 0);
!   searchbuf.translate = !NULL (bf_cur->case_fold_search) ? (char *) downcase_table : 0;
!   compile_pattern (string, &searchbuf);
  
    immediate_quit = 1;
    QUIT;			/* Do a pending quit right away, to avoid paradoxical behavior */

--- 86,93 -----
    register int i;
  
    CHECK_STRING (string, 0);
!   compile_pattern (string, &searchbuf,
! 		   !NULL (bf_cur->case_fold_search) ? (char *) downcase_table : 0);
  
    immediate_quit = 1;
    QUIT;			/* Do a pending quit right away, to avoid paradoxical behavior */
***************
*** 109,115
      }
    
    val = (0 <= re_match_2 (&searchbuf, p1, s1, p2, s2,
! 			  dot - FirstCharacter, &search_regs)
  	 ? Qt : Qnil);
    for (i = 0; i < RE_NREGS; i++)
      {

--- 112,119 -----
      }
    
    val = (0 <= re_match_2 (&searchbuf, p1, s1, p2, s2,
! 			  dot - FirstCharacter, &search_regs,
! 			  NumCharacters + 1 - FirstCharacter)
  	 ? Qt : Qnil);
    for (i = 0; i < RE_NREGS; i++)
      {
***************
*** 140,146
        s = XINT (start);
      }
  
!   compile_pattern (regexp, &searchbuf);
    val = re_search (&searchbuf, XSTRING (string)->data, XSTRING (string)->size,
  			       s, XSTRING (string)->size - s, 0);
    if (val < 0) return Qnil;

--- 144,151 -----
        s = XINT (start);
      }
  
!   compile_pattern (regexp, &searchbuf,
! 		   !NULL (bf_cur->case_fold_search) ? (char *) downcase_table : 0);
    val = re_search (&searchbuf, XSTRING (string)->data, XSTRING (string)->size,
  			       s, XSTRING (string)->size - s, 0);
    if (val < 0) return Qnil;
***************
*** 354,360
    register int i, j;
    unsigned char *p1, *p2;
    int s1, s2;
-   int startpos;
  
    immediate_quit = 1;	/* Quit immediately if user types ^G,
  			   because letting this function finish can take too long. */

--- 359,364 -----
    register int i, j;
    unsigned char *p1, *p2;
    int s1, s2;
  
    immediate_quit = 1;	/* Quit immediately if user types ^G,
  			   because letting this function finish can take too long. */
***************
*** 362,369
  
    if (RE)
      {
!       searchbuf.translate = (char *) trt;
!       compile_pattern (string, &searchbuf);
  
        /* Get pointers and sizes of the two strings
  	 that make up the visible portion of the buffer. */

--- 366,372 -----
  
    if (RE)
      {
!       compile_pattern (string, &searchbuf, (char *) trt);
  
        /* Get pointers and sizes of the two strings
  	 that make up the visible portion of the buffer. */
***************
*** 417,424
  	}
        else
  	{
! 	  startpos = pos;
! 	  while (1)
  	    {
  	      if (pos < lim
  		  || 0 > re_search_2 (&searchbuf, p1, s1, p2, s2,

--- 420,430 -----
  	}
        else
  	{
! 	  if (re_search_2 (&searchbuf, p1, s1, p2, s2,
! 			   pos - FirstCharacter, lim - pos, &search_regs,
! 			   /* Don't allow match past current point */
! 			   pos - FirstCharacter)
! 	      >= 0)
  	    {
  	      j = FirstCharacter - 1;
  	      for (i = 0; i < RE_NREGS; i++)
***************
*** 420,433
  	  startpos = pos;
  	  while (1)
  	    {
- 	      if (pos < lim
- 		  || 0 > re_search_2 (&searchbuf, p1, s1, p2, s2,
- 				      pos - FirstCharacter,
- 				      lim - pos, &search_regs))
- 		{
- 		  immediate_quit = 0;
- 		  return 0;
- 		}
  	      j = FirstCharacter - 1;
  	      if (search_regs.end[0] <= startpos - FirstCharacter)
  		{

--- 426,431 -----
  			   pos - FirstCharacter)
  	      >= 0)
  	    {
  	      j = FirstCharacter - 1;
  	      for (i = 0; i < RE_NREGS; i++)
  		{
***************
*** 429,436
  		  return 0;
  		}
  	      j = FirstCharacter - 1;
- 	      if (search_regs.end[0] <= startpos - FirstCharacter)
- 		{
  		  for (i = 0; i < RE_NREGS; i++)
  		    {
  		      search_regs.start[i] += j;

--- 427,432 -----
  	      >= 0)
  	    {
  	      j = FirstCharacter - 1;
  	      for (i = 0; i < RE_NREGS; i++)
  		{
  		  search_regs.start[i] += j;
***************
*** 436,441
  		      search_regs.start[i] += j;
  		      search_regs.end[i] += j;
  		    }
  		  pos = search_regs.start[0] + 1;
  		  break;
  		}

--- 432,438 -----
  		  search_regs.start[i] += j;
  		  search_regs.end[i] += j;
  		}
+ 	      /* Set pos to the new position. */
  	      pos = search_regs.start[0] + 1;
  	    }
  	  else
***************
*** 437,443
  		      search_regs.end[i] += j;
  		    }
  		  pos = search_regs.start[0] + 1;
- 		  break;
  		}
  	      pos = search_regs.start[0] + j;
  	    }

--- 434,439 -----
  		}
  	      /* Set pos to the new position. */
  	      pos = search_regs.start[0] + 1;
  	    }
  	  else
  	    {
***************
*** 439,445
  		  pos = search_regs.start[0] + 1;
  		  break;
  		}
! 	      pos = search_regs.start[0] + j;
  	    }
  	}
        n++;

--- 435,444 -----
  	      /* Set pos to the new position. */
  	      pos = search_regs.start[0] + 1;
  	    }
! 	  else
! 	    {
! 	      immediate_quit = 0;
! 	      return 0;
  	    }
  	}
        n++;
***************
*** 482,488
        else
  	{
  	  if (re_search_2 (&searchbuf, p1, s1, p2, s2,
! 			   pos - FirstCharacter, lim - pos, &search_regs)
  	      >= 0)
  	    {
  	      j = FirstCharacter - 1;

--- 481,488 -----
        else
  	{
  	  if (re_search_2 (&searchbuf, p1, s1, p2, s2,
! 			   pos - FirstCharacter, lim - pos, &search_regs,
! 			   NumCharacters + 1 - FirstCharacter)
  	      >= 0)
  	    {
  	      j = FirstCharacter - 1;
diff -cbr /u2/emacs/dist-16.56/src/syntax.c /u2/emacs/dist/src/syntax.c
*** /u2/emacs/dist-16.56/src/syntax.c	Sun Jul 14 02:31:47 1985
--- /u2/emacs/dist/src/syntax.c	Mon Sep 16 16:08:46 1985
***************
*** 324,330
      {
        while (1)
  	{
! 	  if (from == end) return 0;
  	  if (SYNTAX(CharAt (from)) == Sword)
  	    break;
  	  from++;

--- 324,334 -----
      {
        while (1)
  	{
! 	  if (from == end)
! 	    {
! 	      immediate_quit = 0;
! 	      return 0;
! 	    }
  	  if (SYNTAX(CharAt (from)) == Sword)
  	    break;
  	  from++;
***************
*** 342,348
      {
        while (1)
  	{
! 	  if (from == beg) return 0;
  	  if (SYNTAX(CharAt (from - 1)) == Sword)
  	    break;
  	  from--;

--- 346,356 -----
      {
        while (1)
  	{
! 	  if (from == beg)
! 	    {
! 	      immediate_quit = 0;
! 	      return 0;
! 	    }
  	  if (SYNTAX(CharAt (from - 1)) == Sword)
  	    break;
  	  from--;
***************
*** 709,714
    register int depth;	/* Paren depth of current scanning location.
  			   level - levelstart equals this except
  			   when the depth becomes negative.  */
    Lisp_Object tem;
  
    immediate_quit = 1;

--- 717,723 -----
    register int depth;	/* Paren depth of current scanning location.
  			   level - levelstart equals this except
  			   when the depth becomes negative.  */
+   int start_quoted = 0;		/* Nonzero means starting after a char quote */
    Lisp_Object tem;
  
    immediate_quit = 1;
***************
*** 718,724
        depth = 0;
        state.instring = -1;
        state.incomment = 0;
-       state.quoted = 0;
      }
    else
      {

--- 727,732 -----
        depth = 0;
        state.instring = -1;
        state.incomment = 0;
      }
    else
      {
***************
*** 740,746
  
        oldstate = Fcdr (oldstate);
        tem = Fcar (oldstate);
!       state.quoted = !NULL (tem);
      }
