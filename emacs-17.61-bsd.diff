diff --git a/ChangeLog b/ChangeLog
deleted file mode 100644
index 7657046..0000000
--- a/ChangeLog
+++ /dev/null
@@ -1,38 +0,0 @@
-Sun Mar 30 14:50:02 1986  Paul Rubin  (phr at calder.berkeley.edu)
-
-	* CHANGES IN THE EMACS DIRECTORY FOR THE 4.3BSD DISTRIBUTION
-	____________________________________________________________
-
-	* src/config.h, src/paths.h:
-	Provide sample versions of these files (see INSTALL for details).
-	These should work on VAXen with vanilla directories.  For other
-	CPU's, you'll have to change config.h; if you've moved directories
-	around, change paths.h.  If you are running the X window system,
-	change ``#undef HAVE_X_WINDOWS'' to ``#define HAVE_X_WINDOWS''
-	in config.h.
-
-	* lisp/mh-e.el (MH mail-handler front end):
-	Replace with latest version (3.3) by ucbvax!larus.  This
-	version incorporates some fixes/improvements that are not
-	yet in the FSF distribution (as of the date above).
-	Share and enjoy.
-
-	* etc/emacs.1 (troff'able man page):
-	Change pathnames in FILES section to reflect where they are
-	in this distribution.
-
-	* INSTALL (installation guide):
-	Say in LOSSAGES section to disregard `BSD redefined' and
-	`BSD4_3 redefined' warning messages.
-
-	* build-install (shell script to build and install emacs):
-	Rearrange the installation part somewhat, since 4.3 systems
-	typically have sources living in a different places from libraries.
-	(Here at Berkeley, sources are all maintained on one machine
-	and libraries are distributed to other machines over a local network;
-	the script is now set up for this kind of environment).
-
-	* README (note to installer):
-	Insert pointer to this file.
-
-	* dbx and cpp are not included on the distribution.
diff --git a/INSTALL b/INSTALL
index f352c00..cf73e7f 100644
--- a/INSTALL
+++ b/INSTALL
@@ -27,7 +27,7 @@ PREPARATION
  
 1) Choose a place in the file structure for the main directory
  of Emacs code to reside.  This will ultimately have
- subdirectories named info, lisp, etc, etc.  Call this name
+ subdirectories named src, lisp, etc, etc.  Call this name
  $EMACS.  Let $BUILD stand for the name the directory has now.
 
 2) Copy $BUILD/src/config.h.dist to config.h, and edit it to
@@ -134,12 +134,6 @@ The steps below are done by the shell script `build-install'.
 LOSSAGES
 Known possible problems building and running GNU Emacs
 
-* In the 4.3bsd distribution, you will get some spurious warning messages
-saying `BSD redefined' or `BSD4_3 redefined' from the C compiler while
-building Emacs.  These are due to a last minute surprise in the 4.3
-header files which we did not have time to correct for.  For now,
-please disregard the messages.
-
 * Watch out for .emacs files and EMACSLOADPATH environment vars
 
 These control the actions of Emacs.
diff --git a/README b/README
index 3722f10..3b5431c 100644
--- a/README
+++ b/README
@@ -18,6 +18,3 @@ The file INSTALL in this directory says how to bring up
 The `etc' subdirectory contains several other files,
  named in capital letters, which you should look at
  when installing GNU Emacs.
-
-For a list of the changes made at Berkeley to the FSF distribution,
- see the file ChangeLog, in this directory.
diff --git a/build-install b/build-install
index ac59cc1..69feba0 100755
--- a/build-install
+++ b/build-install
@@ -2,8 +2,8 @@
 #
 #Shell script for building and installing Emacs.
 
-set EMACS=/usr/new/lib/emacs
-set BIN=/usr/new
+set EMACS=/usr/local/emacs
+set BIN=/usr/local/bin
 
 (cd etc; make) || exit 1
 (cd src; make) || exit 1
diff --git a/etc/emacs.1 b/etc/emacs.1
index 5e0eb6f..6325273 100644
--- a/etc/emacs.1
+++ b/etc/emacs.1
@@ -72,29 +72,29 @@ make and distribute copies of the Emacs manual.  The TeX source to the
 manual is also included in the Emacs source distribution.
 .PP
 .SH FILES
-/usr/src/new/emacs/src - C source files and object files
+/usr/local/emacs/src - C source files and object files
 
-/usr/new/lib/emacs/lisp - Lisp source files and compiled files
+/usr/local/emacs/lisp - Lisp source files and compiled files
 that define most editing commands.  Some are preloaded;
 others are autoloaded from this directory when used.
   
-/usr/new/lib/emacs/man - sources for the Emacs reference manual.
+/usr/local/emacs/man - sources for the Emacs reference manual.
 
-/usr/new/lib/emacs/etc - various programs that are used with
+/usr/local/emacs/etc - various programs that are used with
 GNU Emacs, and some files of information.
 
-/usr/new/lib/emacs/etc/DOC.* - contains the documentation
+/usr/local/emacs/etc/DOC.* - contains the documentation
 strings for the Lisp primitives and preloaded Lisp functions
 of GNU Emacs.  They are stored here to reduce the size of
 Emacs proper.
 
-/usr/new/lib/emacs/etc/DIFF discusses GNU Emacs vs. Twenex Emacs;
+/usr/local/emacs/etc/DIFF discusses GNU Emacs vs. Twenex Emacs;
 .br
-/usr/new/lib/emacs/etc/CCADIFF discusses GNU Emacs vs. CCA Emacs;
+/usr/local/emacs/etc/CCADIFF discusses GNU Emacs vs. CCA Emacs;
 .br
-/usr/new/lib/emacs/etc/GOSDIFF discusses GNU Emacs vs. Gosling Emacs.
+/usr/local/emacs/etc/GOSDIFF discusses GNU Emacs vs. Gosling Emacs.
 .br
-/usr/new/lib/emacs/etc/SERVICE lists people offering various services
+/usr/local/emacs/etc/SERVICE lists people offering various services
 to assist users of GNU Emacs, including education, troubleshooting,
 porting and customization.
 .br
@@ -102,20 +102,20 @@ These files also have information useful to anyone wishing to write
 programs in the Emacs Lisp extension language, which has not yet been fully
 documented.
 
-/usr/new/lib/emacs/info - files for the Info documentation browser
+/usr/local/emacs/info - files for the Info documentation browser
 (a subsystem of Emacs) to refer to.  Currently not much of Unix
 is documented here, but the complete text of the Emacs reference
 manual is included in a convenient tree structured form.
 
-/usr/new/lib/emacs/lock - holds lock files that are made for all
+/usr/local/emacs/lock - holds lock files that are made for all
 files being modified in Emacs, to prevent simultaneous modification
 of one file by two users.
 
-/usr/src/new/emacs/cpp - the GNU cpp, needed for building Emacs on
+/usr/local/emacs/cpp - the GNU cpp, needed for building Emacs on
 certain versions of Unix where the standard cpp cannot handle long
 names for macros.
 
-/usr/src/new/emacs/shortnames - facilities for translating long names to
+/usr/local/emacs/shortnames - facilities for translating long names to
 short names in C code, needed for building Emacs on certain versions
 of Unix where the C compiler cannot handle long names for functions
 or variables.
@@ -138,7 +138,7 @@ a list of people who offer it.
 Please do not send anything but bug reports to this mailing list.
 Send other stuff to info-gnu-emacs-request@prep.ai.mit.edu (or the
 corresponding UUCP address).  For more information about Emacs mailing
-lists, see the file /usr/new/lib/emacs/etc/MAILINGLISTS.  Bugs tend
+lists, see the file /usr/local/emacs/etc/MAILINGLISTS.  Bugs tend
 actually to be fixed if they can be isolated, so it is in your
 interest to report them in such a way that they can be easily
 reproduced.
diff --git a/src/config.h b/src/config.h
deleted file mode 100644
index 1d157fe..0000000
--- a/src/config.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/* GNU Emacs site configuration file.
-   Copyright (C) 1985 Richard M. Stallman.
-
-This file is part of GNU Emacs.
-
-GNU Emacs is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY.  No author or distributor
-accepts responsibility to anyone for the consequences of using it
-or for whether it serves any particular purpose or works at all,
-unless he says so in writing.  Refer to the GNU Emacs General Public
-License for full details.
-
-Everyone is granted permission to copy, modify and redistribute
-GNU Emacs, but only under the conditions described in the
-GNU Emacs General Public License.   A copy of this license is
-supposed to have been given to you along with GNU Emacs so you
-can know your rights and responsibilities.  It should be in a
-file named COPYING.  Among other things, the copyright notice
-and this notice must be preserved on all copies.  */
-
-
-/* NOTE:  This is the config file for generic 4.3BSD.
-	  If you want to make a change to the configuration file which
-	  is included in the Emacs distribution, the file config.h.dist must
-	  also be modified.
-*/
-
-/* Include here a s- file that describes the system type you are using.
-   Alternatives now defined include
-   s-bsd4.1.h, s-bsd4.2.h and s-bsd4.3.h for Berkeley systems,
-   s-unipl5.2.h and s-unipl.5.0.h for Unisoft-modified system V,
-   and s-usg5.2.h for ordinary losing system V.
-   See s-template.h for documentation on writing s- files.  */
-#include "s-bsd4.3.h"
- 
-/* Include here a m- file that describes the machine and system you use.
-   Alternatives implemented so far are
-    m-vax.h	for vaxen.
-    m-mega68.h	for Megatest 68000's.
-    m-sun.h	for Sun 68000's.
-    m-ns16000.h	for 16000's (not sure how general this is yet)
-    m-pyramid.h for pyramids.
-    m-dual68.h  for dual 68000's (that run Unisoft port).
-    m-apollo.h  for Apollo running their own system.
-   See m-template.h for info on what m- files should define.
-   */
-#include "m-vax.h"
-
-
-/* define HAVE_X_WINDOWS if you want to use the X window system */
-
-#undef HAVE_X_WINDOWS
-
-/* subprocesses should be defined if you want to
- have code for asynchronous subprocesses
- (as used in M-x compile and M-x shell).
- These do not work for some USG systems yet;
- for the ones where they work, the s-*.h file defines this flag.  */
-
-#ifndef USG
-#define subprocesses
-#endif
-
-/* Define USER_FULL_NAME to return a string
- that is the user's full name.
- It can assume that the variable `pw'
- points to the password file entry for this user.
-
- At some sites, the pw_gecos field contains
- the user's full name.  If neither this nor any other
- field contains the right thing, use pw_name,
- giving the user's login name, since that is better than nothing.  */
-
-#define USER_FULL_NAME pw->pw_gecos
-
-/* Define AMPERSAND_FULL_NAME if you use the convention
-  that & in the full name stands for the login id.  */
-
-#define AMPERSAND_FULL_NAME
-
-/* Maximum screen width we handle. */
-
-#define MScreenWidth 300
-
-/* Maximum screen length we handle. */
-
-#define MScreenLength 300
-
-/* # bytes of pure Lisp code to leave space for.
-  130000 is enough for Emacs as distributed by me, Richard Stallman,
-  with the set of preloaded packages I set up.  */
-
-#define PURESIZE 130000
-
-/* Define HIGHPRI as a negative number
- if you want Emacs to run at a higher than normal priority.
- For this to take effect, you must install it as setuid root. */
-
-#undef HIGHPRI
diff --git a/src/paths.h b/src/paths.h
deleted file mode 100644
index 64360d8..0000000
--- a/src/paths.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* the default search path for Lisp function "load" */
-#define PATH_LOADSEARCH ":/usr/new/lib/emacs/lisp"
-
-/* the extra search path for programs to invoke.
- This is appended to whatever the PATH environment variable says. */
-#define PATH_EXEC "/usr/new/lib/emacs/etc"
-
-/* the name of the directory that contains lock files
- with which we record what files are being modified in Emacs.
- This directory should be writable by everyone.
- THE STRING MUST END WITH A SLASH!!!  */
-#define PATH_LOCK "/usr/new/lib/emacs/lock/"
-
-/* the name of the file !!!SuperLock!!! in the directory
- specified by PATH_LOCK.  Yes, this is redundant.  */
-#define PATH_SUPERLOCK "/usr/new/lib/emacs/lock/!!!SuperLock!!!"
diff --git a/lisp/ChangeLog b/lisp/ChangeLog
index 5c57f72..e517bb2 100644
--- a/lisp/ChangeLog
+++ b/lisp/ChangeLog
@@ -1,7 +1,3 @@
-Sun Apr 13 07:39:08 1986  James Larus  (larus at calder.berkeley.edu)
-
-	* Installed mh-e (v 3.3c).
-
 Sat Apr 12 19:29:26 1986  Richard M. Stallman  (rms at prep)
 
 	* replace.el (perform-replace):
@@ -54,11 +50,6 @@ Mon Mar 31 12:39:55 1986  Richard M. Stallman  (rms at prep)
 
 	* man.el: fix stupid error in arg to file-name-all-completions.
 
-Sun Mar 30 14:42:26 1986  Paul Rubin  (phr at calder.berkeley.edu)
-
-	* mh-e.el:
-	Replace with improved version, by larus@kim.berkeley.edu.
-
 Fri Mar 28 23:28:16 1986  Richard M. Stallman  (rms at prep)
 
 	* info.el (Info-tagify):
diff --git a/lisp/mh-e.el b/lisp/mh-e.el
index f0da19e..37834cc 100644
--- a/lisp/mh-e.el
+++ b/lisp/mh-e.el
@@ -1,11 +1,11 @@
-;;;  mh-e.el	(Version: 3.3c for GNU Emacs Version 17 and MH.5 and MH.6)
+;;;  mh-e.el	(Version: 3.2 for GNU Emacs Version 17)
 
-;;;  Copyright (C) James Larus (larus@kim.berkeley.edu, ucbvax!larus), 1985
+;;;  Copyright (C) 1985 Free Software Foundation
+;;;     Author James Larus, larus@berkeley.arpa, ucbvax!larus
 ;;;	Please send suggestions and corrections to the above address.
 ;;;
 ;;;  This file contains mh-e, a GNU Emacs front end to the MH mail system.
 
-
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but without any warranty.  No author or distributor
 ;; accepts responsibility to anyone for the consequences of using it
@@ -35,8 +35,8 @@
 
 ;;; Set for local environment:
 ;;;* These are now in paths.el.
-;;;(defvar mh-progs "/usr/new/mh/"     "Directory containing MH commands")
-;;;(defvar mh-lib   "/usr/new/lib/mh/" "Directory of MH library")
+;(defvar mh-progs "/usr/new/mh/"     "Directory containing MH commands")
+;(defvar mh-lib   "/usr/new/lib/mh/" "Directory of MH library")
 
 
 ;;; Mode hooks:
@@ -78,8 +78,7 @@ as it is inserted in an outgoing letter.")
 (defvar mh-rejected-letter-start "^   ----- Unsent message follows -----$"
   "Regexp specifying the beginning of the wrapper around a letter returned
 by the mail system.")
-(defvar mh-good-msg-regexp  "^....[^D^]"
-  "Regexp specifiying the scan lines that are 'good' messages")
+
 
 ;;; Global variables:
 
@@ -90,7 +89,7 @@ by the mail system.")
 (defvar mh-pick-mode-map (make-sparse-keymap) "Keymap for searching folder.")
 (defvar mh-folder-list nil	     "List of folder names for completion.")
 
-;;; Macros and generic functions:
+;;; Macros:
 
 (defmacro push (v l)
   (list 'setq l (list 'cons v l)))
@@ -110,11 +109,6 @@ by the mail system.")
 (defmacro when (pred &rest body)
   (list 'cond (cons pred body)))
 
-(defun mapc (func list)
-  (while list
-    (funcall func (car list))
-    (setq list (cdr list))))
-
 
 
 ;;; Entry points:
@@ -146,17 +140,15 @@ different conventions from the usual mail system."
 
 ;;; User executable mh-e commands:
 
-
 (defun mh-answer (&optional arg)
-  "Answer a letter.  If given a non-nil ARGUMENT, then include the current
-message in the reply."
+  "Answer a letter.  If given an argument, then include the current message
+in the reply."
   (interactive "P")
   (let ((msg-filename (mh-msg-filename))
 	(msg (mh-get-msg-num t))
 	(minibuffer-help-form
 "from => Sender\n  to => Sender and primary recipients\n  cc => Sender and all recipients")
-	(folder mh-current-folder)
-	(show-buffer mh-show-buffer))
+	(folder mh-current-folder))
     (let ((reply-to (completing-read
 		     "Reply to whom: " '(("from") ("to") ("cc")) nil t)))
     (message "Composing a reply...")
@@ -168,7 +160,8 @@ message in the reply."
 	  ((equal reply-to "to")
 	   (apply 'mh-exec-cmd
 		  (nconc
-		   (list "repl" "-build" mh-current-folder msg "-cc" "to")
+		   (list "repl" "-build" mh-current-folder msg "-cc" "to"
+			 "-nocc" "me")
 		   (if arg (list "-filter" "mhl.reply")))))
 	  ((equal reply-to "cc")
 	   (apply 'mh-exec-cmd
@@ -190,55 +183,46 @@ message in the reply."
 	  (cc (mh-get-field "Cc:")))
       (goto-char (point-min))
       (re-search-forward "^$" (point-max) nil)
-      (if (not arg)
-	(mh-display-msg msg msg-filename show-buffer))
-      (mh-add-msg-to-seq msg "answered" t)
+      (when (not arg)
+	(switch-to-buffer-other-window "*message*")
+	(erase-buffer)
+	(if (file-exists-p msg-filename)
+	    (insert-file-contents msg-filename)
+	    (error "File %s does not exist" msg-filename))
+	(set-buffer-modified-p nil)
+	(goto-char (point-min))
+	(re-search-forward "^$\\|^-*$")
+	(recenter 0))
       (message "Composing a reply...done")
       (mh-compose-and-send-mail "" folder to subject cc "-" "Replied:")))))
 
 
-(defun my-apply-command-to-seq (command)
-  "Applies the next command to all messages in a sequence to be prompted for."
-  (interactive "k")
-  (funcall (key-binding command) (mh-read-seq "Apply to" mh-narrowed-to-seq)))
-
-
-(defun mh-copy-msg (&optional seq)
-  "Copy specified message(s) to another folder without deleting them.
-Optional argument is a SEQUENCE name to copy."
+(defun mh-copy-msg (&optional arg)
+  "Copy specified message(s) to another folder without deleting them."
   (interactive "P")
-  (let ((msgs (if seq seq (mh-get-msg-num t))))
-    (mh-exec-cmd "refile" msgs "-link" "-src" mh-current-folder
-		 (mh-prompt-for-folder "Copy to" "" t))
-    (if seq
+  (let ((msgs (if arg
+		  (mh-seq-to-msgs (mh-read-seq "Copy"))
+		  (mh-get-msg-num t))))
+    (mh-exec-cmd-no-wait "refile" msgs "-link" "-src"
+			 mh-current-folder
+			 (mh-prompt-for-folder "Copy to" "" t))
+    (if arg
 	(mh-notate-seq msgs ?C mh-cmd-note)
 	(mh-notate ?C mh-cmd-note))))
 
 
-(defun mh-delete-msg (&optional seq)
-  "Marks the specified message(s) for later deletion.  Optional argument is a
-SEQUENCE name to  delete."
-  (interactive "P")
-  (if seq
-      (mh-map-to-seq-msgs 'mh-delete-a-msg seq)
-      (mh-delete-a-msg))
-  (mh-next-msg))
-
-
-(defun mh-delete-msg-from-seq (&optional arg)
-  "Deletes a message from a sequence or, if optional ARG is non-nil, deletes
-the sequence."
+(defun mh-delete-msg (&optional arg)
+  "Marks the specified message(s) for later deletion."
   (interactive "P")
   (if arg
-      (mh-remove-seq (mh-read-seq "Delete"))
-      (mh-remove-msg-from-seq (mh-get-msg-num t) (mh-read-seq "Delete from")))
+      (mh-map-over-seq 'mh-delete-a-msg (mh-read-seq "Delete"))
+      (mh-delete-a-msg))
   (mh-next-msg))
 
 
 (defun mh-execute-commands ()
   "Process outstanding delete and move commands."
   (interactive)
-  (if mh-narrowed-to-seq (mh-widen))
   (save-excursion
     (mh-process-commands mh-current-folder))
   (delete-other-windows)
@@ -263,44 +247,28 @@ the sequence."
     (let ((mh-invisible-headers "^Date:\\|^Received:\\|^Message-Id:\\|^From:"))
       (mh-clean-msg-header (point-min)))
     (goto-char (point-min))
-    (switch-to-buffer mh-current-folder)
     (mh-compose-and-send-mail "" mh-current-folder (mh-get-field "To")
 			      (mh-get-field "From") (mh-get-field "cc"))))
 
 
-(defun mh-forward (&optional seq)
-  "Forward a letter.  Optional argument is a SEQUENCE of messages to forward."
-  (interactive "P")
-  (let ((to (read-string "To: "))
-	(cc (read-string "Cc: "))
-	(msg-filename (mh-msg-filename))
-	(msg (if seq seq (mh-get-msg-num t)))
+(defun mh-forward (to cc subject)
+  "Forward a letter."
+  (interactive "sTo: \nsCc: \nsSubject: ")
+  (let ((msg-filename (mh-msg-filename))
+	(msg (mh-get-msg-num t))
 	(folder mh-current-folder))
     (cond ((or (not (file-exists-p (format "%sdraft" mh-user-path)))
 	       (y-or-n-p "The file 'draft' exists.  Discard it? "))
 	   (mh-exec-cmd "forw" "-build" mh-current-folder msg)
 	   (mh-read-draft)
-	   (mh-insert-fields "To:" to "Cc:" cc)
-	   (set-buffer-modified-p nil))
+	   (mh-insert-fields "To:" to "Subject:" subject "Cc:" cc))
 	  (t
 	   (mh-read-draft)))
     (goto-char (point-min))
     (re-search-forward "^------- Forwarded Message")
     (previous-line 1)
-    (narrow-to-region (point) (point-max))
-    (let* ((subject (save-excursion (mh-get-field "From:")))
-	   (trim (string-match "<" subject))
-	   (forw-subject (save-excursion (mh-get-field "Subject:"))))
-      (if trim
-	  (setq subject (substring subject 0 (1- trim))))
-      (widen)
-      (save-excursion
-	(mh-insert-fields "Subject:" (format "[%s: %s]" subject forw-subject)))
-      (delete-other-windows)
-      (if seq
-	  (mh-add-msg-list-to-seq (mh-seq-to-msgs seq) "forwarded" t)
-	  (mh-add-msg-to-seq msg "forwarded" t))
-      (mh-compose-and-send-mail "" folder to subject cc "F" "Forwarded:"))))
+    (delete-other-windows)
+    (mh-compose-and-send-mail "" folder to subject cc "F" "Forwarded-To:")))
 
 
 (defun mh-goto-msg (number &optional no-error-if-no-message)
@@ -322,23 +290,39 @@ ARG is t.  Return non-nil if cursor is at message."
 (defun mh-inc-folder ()
   "inc(orporate) new mail into inbox."
   (interactive)
-  (pop-to-buffer "+inbox")
+  (switch-to-buffer "+inbox")
   (if (or (not (boundp 'mh-current-folder)) (null mh-current-folder))
       (mh-make-folder "+inbox"))
   (if (mh-get-new-mail)
       (mh-show)))
 
 
+(defun mh-indicate-seq (&optional arg)
+  "Add the specified message(s) to a sequence."
+  (interactive "P")
+  (let ((new-seq (mh-char-to-seq last-input-char))
+	(old-seq (if (looking-at "^[0-9a-z]")
+		     (mh-char-to-seq (char-after (point))))))
+    (if old-seq
+	(if arg
+	    (mh-remove-seq old-seq)
+	    (mh-remove-msg-from-seq (mh-get-msg-num t) old-seq)))
+    (if (and (not arg)
+	     (or (not old-seq) (not (equal new-seq old-seq))))
+	(mh-add-msg-to-seq (mh-get-msg-num t) new-seq)))
+    (mh-next-msg))
+
+
 (defun mh-kill-folder ()
   "Removes the current folder."
   (interactive)
   (if (yes-or-no-p (format "Remove folder %s? " mh-current-folder))
-      (let ((folder mh-current-folder))
+      (let ((buffer mh-current-folder))
 	(switch-to-buffer-other-window " *mh-temp*")
-	(mh-exec-cmd "rmf" "-nointeractive" folder)
-	(mh-remove-folder-from-folder-list folder)
+	(mh-exec-cmd "rmf" buffer)
+	(mh-remove-folder-from-folder-list buffer)
 	(message "Folder removed")
-	(kill-buffer folder))
+	(kill-buffer buffer))
       (message "Folder not removed")))
 
 
@@ -353,76 +337,27 @@ ARG is t.  Return non-nil if cursor is at message."
   (message "listing folders...done"))
 
 
-(defun mh-msg-is-in-seq ()
-  "Displays the sequences that the current messages is in."
-  (interactive)
-  (let ((msg (mh-get-msg-num t))
-	(l mh-seq-list)
-	(seqs ""))
-      (while l
-	(if (memq msg (cdar l))
-	    (setq seqs (format "%s %s" (symbol-name (caar l)) seqs)))
-	(setq l (cdr l)))
-      (message "Message %d is in sequences: %s" msg seqs)))
-
-
-(defun mh-move-msg (&optional seq)
-  "Move specified message(s) to another folder.  Optional argument is a
-SEQUENCE of messages to refile."
+(defun mh-move-msg (&optional arg)
+  "Move specified message(s) to another folder."
   (interactive "P")
-  (setq mh-last-destination
-	(cons 'move (intern (mh-prompt-for-folder "Destination" "" t))))
-  (if seq
-      (mh-map-to-seq-msgs 'mh-move-a-msg seq (cdr mh-last-destination))
-      (mh-move-a-msg (cdr mh-last-destination)))
-  (mh-next-msg))
-
-
-(defun mh-move-or-write-again ()
-  "Move or write the current message to same folder or file as the last move
-or write."
-  (interactive)
-  (if (null mh-last-destination)
-      (error "No previous move"))
-  (cond ((eq (car mh-last-destination) 'move)
-	 (mh-move-a-msg (cdr mh-last-destination))
-	 (message "Destination folder: %s" (cdr mh-last-destination)))
-	(t
-	 (mh-write-msg-to-file (cdr mh-last-destination))
-	 (message "Destination: %s" (cdr mh-last-destination))))
-  (sit-for 3)
+  (setq mh-last-destination (mh-prompt-for-folder "Destination" "" t))
+  (if arg
+      (mh-map-over-seq 'mh-move-a-msg (mh-read-seq "Move"))
+      (mh-move-a-msg))
   (mh-next-msg))
 
 
-(defun mh-narrow-to-seq ()
-  "Restrict the display of the current folder to the messages in the sequence
-to be prompted for.  Use \\[mh-widen] to undo this command."
-  (interactive "")
-  (let ((seq (mh-read-seq "Narrow to"))
-	(eob (point-max))
-	(buffer-read-only nil))
-    (cond ((mh-seq-to-msgs seq)
-	   (mh-copy-seq-to-point seq eob)
-	   (narrow-to-region eob (point-max))
-	   (setq mode-line-format (mh-make-mode-line (symbol-name seq)))
-	   (recenter)
-	   (setq mh-narrowed-to-seq seq))
-	  (t
-	   (error "No messages in sequence `%s'" (symbol-name seq))))))
-
-
 (defun mh-next-line (&optional arg)
   "Move to next undeleted message in window and display body if summary
 flag set."
   (interactive "p")
   (forward-line (if arg arg 1))
   (setq mh-next-direction 'forward)
-  (cond ((re-search-forward mh-good-msg-regexp nil 0 arg)
+  (cond ((re-search-forward "^....[^D^]" nil 0 arg)
 	 (beginning-of-line)
 	 (mh-maybe-show))
 	(t
 	 (forward-line -1)
-	 (sit-for 2)
 	 (message "No more messages"))))
 
 
@@ -459,7 +394,7 @@ flag set."
   "Move to previous message in window and display body if summary flag set."
   (interactive "p")
   (setq mh-next-direction 'backward)
-  (if (not (re-search-backward mh-good-msg-regexp nil 0 arg))
+  (if (not (re-search-backward "^....[^D^]" nil 0 arg))
       (message "Beginning of messages")
       (mh-maybe-show)))
 
@@ -474,56 +409,26 @@ flag set."
       (other-window -1))))
 
 
-(defun mh-print-msg (&optional seq)
-  "Print specified message(s) on a line printer.  Optional argument is a
-SEQUENCE of messages to print."
+(defun mh-print-msg (&optional arg)
+  "Print specified message(s) on a line printer."
   (interactive "P")
-  (let ((msgs (if seq
-		  (reverse (mh-seq-to-msgs seq))
+  (let ((msgs (if arg
+		  (reverse (mh-seq-to-msgs (mh-read-seq "Print")))
 		  (list (mh-get-msg-num t)))))
     (message "printing message...")
-    (call-process shell-file-name nil 0 nil "-c"
-		  (if seq
-		      (format "(scan -clear %s ; %smhl -nobell -clear %s) | %s"
-			      (mapconcat (function (lambda (msg) msg)) msgs " ")
-			      mh-lib
-			      (mh-msg-filenames msgs mh-folder-filename)
-			      (format mh-lpr-command-format
-				      (if seq
-					  "Mail"
-					  (format "%s/%d" mh-current-folder
-						  (mh-get-msg-num t)))))
-		      (format "%smhl -nobell -clear %s | %s"
-			      mh-lib
-			      (mh-msg-filenames msgs mh-folder-filename)
-			      (format mh-lpr-command-format
-				      (if seq
-					  "Mail"
-					  (format "%s/%d" mh-current-folder
-						  (mh-get-msg-num t)))))))
-    (if seq
-	(mh-notate-seq msgs ?P mh-cmd-note)
-	(mh-notate ?P mh-cmd-note))
-    (mh-add-msg-list-to-seq msgs 'printed t)
+    (call-process "/bin/sh" nil 0 nil "-c"
+		  (format "%smhl -nobell -clear %s | %s" mh-lib
+			  (mh-msg-filenames msgs mh-folder-filename)
+			  (format mh-lpr-command-format
+				  (if arg
+				      "Mail"
+				      (format "%s/%d" mh-current-folder
+					      (mh-get-msg-num t))))))
     (message "printing message...done")))
 
 
-(defun mh-put-msg-in-seq (&optional arg)
-  "Add a message to a sequence or, if optional ARG is non-nil, add the
-messages from a sequence to another sequence."
-  (interactive "P")
-  (if arg
-      (mh-add-msg-list-to-seq (mh-seq-to-msgs
-			       (mh-read-seq "Add messages from"))
-			      (mh-read-seq "to"))
-      (mh-add-msg-to-seq (mh-get-msg-num t) (mh-read-seq "Add to")))
-  (mh-next-msg))
-
-
 (defun mh-rescan-folder (&optional arg)
-  "Rescan a folder after optionally processing the outstanding commands.  If
-the optional argument is non-nil, then prompt for the range of messages to
-display, otherwise assume the whole buffer."
+  "Optionally process commands in current folder and (re)scan it."
   (interactive "P")
   (if (and (or mh-delete-list mh-move-list)
 	   (y-or-n-p "Process commands? "))
@@ -535,42 +440,43 @@ display, otherwise assume the whole buffer."
 
 (defun mh-redistribute (to cc)
   "Redistribute a letter."
-  (interactive "sRedist-To: \nsRedist-Cc: ")
+  (interactive "sTo: \nsCc: ")
   (let ((msg-filename (mh-msg-filename))
 	(msg (mh-get-msg-num t))
 	(folder mh-current-folder))
-    (save-window-excursion
-      (mh-read-draft)
-      (when (or (zerop (buffer-size))
-		(not (y-or-n-p
-		      "The file 'draft' exists.  Redistribute old version? ")))
-	(erase-buffer)
-	(insert-file-contents msg-filename))
-      (re-search-forward "^$\\|^---")
+    (mh-read-draft)
+    (delete-other-windows)
+    (when (or (zerop (buffer-size))
+	      (not (y-or-n-p
+		    "The file 'draft' exists.  Redistribute old version? ")))
+      (erase-buffer)
+      (insert-file-contents msg-filename)
+      (goto-char (point-min))
       (insert "Resent-To: " to "\n")
       (if (not (equal cc ""))
-	  (insert "Resent-cc: " cc "\n"))
-      (let ((mh-invisible-headers "^Message-Id:\\|^Received:\\|Return-Path:"))
-	(mh-clean-msg-header (point-min)))
-      (save-buffer)
-      (message "Redistributing...")
-      (call-process "/bin/sh" nil 0 nil "-c"
-       (format "mhdist=1 mhaltmsg=%s %s/send -push %s/draft"
-	       msg-filename mh-progs mh-user-path))
-      (mh-annotate-msg msg folder "R"
-		       "-component" "Resent:"
-		       "-text" (format "\"%s %s\"" to cc))
-      (message "Redistributing...done"))))
+	  (insert "Resent-cc: " cc "\n")))
+    (mh-compose-and-send-mail "-dist" folder to (mh-get-field "Subject:") cc
+			      "F" "Distributed-to:")))
+
+
+(defun mh-move-again ()
+  "Move specified message to same folder as last move."
+  (interactive)
+  (if (null mh-last-destination)
+      (error "No previous move"))
+  (mh-move-a-msg)
+  (message "Destination folder: %s" mh-last-destination)
+  (mh-next-msg))
 
 
 (defun mh-write-msg-to-file (file)
   "Append the current message to the end of a file."
   (interactive "FSave message in file: ")
-  (setq mh-last-destination (cons 'write file))
-  (call-process shell-file-name nil 0 nil "-c"
-		(format "cat %s >> %s " (mh-msg-filename) file)))
-
+  (let ((msg-filename (mh-msg-filename)))
+    (call-process "/bin/csh" nil 0 nil "-c"
+		  (format "cat %s >> %s " msg-filename file))))
 
+    
 (defun mh-search-folder ()
   "Search the current folder for messages matching a pattern."
   (interactive)
@@ -599,7 +505,6 @@ display, otherwise assume the whole buffer."
 	      (insert-file-contents (format "%scomponents" mh-lib))
 	      (error "Can't find components")))
       (mh-insert-fields "To:" to "Subject:" subject "Cc:" cc)
-      (set-buffer-modified-p nil)
       (goto-char (point-max))
       (message "Composing a message...done"))
     (mh-compose-and-send-mail "" folder to subject cc)))
@@ -610,10 +515,30 @@ display, otherwise assume the whole buffer."
   (interactive)
   (setq mh-summarize nil)
   (setq mode-name "Mh-Show")
-  (let ((msg-num (mh-get-msg-num t))
+  (let ((msgn (mh-get-msg-num t))
+	(msg-filename (mh-msg-filename))
 	(folder mh-current-folder))
-    (mh-display-msg msg-num (mh-msg-filename) mh-show-buffer)
-
+    (if (not (file-exists-p msg-filename))
+	(error "Message %d does not exist." msgn))
+    (switch-to-buffer mh-show-buffer)
+    (erase-buffer)
+    (unlock-buffer)
+    (if mh-use-mhl
+	(mh-exec-lib-cmd-output "mhl" "-nobell" msg-filename)
+	(insert-file-contents msg-filename))
+    (setq buffer-file-name msg-filename)
+    (goto-char (point-min))
+    (cond (mh-clean-message-header
+	   (mh-clean-msg-header (point-min))
+	   (goto-char (point-min)))
+	  (t
+	   (let ((case-fold-search t))
+	     (re-search-forward "^To:\\|^From:\\|^Subject:\\|^Date:" nil t)
+	     (beginning-of-line)
+	     (recenter 0))))
+    (set-buffer-modified-p nil)
+    (setq mode-line-format
+	  (concat "{%b}	%[%p of " folder "/" msgn "%]	%M"))
     ;; These contortions are to force the summary line to be the top window.
     (switch-to-buffer-other-window folder)
     (delete-other-windows)
@@ -621,12 +546,14 @@ display, otherwise assume the whole buffer."
     (switch-to-buffer-other-window folder)
     (shrink-window (- (window-height) mh-summary-height))
     (recenter 1)
-    (push msg-num mh-seen-list)))
+    ;; Remove from unseen seq.
+    (mh-exec-cmd-no-wait "mark" mh-current-folder msgn "-seq" "unseen"
+			 "-delete" "-nolist")))
 
 
-(defun mh-sort-folder ()
+(defun mh-sort-folder (&optional arg)
   "Sort the messages in the current folder by date."
-  (interactive "")
+  (interactive "P")
   (mh-process-commands mh-current-folder)
   (setq mh-next-direction 'forward)
   (message "sorting folder...")
@@ -635,6 +562,14 @@ display, otherwise assume the whole buffer."
   (mh-scan-folder mh-current-folder "all"))
 
 
+(defun mh-summary ()
+  "Show a summary of mh-e commands."
+  (interactive)
+  (message
+"Next Prev Go Del ^ ! Copy Undo . Toggle Ans Forw Redist Send List Execute")
+  (sit-for 5))
+
+
 (defun mh-toggle-summarize ()
   "Turn the summary mode of displaying messages on or off."
   (interactive)
@@ -642,45 +577,30 @@ display, otherwise assume the whole buffer."
   (cond (mh-summarize
 	 (delete-other-windows)
 	 (setq mode-name "Mh-Summarize")
-	 (recenter (/ (window-height) 2)))
+	 (recenter))
 	(t
 	 (setq mode-name "Mh-Show")
 	 (mh-show))))
 
 
-(defun mh-undo (&optional seq)
-  "Undo the deletion or move of the specified message(s).  Optional argument
-is a name of a sequence of messages to apply undo to."
+(defun mh-undo (&optional arg)
+  "Undo the deletion or move of the specified message(s)."
   (interactive "P")
   (cond ((looking-at "^....D")
-	 (cond (seq
-		(mapc (function (lambda (msg)
-				  (setq mh-delete-list
-					(delq msg mh-delete-list))
-				  (mh-remove-msg-from-seq msg 'deleted)))
-		      (mh-seq-to-msgs seq))
-		(mh-notate-seq seq ?  mh-cmd-note))
-	       (t
-		(let ((msg (mh-get-msg-num t)))
-		  (setq mh-delete-list (delq msg mh-delete-list))
-		  (mh-remove-msg-from-seq msg 'deleted)
-		  (mh-notate ?  mh-cmd-note)))))
-
-	((looking-at "^....\\^")
-	 (cond (seq
-		(mapc (function (lambda (msg)
-				  (mapc (function
-					 (lambda (dest)
-					   (mh-remove-msg-from-seq msg dest)))
-					mh-move-list)))
-		      (mh-seq-to-msgs seq))
-		(mh-notate-seq seq ?  mh-cmd-note))
-	       (t
-		(let ((msg (mh-get-msg-num t)))
-		  (mapc (function (lambda (dest)
-				    (mh-remove-msg-from-seq msg dest)))
-			mh-move-list)
-		  (mh-notate ?  mh-cmd-note)))))
+	 (let ((msgs (if arg (mh-read-seq "Undelete") (mh-get-msg-num t))))
+	   (setq mh-delete-list (delq msgs mh-delete-list))
+	   (if arg
+	       (mh-notate-seq msgs ?  mh-cmd-note)
+	       (mh-notate ?  mh-cmd-note))))
+
+	((looking-at "^....^")
+	 (let ((msgs (if arg (mh-read-seq "Unmove") (mh-get-msg-num t))))
+	   (mapcar
+	    (function (lambda (move) (setcdr move (delq msgs (cdr move)))))
+	    mh-move-list)
+	   (if arg
+	       (mh-notate-seq msgs ?  mh-cmd-note)
+	       (mh-notate ?  mh-cmd-note))))
 
 	(t nil)))
 
@@ -699,78 +619,39 @@ is a name of a sequence of messages to apply undo to."
 
 
 (defun mh-visit-folder (&optional arg)
-  "Visit a new folder.  If optional argument is non-nil, then prompt for the
-range of messages, otherwise scan the whole buffer."
+  "Visit a new folder."
   (interactive "p")
   (let ((folder (mh-prompt-for-folder "Visit" "" t))
 	(range (if arg (read-string "Range [all]? ") "all")))
     (mh-scan-folder folder (if (equal range "") "all" range))
     (delete-other-windows)))
 
-
-(defun mh-widen ()
-  "Remove restrictions from the current folder, thereby showing all messages."
-  (interactive "")
-  (let ((buffer-read-only nil))
-    (delete-region (point-min) (point-max))
-    (widen)
-    (setq mode-line-format (mh-make-mode-line)))
-  (setq mh-narrowed-to-seq nil))
-
 
 
 ;;; Support routines.
 
 (defun mh-delete-a-msg ()
   "Delete the message pointed to by the cursor."
-  (let ((msg (mh-get-msg-num t)))
-    (if (looking-at "....\\^")
-	(error "Message %d already moved.  Undo move before deleting." msg))
-    (push msg mh-delete-list)
-    (mh-add-msg-to-seq msg 'deleted t)
-    (mh-notate ?D mh-cmd-note)))
+  (if (looking-at "....^")
+      (error "Message %d already moved.  Undo move before deleting."
+	     (mh-get-msg-num t)))
+  (push (mh-get-msg-num t) mh-delete-list)
+  (mh-notate ?D mh-cmd-note))
 
 
-(defun mh-move-a-msg (destination)
+(defun mh-move-a-msg ()
   "Move the message pointed to by the cursor."
   (if (looking-at "....D")
       (error "Message %d is already deleted.  Undo delete before moving."
 	     (mh-get-msg-num nil))
-      (let ((msg (mh-get-msg-num t)))
-	(if (not (memq destination mh-move-list))
-	    (push destination mh-move-list))
-	(mh-add-msg-to-seq msg destination t)
+      (let ((others (assoc mh-last-destination mh-move-list))
+	    (msg (mh-get-msg-num t)))
+	(if others
+	    (setcdr others (cons msg (cdr others)))
+	    (push (cons mh-last-destination (list msg)) mh-move-list))
 	(mh-notate ?^ mh-cmd-note))))
 
 
-(defun mh-display-msg (msg-num msg-filename show-buffer)
-  "Displays the message NUMBER and PATHNAME in BUFFER."
-  (if (not (file-exists-p msg-filename))
-      (error "Message %d does not exist." msg-num))
-  (switch-to-buffer show-buffer)
-  (buffer-flush-undo (current-buffer))
-  (when (not (equal msg-filename buffer-file-name))
-    ;; Buffer does not yet contain message.
-    (setq buffer-file-name msg-filename)
-    (erase-buffer)
-    (unlock-buffer)
-    (if mh-use-mhl
-	(mh-exec-lib-cmd-output "mhl" "-nobell" "-noclear" msg-filename)
-	(insert-file-contents msg-filename))
-    (goto-char (point-min))
-    (cond (mh-clean-message-header
-	   (mh-clean-msg-header (point-min))
-	   (goto-char (point-min)))
-	  (t
-	   (let ((case-fold-search t))
-	     (re-search-forward "^To:\\|^From:\\|^Subject:\\|^Date:" nil t)
-	     (beginning-of-line)
-	     (recenter 0))))
-    (set-buffer-modified-p nil)
-    (setq mode-line-format
-	  (concat "{%b}	%[%p of " folder "/" msg-num "%]	%M"))))
-
-
 (defun mh-clean-msg-header (start)
   "Flush extraneous lines in a message header.  The variable
 mh-invisible-headers contains a regular expression specifying these lines."
@@ -789,14 +670,10 @@ mh-invisible-headers contains a regular expression specifying these lines."
 
 
 (defun mh-read-draft ()
-  "Read draft file into draft buffer.  Avoids errors even if disk file has been
-modified underneath the buffer.  Causes an error if the folder is modified and
-the user does not want to change it."
+  "Read draft file into buffer draft.  No errors if disk file has been
+modified."
   (switch-to-buffer "draft")
-  (if (buffer-modified-p)
-      (if (y-or-n-p "Draft is modified; kill anyways? ")
-	  (set-buffer-modified-p nil)
-	  (error "Draft is not killed.")))
+  (set-buffer-modified-p nil)
   (kill-buffer "draft")
   (switch-to-buffer-other-window
    (find-file-noselect (format "%sdraft" mh-user-path))))
@@ -819,40 +696,35 @@ by the cursor."
 ;;; The folder data abstraction.
 
 (defun mh-make-folder (name)
-  "Create and initialize a new mail folder called NAME and make it the
-current folder."
+  "Create and initialize a new mail folder called NAME and make
+it the current folder."
   (switch-to-buffer name)
-  (buffer-flush-undo (current-buffer))
   (kill-all-local-variables)
   (setq buffer-read-only nil)
   (erase-buffer)
-  (make-local-vars
-   'mh-current-folder name		;Name of folder
-   'mh-show-buffer (format "show-%s" name) ; Buffer that displays messages
-   'mh-folder-filename			; e.g. /usr/foobar/Mail/inbox/
-     (format "%s%s/" mh-user-path (substring name 1))
-   'mh-summarize t			; Show scan list only?
-   'mh-next-seq-num 0			; Index of free sequence id
-   'mh-delete-list nil			; List of msgs nums to delete
-   'mh-move-list nil			; List of folder names in mh-seq-list
-   'mh-seq-list nil			; Alist of seq . msgs nums
-   'mh-seen-list nil			; List of displayed messages
-   'mh-next-direction 'forward		; Direction to move to next message
-   'mh-narrowed-to-seq nil)		; Sequence display is narrowed to
+  (make-local-variable 'mh-current-folder) ; Name of folder
+  (setq mh-current-folder name)
+  (make-local-variable 'mh-show-buffer) ; Buffer that displays messages
+  (setq mh-show-buffer (format "show-%s" mh-current-folder))
+  (make-local-variable 'mh-folder-filename) ; e.g. /usr/foobar/Mail/inbox/
+  (setq mh-folder-filename (format "%s%s/" mh-user-path (substring name 1)))
+  (make-local-variable 'mh-summarize)	 ; Show scan list only?
+  (setq mh-summarize t)
+  (make-local-variable 'mh-next-seq-num)  ; Index of free sequence id
+  (setq mh-next-seq-num 0)
+  (make-local-variable 'mh-delete-list)	 ; List of msgs nums to delete
+  (setq mh-delete-list nil)
+  (make-local-variable 'mh-move-list)	 ; Alist of dest . msgs nums
+  (setq mh-move-list nil)
+  (make-local-variable 'mh-seq-list)	 ; Alist of seq . msgs nums
+  (setq mh-seq-list nil)
+  (make-local-variable 'mh-next-direction) ; Direction to move to next message
+  (setq mh-next-direction 'forward)
   (mh-folder-mode)
   (setq buffer-read-only t)
   (setq mode-name "Mh-Summarize"))
 
 
-(defun make-local-vars (&rest pairs)
-  "Takes VARIABLE-VALUE pairs and makes local variables initialized to the
-value."
-  (while pairs
-    (make-local-variable (car pairs))
-    (set (car pairs) (cadr pairs))
-    (setq pairs (cddr pairs))))
-
-
 (defun mh-folder-mode ()
   "Major mode for \"editing\" an MH folder scan listing.
 Messages can be marked for refiling and deletion.  However, both actions
@@ -870,7 +742,7 @@ Variables controlling mh-e operation are (defaults in parentheses):
     specified in mh-invisible-headers from messages.
 
  mh-use-mhl (nil)
-    Non-nil means use mhl to format displayed messages.
+    Non-nill means use mhl to format displayed messages.
 
  mh-lpr-command-format (\"lpr -p -J '%s'\")
     Format for command used to print a message on a system printer.
@@ -891,20 +763,17 @@ Variables controlling mh-e operation are (defaults in parentheses):
 
 (defun mh-scan-folder (folder range)
   "Scan the folder FOLDER over the range RANGE.  Return in the folder."
-  (cond ((null (get-buffer folder))
-	 (mh-make-folder folder))
-	(t
-	 (if (or mh-delete-list mh-move-list mh-seq-list)
-	     (if (y-or-n-p "Process commands?")
-		 (mh-process-commands folder)
-		 (mh-undo-folder)))
-	 (switch-to-buffer-other-window folder)))
+  (if (null (get-buffer folder))
+      (mh-make-folder folder)
+      (switch-to-buffer-other-window folder))
   (mh-regenerate-headers range)
-  (when (= (count-lines (point-min) (point-max)) 0)
-    (if (equal range "all")
-	(message  "Folder %s is empty" folder)
-	(message  "No messages in %s, range %s" folder range))
-    (sit-for 5))
+  (when (looking-at "scan: no messages ")
+      (let ((buffer-read-only nil))
+	(erase-buffer))
+      (if (equal range "all")
+	  (message  "Folder %s is empty" folder)
+	  (message  "No messages in %s, range %s" folder range))
+      (sit-for 5))
   (setq mode-line-format (mh-make-mode-line))
   (mh-unmark-all-headers nil)
   (mh-goto-cur-msg))
@@ -916,54 +785,40 @@ Variables controlling mh-e operation are (defaults in parentheses):
     (message (format "scanning %s..." (buffer-name)))
     (delete-other-windows)
     (erase-buffer)
-    (mh-exec-cmd-output "scan" "-noclear" "-noheader" (buffer-name) range)
+    (mh-exec-cmd-output "scan" (buffer-name) range)
     (goto-char (point-min))
-    (cond ((looking-at "scan: no messages in")
-	   (keep-lines "^[ ]*[0-9]"))	; Flush random scan lines
-	  ((looking-at "scan: "))	; Keep error messages
-	  (t
-	   (keep-lines "^[ ]*[0-9]")))	; Flush random scan lines
     (message (format "scanning %s...done" (buffer-name)))))
 
 
 (defun mh-get-new-mail ()
   "Read new mail into the current buffer.  Return t if there was new mail,
-nil otherwise.  Leave cursor in current buffer."
-  (let ((buffer-read-only nil)
-	(point-before-inc (point)))
+nil otherwise.  Return in the current buffer."
+  (let ((buffer-read-only nil))
     (message (format "inc %s..." (buffer-name)))
     (mh-unmark-all-headers nil)
     (setq mh-next-direction 'forward)
-    (flush-lines "^inc:\\|^scan:")	; Kill old error messages
     (goto-char (point-max))
     (let ((start-of-inc (point)))
       (mh-exec-cmd-output "inc")
-      (goto-char start-of-inc)
       (message (format "inc %s...done" (buffer-name)))
+      (goto-char start-of-inc)
       (cond ((looking-at "inc: no mail")
-	     (keep-lines "^[ ]*[0-9]")	; Flush random scan lines
+	     (kill-line 1)
 	     (setq mode-line-format (mh-make-mode-line))
-	     (goto-char point-before-inc)
+	     (previous-line 1)
 	     (message "No new mail.")
 	     nil)
-	    ((looking-at "inc:")	; Error messages
-	     (setq mode-line-format (mh-make-mode-line))
-	     (goto-char point-before-inc)
-	     (message "inc error")
-	     nil)
 	    (t
-	     (keep-lines "^[ ]*[0-9]")
+	     (kill-line 2)
 	     (setq mode-line-format (mh-make-mode-line))
-	     (mh-goto-cur-msg)
 	     t)))))
 
 
-(defun mh-make-mode-line (&optional annotation)
-  "Returns a string for mode-line-format.  The optional ANNOTATION string is
-displayed after the folder's name."
+(defun mh-make-mode-line ()
+  "Returns a string for mode-line-format."
   (save-excursion
-    (goto-char (point-min))
     (let ((lines (count-lines (point-min) (point-max))))
+      (goto-char (point-min))
       (let* ((first (mh-get-msg-num nil))
 	     (case-fold-search nil)
 	     (current (and (re-search-forward "....\\+" nil t)
@@ -971,15 +826,14 @@ displayed after the folder's name."
 	(goto-char (point-max))
 	(previous-line 1)
 	(let ((last (mh-get-msg-num nil)))
-	  (format "{%%b%s}  [%d messages%s%s]  (%%p%%%% - %%m)  %%M"
-		  (if annotation (format "/%s" annotation) "")
-		  lines
+	  (concat "{%b} %[" lines " messages"
 		  (if (> lines 0)
-		      (format "  (%d - %d)" first last)
+		      (format " (%d - %d)" first last)
 		      "")
 		  (if current
-		      (format "  cur = %d" current)
-		      "")))))))
+		      (format " cur = %d" current)
+		      "")
+		  "%]	(%p%% - %m)"))))))
 
 
 (defun mh-unmark-all-headers (remove-all-flags)
@@ -989,8 +843,7 @@ displayed after the folder's name."
 	(case-fold-search nil))
     (goto-char (point-min))
     (while (if remove-all-flags
-	       (re-search-forward "^....\\D\\|^....\\^\\|^....\\+\\|.....%"
-				  nil t)
+	       (re-search-forward "^....\\D\\|^....\\^\\|^....\\+" nil t)
 	       (re-search-forward "^....\\+" nil t))
       (delete-backward-char 1)
       (insert " "))))
@@ -998,8 +851,8 @@ displayed after the folder's name."
 
 (defun mh-goto-cur-msg ()
   "Position the cursor at the current message."
-  (let ((curmsg (mh-get-cur-msg mh-current-folder)))
-    (cond ((or (zerop curmsg) (not (mh-goto-msg curmsg t)))
+  (let ((curmsg (mh-get-cur-msg mh-folder-filename)))
+    (cond ((or (zerop curmsg) (mh-goto-msg curmsg t))
 	   (goto-char (point-max))
 	   (forward-line -1)
 	   (mh-maybe-show)
@@ -1015,12 +868,18 @@ displayed after the folder's name."
     (message "closing folder...")
     (mh-process-commands mh-current-folder)
     (message "packing folder...")
-    (mh-exec-cmd-quiet 0 "folder" mh-current-folder "-pack")
+    (mh-exec-cmd-quiet "folder" mh-current-folder "-pack")
     (mh-regenerate-headers "all")
     (message "packing done"))
   (setq mode-line-format (mh-make-mode-line)))
 
 
+(defun mh-map-over-msgs (func list)
+  "Apply the function FUNC to each message in message-list LIST, 
+passing the name and list of messages as arguments."
+  (mapcar (function (lambda (l) (apply func (list (car l) (cdr l))))) list))
+
+
 (defun mh-process-commands (buffer)
   "Process outstanding commands for the buffer BUFFER."
   (message "Processing deletes and moves...")
@@ -1028,60 +887,37 @@ displayed after the folder's name."
   (let ((buffer-read-only nil))
     ;; Sequences must be first
     (mh-process-seq-commands mh-seq-list)
-    ;; Update the unseen sequence
-    (if mh-seen-list
-	(let ((unseen-seq (mh-get-profile-field "Unseen-Sequence:")))
-	  (if (null unseen-seq)		; For MH.5
-	      (setq unseen-seq "unseen"))
-	  (apply 'mh-exec-cmd-quiet
-		 (nconc (list 0 "mark" mh-current-folder)
-			mh-seen-list
-			(list "-sequence" unseen-seq "-delete")))))
 
     ;; Then refile messages
-    (mapc (function
-	   (lambda (dest)
-	     (let ((msgs (mh-seq-to-msgs dest)))
-	       (when msgs
-		 (mh-delete-scan-msgs msgs)
+    (mh-map-over-msgs
+     (function (lambda (dest msgs)
 		 (apply 'mh-exec-cmd
 			(nconc (cons "refile" msgs)
-			       (list "-src" buffer (symbol-name dest))))))))
-	  mh-move-list)
+			       (list "-src" (format "%s" buffer) dest)))))
+     mh-move-list)
 
     ;; Now delete messages
-    (when mh-delete-list
-      (apply 'mh-exec-cmd
-	     (nconc (list "rmm" (format "%s" buffer)) mh-delete-list))
-      (mh-delete-scan-msgs mh-delete-list))
+    (if mh-delete-list
+	(apply 'mh-exec-cmd
+	       (nconc (list "rmm" (format "%s" buffer)) mh-delete-list)))
 
     ;; Mark as cur message.
-    (cond ((mh-get-msg-num nil)
-	   (mh-exec-cmd "mark" mh-current-folder (mh-get-msg-num nil)
-			"-seq" "cur" "-add" "-zero"))
-	  ((> (buffer-size) 0)		; Some messages left in folder.
-	   (mh-exec-cmd "mark" mh-current-folder
-			"-seq" "cur" "-delete" "all")))
-
-    (save-excursion
-      (switch-to-buffer mh-show-buffer)
-      (setq buffer-file-name nil))	; Invalidate buffer file cache
+    (if (mh-get-msg-num nil)
+	(mh-exec-cmd-no-wait "mark" mh-current-folder (mh-get-msg-num nil)
+			     "-seq" "cur" "-add" "-zero" "-nolist")
+	(mh-exec-cmd-no-wait "mark" mh-current-folder "-seq" "cur" "-delete"
+			     "all" "-nolist"))
 
+    (switch-to-buffer buffer)
+    (goto-char (point-min))
+    (flush-lines "^....D")
+    (goto-char (point-min))
+    (flush-lines "^....^")
     (setq mh-delete-list nil
 	  mh-move-list nil
-	  mh-seq-list nil
-	  mh-seen-list nil))
+	  mh-seq-list nil))
   (message "Processing deletes and moves...done"))
 
-
-(defun mh-delete-scan-msgs (msgs)
-  "Delete the scan listing lines for each of the msgs in the LIST."
-  (save-excursion
-    (goto-char (point-min))
-    (while msgs
-      (flush-lines (mh-msg-search-pat (car msgs)))
-      (setq msgs (cdr msgs)))))
-
 
 
 ;;; A mode for composing and sending a message.
@@ -1112,12 +948,10 @@ displayed after the folder's name."
 
 
 (defun mh-to-subject ()
-  "Move point to end of Subject: field.  Creates the field if necessary"
+  "Move point to end of Subject: field."
   (interactive)
   (expand-abbrev)
-  (when (not (mh-position-on-field "Subject:" t))
-    (mh-position-on-field "To:" nil)
-    (insert-string "\nSubject: ")))
+  (mh-position-on-field "Subject:" t))
 
 
 (defun mh-to-cc ()
@@ -1151,15 +985,13 @@ displayed after the folder's name."
   "List recipients of the current message."
   (interactive)
   (let ((file-name (buffer-file-name)))
-    (set-buffer-modified-p t)		; Force writing of contents
     (save-buffer)
     (message "Checking recipients...")
     (switch-to-buffer-other-window "*Mail Recipients*")
     (bury-buffer (current-buffer))
     (erase-buffer)
     (mh-exec-cmd-output "whom" file-name)
-    (other-window -1)
-    (message "Checking recipients...done")))
+    (previous-window)))
 
 
 
@@ -1184,28 +1016,28 @@ displayed after the folder's name."
 
 
 (defun mh-do-pick-search ()
-  "Search the current folder for the messages matching the qualification
-in the current buffer and make them into a sequence called `search'."
+  "Search for the messages in the current folder meeting the qualification
+in the current buffer and make them into a sequence."
   (interactive)
   (let* ((pattern-buffer (buffer-name))
 	 (searching-buffer mh-searching-folder)
 	 (range "all")
+	 (seq (mh-new-seq mh-searching-folder))
 	 (pattern nil))
     (message "Searching...")
     (goto-char (point-min))
     (while (setq pattern (mh-next-pick-field pattern-buffer))
       (setq msgs
 	    (mh-seq-from-command searching-buffer
-				 'search
+				 seq
 				 (nconc (cons "pick" pattern)
 					(list searching-buffer
 					      range
-					      "-sequence" "search"
-					      "-list"))))
-      (setq range "search"))
+					      "-sequence" seq "-list"))))
+      (setq range seq))
     (message "Searching...done")
     (switch-to-buffer searching-buffer)
-    (mh-notate-seq 'search ?% (+ mh-cmd-note 1))))
+    (mh-notate-seq seq (mh-seq-to-notation seq) 0)))
 
 
 (defun mh-next-pick-field (buffer)
@@ -1238,7 +1070,7 @@ BUFFER.  Returns nil if no pieces remain."
 
 (defun mh-compose-and-send-mail (send-args sent-from-folder to subject cc
 					   &optional annotate-char
-					   annotate-field search-prefix)
+					   annotate-field)
   "Edit and compose a draft message and send or save it.
 SENT-FROM-FOLDER is buffer containing summary of current folder, if any.
 SEND-ARGS is an optional argument passed to the send command.
@@ -1253,52 +1085,36 @@ for mh-annotate-msg."
 	(setq sent-from-msg (mh-get-msg-num nil))))
     (pop-to-buffer "draft")
     (mh-letter-mode)
-    (make-local-vars
-     'mh-send-args send-args
-     'mh-sent-from-folder sent-from-folder
-     'mh-sent-from-msg sent-from-msg
-     'mh-annotate-field annotate-field
-     'mh-annotate-char annotate-char
-     'mh-annotate-search-prefix (if search-prefix search-prefix ""))
+    (make-local-variable 'mh-send-args)
+    (setq mh-send-args send-args)
+    (make-local-variable 'mh-sent-from-folder)
+    (setq mh-sent-from-folder sent-from-folder)
+    (make-local-variable 'mh-sent-from-msg)
+    (setq mh-sent-from-msg sent-from-msg)
+    (make-local-variable 'mh-annotate-field)
+    (setq mh-annotate-field annotate-field)
+    (make-local-variable 'mh-annotate-char)
+    (setq mh-annotate-char annotate-char)
     (setq mode-line-format "{%b}  %[Mail/draft%] (%p - %m) (^C^C to send) %M")
     (if (and (boundp 'mh-compose-letter-hook) mh-compose-letter-hook)
 	(funcall mh-compose-letter-hook to subject cc))))
 
 
-(defun mh-send-letter (&optional arg)
-  "Send the letter in the current buffer.  If given an ARGUMENT, the delivery
-process is monitored and displayed."
-  (interactive "P")
+(defun mh-send-letter ()
+  "Send the letter in the current buffer."
+  (interactive)
   (save-buffer)
   (message "Sending...")
-  (if arg
-      (let ((from-buffer (buffer-name))
-	    (file-name (buffer-file-name)))
-	(pop-to-buffer " *mh-temp*")
-	(erase-buffer)
-	(if mh-send-args
-	    (mh-exec-cmd-output "send" "-watch" "-unique" mh-send-args
-				file-name)
-	    (mh-exec-cmd-output "send" "-watch" "-unique" file-name))
-	(pop-to-buffer from-buffer))
-      (if mh-send-args
-	  (mh-exec-cmd-quiet 0 "send" "-push" "-unique" mh-send-args
-			     (buffer-file-name))
-	  (mh-exec-cmd-quiet 0 "send" "-push" "-unique" (buffer-file-name))))
+  (if mh-send-args
+      (mh-exec-cmd-no-wait "send" "-push" "-unique" mh-send-args
+			   (buffer-file-name))
+      (mh-exec-cmd-no-wait "send" "-push" "-unique" (buffer-file-name)))
   (if mh-annotate-char
-      (mh-annotate-msg mh-sent-from-msg
-		       mh-sent-from-folder
+      (mh-annotate-msg mh-sent-from-msg mh-sent-from-folder
 		       mh-annotate-char
 		       "-component" mh-annotate-field
-		       "-text" (format "\"%s %s\""
-				       (mh-get-field
-					(format "%s%s"
-						mh-annotate-search-prefix
-						"To:"))
-				       (mh-get-field
- 					(format "%s%s"
-						mh-annotate-search-prefix
-						"Cc:")))))
+		       "-text" (format "\"%s %s\"" (mh-get-field "To:")
+				      (mh-get-field "Cc:"))))
   (message "Sending...done")
   (kill-buffer (buffer-name)))
 
@@ -1317,7 +1133,7 @@ header fields.  Leaves point before the text and mark after it."
 					 ""))))
 	(start (point)))
     (if (equal message "") (setq message (format "%d" mh-sent-from-msg)))
-    (mh-exec-lib-cmd-output "mhl" "-nobell" "-noclear"
+    (mh-exec-lib-cmd-output "mhl" "-nobell"
 			    (format "%s%s/%s" mh-user-path
 				    (substring folder 1) message))
     (when (not (equal arg 4))
@@ -1329,15 +1145,15 @@ header fields.  Leaves point before the text and mark after it."
 
 
 (defun mh-insert-cur-msg ()
-  "Inserts the currently displayed message into the current draft buffer.
-Prefixes each non-blank line with the string mh-ins-buf-prefix.
-If there is a region set in the  message's buffer,only the region will
-be inserted.  Otherwise, the region from (point) to the end will be grabbed."
+  "Inserts the currently visible message into the current buffer.
+Prefixes the string mh-ins-buf-prefix to each non-blank line
+of the inserted text.  If there is a region set in the
+currently visible message's buffer, only the region will be grabbed.
+Otherwise, the region from (point) to the end will be grabbed."
   (interactive)
   (let ((to-point (point))
 	(to-buffer (current-buffer)))
-    (set-buffer mh-sent-from-folder)
-    (set-buffer mh-show-buffer)		; Find displayed message
+    (set-buffer "*message*")
     (let  ((mh-ins-str (if (mark)
 			   (buffer-substring (point) (mark))
 			   (buffer-substring (point) (point-max)))))
@@ -1365,10 +1181,7 @@ if you don't want to delete the draft message file."
 
 
 
-;;; Commands to manipulate sequences.  Sequences are stored in an alist
-;;; of the form:
-;;;	((seq-name msgs ...) (seq-name msgs ...) ...)
-
+;;; Commands to manipulate sequences.
 
 (defmacro mh-seq-name (pair)
   (list 'car pair))
@@ -1378,38 +1191,14 @@ if you don't want to delete the draft message file."
 
 
 (defun mh-seq-to-msgs (seq)
-  "Returns the messages in sequence SEQ."
+  "Returns the list of messages in sequence SEQ."
   (mh-seq-msgs (assoc seq mh-seq-list)))
 
 
-(defun mh-msg-to-seq (msg)
-  "Given a MESSAGE number, return the first sequence in which it occurs."
-  (let ((l mh-seq-list))
-    (while (and l (not (memq msg (cdar l))))
-      (setq l (cdr l)))
-    (caar l)))
-
-
-(defun mh-read-seq (prompt &optional seq)
-  "Read and return a sequence name from the minibuffer, prompting with 
-the string PROMPT and supplying the optional DEFAULT.
-% defaults to the sequences that the current message is in.
-Makes sure that the sequence is known to MH commands."
-  (let ((input (completing-read
-		(format "%s %s %s" prompt "sequence:"
-			(if seq (format "[%s] " (symbol-name seq)) ""))
-		(mh-seq-names mh-seq-list))))
-    (let ((seq (cond ((equal input "%") (mh-msg-to-seq (mh-get-msg-num t)))
-		     ((equal input "") seq)
-		     (t (intern input)))))
-      (mh-process-seq seq (mh-seq-to-msgs seq))
-      seq)))
-
-
-(defun mh-seq-names (seq-list)
-  "Returns an alist of the names of the SEQUENCES."
-  (mapcar (function (lambda (entry) (cons (symbol-name (car entry)) nil)))
-	  seq-list))
+(defun mh-read-seq (prompt)
+  "Prompt the user with PROMPT and read a sequence name."
+  (mh-char-to-seq
+   (string-to-char (read-string (format "%s %s" prompt "sequence: ")))))
 
 
 (defun mh-seq-from-command (folder seq command)
@@ -1418,7 +1207,8 @@ Makes sure that the sequence is known to MH commands."
 	(case-fold-search t))
     (save-excursion
       (save-window-excursion
-	(apply 'mh-exec-cmd-quiet (cons " *mh-temp*" command))
+	(apply 'mh-exec-cmd-quiet command)
+	(switch-to-buffer " *mh-temp*")
 	(goto-char (point-min))
 	(while (re-search-forward "\\([0-9]+\\)" nil t)
 	  (let ((num (string-to-int (buffer-substring (match-beginning 1)
@@ -1434,96 +1224,74 @@ Makes sure that the sequence is known to MH commands."
   "Delete the sequence SEQ."
   (let ((entry (assoc seq mh-seq-list)))
     (setq mh-seq-list (delq (car entry) mh-seq-list))
-    (mh-notate-seq (mh-seq-msgs (car entry)) ?  (+ mh-cmd-note 1))))
+    (mh-notate-seq (mh-seq-msgs (car entry)) ?  0)))
 
 
-(defun mh-remove-msg-from-seq (msg-num seq &optional do-not-mark)
-  "Remove a message MSG-NUM from the sequence SEQ.  If optional FLAG is
-non-nil, do not mark the message as being part of a sequence."
+(defun mh-remove-msg-from-seq (msg-num seq)
+  "Remove a message MSG-NUM from the sequence SEQ."
   (let ((seq (assoc seq mh-seq-list)))
     (if seq
 	(setcdr seq (delq msg-num (mh-seq-msgs seq)))))
-  (if (not do-not-mark) (mh-notate ? (+ mh-cmd-note 1))))
+  (mh-notate ? 0))
 
 
-(defun mh-add-msg-to-seq (msg-num seq &optional do-not-mark)
-  "Add the message MSG-NUM to the SEQUENCE.  If optional FLAG is non-nil,
-do not mark the message as being part of a sequence."
+(defun mh-add-msg-to-seq (msg-num seq)
+  "Add a message MSG-NUM to a sequence SEQ."
   (let ((seq-list (assoc seq mh-seq-list)))
-    (if (not do-not-mark) (mh-notate ?% (+ mh-cmd-note 1)))
+    (mh-notate (mh-seq-to-notation seq) 0)
     (if (null seq-list)
 	(push (cons seq (list msg-num)) mh-seq-list)
 	(setcdr seq-list (cons msg-num (cdr seq-list))))))
 
 
-(defun mh-add-msg-list-to-seq (msgs seq &optional do-not-mark)
-  "Add the messages in LIST to the SEQUENCE.  If optional FLAG is non-nil,
-do not mark the messages as being part of a sequence."
-  (mapc (function (lambda (msg) (mh-add-msg-to-seq msg seq do-not-mark)))
-	msgs))
 
+(defun mh-new-seq (folder)
+  "Return a new sequence name for FOLDER."
+  (save-excursion
+    (switch-to-buffer folder)
+    (if (= mh-next-seq-num 10)
+	(error "No more sequences"))
+    (setq mh-next-seq-num (+ mh-next-seq-num 1))
+    (mh-char-to-seq (+ (1- mh-next-seq-num) ?a))))
+
+
+(defun mh-char-to-seq (letter)
+  "Given a LETTER, return a string that is a valid sequence name."
+  (cond ((and (>= letter ?0) (<= letter ?9))
+	 (intern (format "mhe%c" letter)))
+	((and (>= letter ?a) (<= letter ?z))
+	 (intern (format "mhe%c" letter)))
+	(t
+	 (error "A sequence is named 0...9"))))
 
-(defun mh-rename-seq (seq new-name)
-  "Rename a SEQUENCE to have a new NAME."
-  (interactive "SOld sequence name: \nSNew name: ")
-  (let ((old-seq (assoc seq mh-seq-list)))
-    (if old-seq
-	(rplaca old-seq new-name)
-	(error "Sequence %s does not exists" (symbol-name seq)))))
+
+(defun mh-seq-to-notation (seq)
+  "Return the string used to indicate sequence SEQ in a scan listing."
+  (string-to-char (substring (symbol-name seq) 3 4)))
 
 
 (defun mh-notate-seq (seq notation offset)
   "Mark all messages in the sequence SEQ with the NOTATION at character
 OFFSET."
-  (mh-map-to-seq-msgs 'mh-notate seq notation offset))
+  (mh-map-over-seq 'mh-notate seq notation offset))
 
 
-(defun mh-map-to-seq-msgs (func seq &rest args)
+(defun mh-map-over-seq (func seq &rest args)
   "Invoke the function FUNC at each message in the sequence SEQ, passing
 the remaining ARGS as arguments."
-  (let ((msgs (mh-seq-to-msgs seq)))
-    (while msgs
-      (mh-goto-msg (car msgs))
-      (apply func args)
-      (setq msgs (cdr msgs)))))
-
-
-(defun mh-map-over-seqs (func seq-list)
-  "Apply the function FUNC to each element in the sequence LIST,
-passing the sequence name and a list of messages as arguments."
-  (while seq-list
-    (funcall func (caar seq-list) (cdar seq-list))
-    (setq seq-list (cdr seq-list))))
+  (mapcar (function (lambda (msg) (mh-goto-msg msg) (apply func args)))
+	  (mh-seq-to-msgs seq)))
 
 
 (defun mh-process-seq-commands (seq-list)
   "Process outstanding sequence commands for the sequences in SEQ-LIST."
-  (mh-map-over-seqs 'mh-process-seq seq-list))
-
-
-(defun mh-process-seq (seq msgs)
-  "Mark sequence SEQ to contain MSGS."
-  ;; Do not mark pseudo-sequences.
-  (if (not (equal (substring (symbol-name seq) 0 1) "+"))
-      (apply 'mh-exec-cmd
-	     (nconc (list "mark" "-zero" "-seq" (format "%s" seq) "-add")
-		    msgs))))
-
-
-(defun mh-copy-seq-to-point (seq location)
-  "Copy the messages in SEQUENCE to after the LOCATION in the current buffer."
-  (mh-map-to-seq-msgs 'mh-copy-line-to-point seq location))
-
-
-(defun mh-copy-line-to-point (location)
-  "Copy the current line to the LOCATION in the current buffer."
-  (beginning-of-line)
-  (let ((beginning-of-line (point)))
-    (forward-line 1)
-    (copy-region-as-kill beginning-of-line (point))
-    (goto-char location)
-    (yank)
-    (goto-char beginning-of-line)))
+  (mh-map-over-msgs
+   (function (lambda (seq msgs)
+	       (apply 'mh-exec-cmd-quiet
+		      (nconc (list "mark" "-zero" "-seq" (format "%s" seq)
+				   "-add" "-nolist")
+			     msgs))))
+   seq-list))
 
 
 
@@ -1534,42 +1302,46 @@ passing the sequence name and a list of messages as arguments."
   (save-excursion
     (switch-to-buffer-other-window " *mh-temp*")
     (erase-buffer)
-    (apply 'call-process
-	   (nconc (list (format "%s%s" mh-progs command) nil t nil)
-		  (mh-list-to-string args)))
+    (apply 'call-process (nconc (list (format "%s%s" mh-progs command)
+				      nil t nil)
+				(mh-list-to-string args)))
     (if (> (buffer-size) 0)
 	(sit-for 5))))
 
 
-(defun mh-exec-cmd-quiet (buffer command &rest args)
-  "In BUFFER, execute MH command COMMAND with ARGS.  Return in buffer, if
-one exists."
-  (when (stringp buffer)
-    (switch-to-buffer buffer)
-    (erase-buffer))
-  (apply 'call-process
-	 (nconc (list (format "%s%s" mh-progs command) nil buffer nil)
-		(mh-list-to-string args))))
+(defun mh-exec-cmd-quiet (command &rest args)
+  "Execute MH command COMMAND with ARGS.  Output is collected, but not shown
+ to the user."
+  (save-excursion
+    (switch-to-buffer " *mh-temp*")
+    (erase-buffer)
+    (apply 'call-process (nconc (list (format "%s%s" mh-progs command)
+				      nil t nil)
+				(mh-list-to-string args)))))
 
 
 (defun mh-exec-cmd-output (command &rest args)
   "Execute MH command COMMAND with ARGS putting the output into buffer after
 point.  Set mark after inserted text."
   (set-mark (point))
-  (apply 'call-process
-	 (nconc (list (format "%s%s" mh-progs command) nil t nil)
-		(mh-list-to-string args)))
+  (apply 'call-process (nconc (list (format "%s%s" mh-progs command) nil t nil)
+			      (mh-list-to-string args)))
   (exchange-point-and-mark))
 
 
+(defun mh-exec-cmd-no-wait (command &rest args)
+  "Execute MH command COMMAND with ARGS and do not wait until it finishes."
+  (apply 'call-process (nconc (list (format "%s%s" mh-progs command) nil 0 nil)
+			      (mh-list-to-string args))))
+
+
 
 (defun mh-exec-lib-cmd-output (command &rest args)
   "Execute MH library command COMMAND with ARGS.  Put the output into
 buffer after point.  Set mark after inserted text."
   (set-mark (point))
-  (apply 'call-process
-	 (nconc (list (format "%s%s" mh-lib command) nil t nil)
-		(mh-list-to-string args)))
+  (apply 'call-process (nconc (list (format "%s%s" mh-lib command) nil t nil)
+			      (mh-list-to-string args)))
   (exchange-point-and-mark))
 
 
@@ -1597,11 +1369,11 @@ buffer after point.  Set mark after inserted text."
   "Mark the MESSAGE in BUFFER listing with the character NOTE and annotate
 the saved message with ARGS."
   ;; Wait for annotation to finish, to avoid race condition with reading msg.
-  (apply 'mh-exec-cmd (cons "anno" (cons buffer (cons msg args))))
+  (apply 'mh-exec-cmd (cons "anno" (nconc (list buffer msg) args)))
   (save-excursion
     (switch-to-buffer buffer)
     (if (mh-goto-msg msg t)
-	(mh-notate note (+ mh-cmd-note 1)))))
+	(mh-notate note 5))))
 
 
 (defun mh-notate (notation offset)
@@ -1627,10 +1399,10 @@ If the CAN-CREATE flag is t,then a non-existant folder is made."
 			     (format " [%s]? " default))))
 	 name)
     (while (and (setq name (completing-read prompt mh-folder-list
-					    nil (not can-create) "+"))
+					    nil (not can-create)))
 		(equal name "")
 		(equal default "")))
-    (cond ((or (equal name "") (equal name "+"))
+    (cond ((equal name "")
 	   (setq name default))
 	  ((not (equal (substring name 0 1) "+"))
 	   (setq name (format "+%s" name))))
@@ -1660,13 +1432,15 @@ If the CAN-CREATE flag is t,then a non-existant folder is made."
 read."
   (interactive)
   (save-window-excursion
-    (mh-exec-cmd-quiet " *mh-temp*" "folders" "-fast" "-norecurse")
+    (mh-exec-cmd-quiet "folders" "-fast" "-norecurse")
+    (switch-to-buffer " *mh-temp*")
     (goto-char (point-min))
     (let ((list nil))
       (while (not (eobp))
 	(let ((start (point)))
 	  (search-forward "\n" nil t)
 	  (let ((folder (buffer-substring start (- (point) 1))))
+	    (push (list folder) list)
 	    (push (list (format "+%s" folder)) list))))
       list)))
 
@@ -1683,11 +1457,14 @@ read."
 
 (defun mh-get-msg-num (error-if-no-message)
   "Returns the message number of the current message.  If the argument
-ERROR-IF-NO-MESSAGE is non-nil, then complain if the cursor is not 
-pointing to a message."
+ERROR-IF-NO-MESSAGE is t, then complain if the cursor is not pointing to a
+message."
   (save-excursion
     (beginning-of-line)
-    (cond ((looking-at "^[ ]*\\([0-9]+\\)")
+    (cond ((looking-at "^[0-9a-z]?[ ]+\\([0-9]+\\)")
+	   (string-to-int (buffer-substring (match-beginning 1)
+					    (match-end 1))))
+	  ((looking-at "^\\([0-9]+\\)")
 	   (string-to-int (buffer-substring (match-beginning 1)
 					    (match-end 1))))
 	  (error-if-no-message
@@ -1697,9 +1474,9 @@ pointing to a message."
 
 (defun mh-msg-search-pat (n)
   "Returns a search pattern for message N in the scan listing."
-  (cond ((< n 10) (format "^[^0-9][^0-9][^0-9]%d" n))
-	((< n 100) (format "^[^0-9][^0-9]%d" n))
-	((< n 1000) (format "^[^0-9]%d" n))
+  (cond ((< n 10) (format "^...%d" n))
+	((< n 100) (format "^..%d" n))
+	((< n 1000) (format "^.%d" n))
 	(t (format "^%d" n))))
 
 
@@ -1715,23 +1492,18 @@ current message."
 
 
 (defun mh-find-path ()
-   "Set mh-user-path to the user's Mail directory from  ~/.mh_profile."
-   (if (equal (setq mh-user-path (mh-get-profile-field "Path:")) "")
-       (setq mh-user-path "Mail/")
-       (setq mh-user-path (format "%s/" mh-user-path)))
-   (if (not (equal (substring mh-user-path 0 1) "/"))
-       (setq mh-user-path (format "%s/%s" (getenv "HOME") mh-user-path))))
-
-
-(defun mh-get-profile-field (field)
-  "Return FIELD from the user's .mh_profile file."
+  "Set mh_path from  ~/.mh_profile."
   (save-window-excursion
     (if (not (file-exists-p "~/.mh_profile"))
 	(error "Cannot find .mh_profile file."))
     (switch-to-buffer " *mh_temp*")
     (erase-buffer)
     (insert-file-contents "~/.mh_profile")
-    (mh-get-field field)))
+    (if (equal (setq mh-user-path (mh-get-field "Path:")) "")
+	(setq mh-user-path "Mail/")
+	(setq mh-user-path (format "%s/" mh-user-path)))
+    (if (not (equal (substring mh-user-path 0 1) "/"))
+	(setq mh-user-path (format "%s/%s" (getenv "HOME") mh-user-path)))))
 
 
 (defun mh-get-cur-msg (folder)
@@ -1740,7 +1512,7 @@ current message."
     (switch-to-buffer " *mh_temp*")
     (erase-buffer)
     (mh-exec-cmd-output "pick" folder "cur")
-    (string-to-int (buffer-substring (point-min) (point-max)))))
+    (string-to-int (buffer-substring (point-min) (point)))))
 
 
 (defun mh-get-field (field)
@@ -1751,7 +1523,7 @@ Returns the empty string if the field is not in the message."
     (cond ((not (search-forward field nil t)) "")
 	  ((looking-at "[\t ]*$") "")
 	  (t
-	   (re-search-forward "[\t ]*\\([a-zA-z0-9/\.].*\\)$" nil t)
+	   (re-search-forward "[\t ]*\\([a-zA-z0-9/].*\\)$" nil t)
 	   (let ((field (buffer-substring (match-beginning 1)
 					  (match-end 1)))
 		 (end-of-match (point)))
@@ -1791,13 +1563,16 @@ to the point, if SET-MARK is non-nil."
 
 ;;; Build the folder-mode keymap:
 
-(define-key mh-folder-mode-map "?" 'mh-msg-is-in-seq)
-(define-key mh-folder-mode-map "%" 'mh-put-msg-in-seq)
-(define-key mh-folder-mode-map "\e%" 'mh-delete-msg-from-seq)
-(define-key mh-folder-mode-map "\^xn" 'mh-narrow-to-seq)
-(define-key mh-folder-mode-map "\^xw" 'mh-widen)
-
-(define-key mh-folder-mode-map "\^c" 'my-apply-command-to-seq)
+(define-key mh-folder-mode-map "9" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "8" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "7" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "6" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "5" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "4" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "3" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "2" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "1" 'mh-indicate-seq)
+(define-key mh-folder-mode-map "0" 'mh-indicate-seq)
 (define-key mh-folder-mode-map "\eu" 'mh-undo-folder)
 (define-key mh-folder-mode-map "\e " 'mh-page-digest)
 (define-key mh-folder-mode-map "\ee" 'mh-extract-rejected-mail)
@@ -1807,11 +1582,12 @@ to the point, if SET-MARK is non-nil."
 (define-key mh-folder-mode-map "\ep" 'mh-renumber-folder)
 (define-key mh-folder-mode-map "\es" 'mh-search-folder)
 (define-key mh-folder-mode-map "\er" 'mh-rescan-folder)
+(define-key mh-folder-mode-map "\ei" 'mh-inc-folder)
 (define-key mh-folder-mode-map "l" 'mh-print-msg)
 (define-key mh-folder-mode-map "t" 'mh-toggle-summarize)
 (define-key mh-folder-mode-map "c" 'mh-copy-msg)
 (define-key mh-folder-mode-map ">" 'mh-write-msg-to-file)
-(define-key mh-folder-mode-map "i" 'mh-inc-folder)
+(define-key mh-folder-mode-map "?" 'mh-summary)
 (define-key mh-folder-mode-map "x" 'mh-execute-commands)
 (define-key mh-folder-mode-map "e" 'mh-execute-commands)
 (define-key mh-folder-mode-map "r" 'mh-redistribute)
@@ -1823,12 +1599,12 @@ to the point, if SET-MARK is non-nil."
 (define-key mh-folder-mode-map " " 'mh-page-msg)
 (define-key mh-folder-mode-map "." 'mh-show)
 (define-key mh-folder-mode-map "u" 'mh-undo)
-(define-key mh-folder-mode-map "!" 'mh-move-or-write-again)
+(define-key mh-folder-mode-map "!" 'mh-move-again)
 (define-key mh-folder-mode-map "^" 'mh-move-msg)
 (define-key mh-folder-mode-map "d" 'mh-delete-msg)
 (define-key mh-folder-mode-map "p" 'mh-previous-line)
 (define-key mh-folder-mode-map "n" 'mh-next-line)
-
+  
 
 ;;; Build the letter-mode keymap:
 
diff --git a/cpp/cpp.h b/cpp/cpp.h
new file mode 100644
index 0000000..4680878
--- /dev/null
+++ b/cpp/cpp.h
@@ -0,0 +1,249 @@
+
+/*
+ *	I n t e r n a l   D e f i n i t i o n s    f o r   C P P
+ *
+ * In general, definitions in this file should not be changed.
+ */
+
+#ifndef toupper
+#define toupper(c) ((c) + ('A' - 'a'))
+#endif /* no toupper */
+#ifndef tolower
+#define tolower(c) ((c) + ('a' - 'A'))
+#endif /* no tolower */
+
+#ifndef	TRUE
+#define	TRUE		1
+#define	FALSE		0
+#endif
+#ifndef	EOS
+/*
+ * This is predefined in Decus C
+ */
+#define	EOS		'\0'		/* End of string		*/
+#endif
+#define	EOF_CHAR	0		/* Returned by get() on eof	*/
+#define NULLST		((char *) NULL)	/* Pointer to nowhere (linted)	*/
+#define	DEF_NOARGS	(-1)		/* #define foo vs #define foo()	*/
+
+/*
+ * The following may need to change if the host system doesn't use ASCII.
+ */
+#define	DEF_MAGIC	0x1D		/* Magic for #defines		*/
+#define	TOK_SEP		0x1E		/* Token concatenation delim.	*/
+#define COM_SEP		0x1F		/* Magic comment separator	*/
+
+/*
+ * Note -- in Ascii, the following will map macro formals onto DEL + the
+ * C1 control character region (decimal 128 .. (128 + PAR_MAC)) which will
+ * be ok as long as PAR_MAC is less than 33).  Note that the last PAR_MAC
+ * value is reserved for string substitution.
+ */
+
+#define	MAC_PARM	0x7F		/* Macro formals start here	*/
+#if PAR_MAC >= 33
+	assertion fails -- PAR_MAC isn't less than 33
+#endif
+#define	LASTPARM	(PAR_MAC - 1)
+
+/*
+ * Character type codes.
+ */
+
+#define	INV		0		/* Invalid, must be zero	*/
+#define	OP_EOE		INV		/* End of expression		*/
+#define	DIG		1		/* Digit			*/
+#define	LET		2		/* Identifier start		*/
+#define	FIRST_BINOP	OP_ADD
+#define	OP_ADD		3
+#define	OP_SUB		4
+#define	OP_MUL		5
+#define	OP_DIV		6
+#define	OP_MOD		7
+#define	OP_ASL		8
+#define	OP_ASR		9
+#define	OP_AND		10		/* &, not &&			*/
+#define	OP_OR		11		/* |, not ||			*/
+#define	OP_XOR		12
+#define	OP_EQ		13
+#define	OP_NE		14
+#define	OP_LT		15
+#define	OP_LE		16
+#define	OP_GE		17
+#define	OP_GT		18
+#define	OP_ANA		19		/* &&				*/
+#define	OP_ORO		20		/* ||				*/
+#define	OP_QUE		21		/* ?				*/
+#define	OP_COL		22		/* :				*/
+#define	OP_CMA		23		/* , (relevant?)		*/
+#define	LAST_BINOP	OP_CMA		/* Last binary operand		*/
+/*
+ * The following are unary.
+ */
+#define	FIRST_UNOP	OP_PLU		/* First Unary operand		*/
+#define	OP_PLU		24		/* + (draft ANSI standard)	*/
+#define	OP_NEG		25		/* -				*/
+#define	OP_COM		26		/* ~				*/
+#define	OP_NOT		27		/* !				*/
+#define	LAST_UNOP	OP_NOT
+#define	OP_LPA		28		/* (				*/
+#define	OP_RPA		29		/* )				*/
+#define	OP_END		30		/* End of expression marker	*/
+#define	OP_MAX		(OP_END + 1)	/* Number of operators		*/
+#define	OP_FAIL		(OP_END + 1)	/* For error returns		*/
+
+/*
+ * The following are for lexical scanning only.
+ */
+
+#define	QUO		65		/* Both flavors of quotation	*/
+#define	DOT		66		/* . might start a number	*/
+#define	SPA		67		/* Space and tab		*/
+#define	BSH		68		/* Just a backslash		*/
+#define	END		69		/* EOF				*/
+
+/*
+ * These bits are set in ifstack[]
+ */
+#define	WAS_COMPILING	1		/* TRUE if compile set at entry	*/
+#define	ELSE_SEEN	2		/* TRUE when #else processed	*/
+#define	TRUE_SEEN	4		/* TRUE when #if TRUE processed	*/
+
+/*
+ * Define bits for the basic types and their adjectives
+ */
+
+#define	T_CHAR		  1
+#define	T_INT		  2
+#define	T_FLOAT		  4
+#define	T_DOUBLE	  8
+#define	T_SHORT		 16
+#define	T_LONG		 32
+#define	T_SIGNED	 64
+#define	T_UNSIGNED	128
+#define	T_PTR		256		/* Pointer			*/
+#define	T_FPTR		512		/* Pointer to functions		*/
+
+/*
+ * The DEFBUF structure stores information about #defined
+ * macros.  Note that the defbuf->repl information is always
+ * in malloc storage.
+ */
+
+typedef struct defbuf {
+	struct defbuf	*link;		/* Next define in chain	*/
+	char		*repl;		/* -> replacement	*/
+	int		hash;		/* Symbol table hash	*/
+	int		nargs;		/* For define(args)	*/
+	char		name[1];	/* #define name		*/
+} DEFBUF;
+
+/*
+ * The FILEINFO structure stores information about open files
+ * and macros being expanded.
+ */
+
+typedef struct fileinfo {
+	char		*bptr;		/* Buffer pointer	*/
+	int		line;		/* for include or macro	*/
+	FILE		*fp;		/* File if non-null	*/
+	struct fileinfo	*parent;	/* Link to includer	*/
+	char		*filename;	/* File/macro name	*/
+	char		*progname;	/* From #line statement	*/
+	unsigned int	unrecur;	/* For macro recursion	*/
+	char		buffer[1];	/* current input line	*/
+} FILEINFO;
+
+/*
+ * The SIZES structure is used to store the values for #if sizeof
+ */
+
+typedef struct sizes {
+    short	bits;			/* If this bit is set,		*/
+    short	size;			/* this is the datum size value	*/
+    short	psize;			/* this is the pointer size	*/
+} SIZES;
+/*
+ * nomacarg is a built-in #define on Decus C.
+ */
+
+#ifdef	nomacarg
+#define	cput		output		/* cput concatenates tokens	*/
+#else
+#if COMMENT_INVISIBLE
+#define	cput(c)		{ if (c != TOK_SEP && c != COM_SEP) putchar(c); }
+#else
+#define	cput(c)		{ if (c != TOK_SEP) putchar(c); }
+#endif
+#endif
+
+#ifndef	nomacarg
+#define	streq(s1, s2)	(strcmp(s1, s2) == 0)
+#endif
+
+/*
+ * Error codes.  VMS uses system definitions.
+ * Decus C codes are defined in stdio.h.
+ * Others are cooked to order.
+ */
+
+#if HOST == SYS_VMS
+#include		<ssdef.h>
+#include		<stsdef.h>
+#define	IO_NORMAL	(SS$_NORMAL | STS$M_INHIB_MSG)
+#define	IO_ERROR	SS$_ABORT
+#endif
+/*
+ * Note: IO_NORMAL and IO_ERROR are defined in the Decus C stdio.h file
+ */
+#ifndef	IO_NORMAL
+#define	IO_NORMAL	0
+#endif
+#ifndef	IO_ERROR
+#define	IO_ERROR	1
+#endif
+
+/*
+ * Externs
+ */
+
+extern int	line;			/* Current line number		*/
+extern int	wrongline;		/* Force #line to cc pass 1	*/
+extern char	type[];			/* Character classifier		*/
+extern char	*tokenbuf;		/* Current input token		*/
+extern int	tokenbsize;		/* Current size allocated in tokenbuf
+					   (not counting 1 byte for zero) */
+extern int	instring;		/* TRUE if scanning string	*/
+extern int	inmacro;		/* TRUE if scanning #define	*/
+extern int	errors;			/* Error counter		*/
+extern int	recursion;		/* Macro depth counter		*/
+extern char	ifstack[BLK_NEST];	/* #if information		*/
+#define	compiling ifstack[0]
+extern char	*ifptr;			/* -> current ifstack item	*/
+extern char	*incdir[NINCLUDE];	/* -i directories		*/
+extern char	**incend;		/* -> active end of incdir	*/
+extern int	cflag;			/* -C option (keep comments)	*/
+extern int	eflag;			/* -E option (ignore errors)	*/
+extern int	nflag;			/* -N option (no pre-defines)	*/
+extern int	rec_recover;		/* unwind recursive macros	*/
+extern char	*preset[];		/* Standard predefined symbols	*/
+extern char	*magic[];		/* Magic predefined symbols	*/
+extern FILEINFO	*infile;		/* Current input file		*/
+extern char	work[NWORK + 1];	/* #define scratch		*/
+extern char	*workp;			/* Free space in work		*/
+#if	DEBUG
+extern int	debug;			/* Debug level			*/
+#endif
+extern int	keepcomments;		/* Don't remove comments if set	*/
+extern SIZES	size_table[];		/* For #if sizeof sizes		*/
+extern char	*getmem();		/* Get memory or die.		*/
+extern char	*incmem();		/* Increase size of block or die.  */
+extern DEFBUF	*lookid();		/* Look for a #define'd thing	*/
+extern DEFBUF	*defendel();		/* Symbol table enter/delete	*/
+extern char	*savestring();		/* Stuff string in malloc mem.	*/
+extern char	*strcpy();
+extern char	*strcat();
+extern char	*strrchr();
+extern char	*strchr();
+extern long	time();
+extern char	*sprintf();		/* Lint needs this		*/
diff --git a/cpp/cpp.mem b/cpp/cpp.mem
new file mode 100644
index 0000000..ead7245
--- /dev/null
+++ b/cpp/cpp.mem
@@ -0,0 +1,286 @@
+
+
+
+
+        1.0  C Pre-Processor
+
+
+
+                                    *******
+                                    * cpp *
+                                    *******
+
+
+
+        NAME:   cpp -- C Pre-Processor
+
+        SYNOPSIS:
+
+                cpp [-options] [infile [outfile]]
+
+        DESCRIPTION:
+
+                CPP reads a C source file, expands  macros  and  include
+                files,  and writes an input file for the C compiler.  If
+                no file arguments are given, CPP reads  from  stdin  and
+                writes  to  stdout.   If  one file argument is given, it
+                will define the input file,  while  two  file  arguments
+                define  both  input and output files.  The file name "-"
+                is a synonym for stdin or stdout as appropriate.
+
+                The following options are  supported.   Options  may  be
+                given in either case.
+
+                -C              If set, source-file comments are written
+                                to  the  output  file.   This allows the
+                                output of CPP to be used as the input to
+                                a  program,  such  as lint, that expects
+                                commands embedded in specially-formatted
+                                comments.
+
+                -Dname=value    Define the name  as  if  the  programmer
+                                wrote
+
+                                    #define name value
+
+                                at the start  of  the  first  file.   If
+                                "=value"  is  not  given, a value of "1"
+                                will be used.
+
+                                On non-unix systems, all alphabetic text
+                                will be forced to upper-case.
+
+                -E              Always return "success" to the operating
+                                system,  even  if  errors were detected.
+                                Note that some fatal errors, such  as  a
+                                missing  #include  file,  will terminate
+                                CPP, returning "failure" even if the  -E
+                                option is given.
+                                                                          Page 2
+        cpp     C Pre-Processor
+
+
+                -Idirectory     Add  this  directory  to  the  list   of
+                                directories  searched for #include "..."
+                                and #include <...> commands.  Note  that
+                                there  is  no space between the "-I" and
+                                the directory string.  More than one  -I
+                                command   is   permitted.   On  non-Unix
+                                systems   "directory"   is   forced   to
+                                upper-case.
+
+                -N              CPP  normally  predefines  some  symbols
+                                defining   the   target   computer   and
+                                operating system.  If -N  is  specified,
+                                no symbols will be predefined.  If -N -N
+                                is  specified,  the   "always   present"
+                                symbols,    __LINE__,    __FILE__,   and
+                                __DATE__ are not defined.
+
+                -Stext          CPP normally assumes that  the  size  of
+                                the  target  computer's  basic  variable
+                                types is the same as the size  of  these
+                                types  of  the host computer.  (This can
+                                be  overridden  when  CPP  is  compiled,
+                                however.)  The  -S option allows dynamic
+                                respecification of these values.  "text"
+                                is  a  string  of  numbers, separated by
+                                commas, that  specifies  correct  sizes.
+                                The sizes must be specified in the exact
+                                order:
+
+                                    char short int long float double
+
+                                If you specify the option as  "-S*text",
+                                pointers   to   these   types   will  be
+                                specified.   -S*  takes  one  additional
+                                argument  for  pointer to function (e.g.
+                                int (*)())
+
+                                For   example,    to    specify    sizes
+                                appropriate  for  a  PDP-11,  you  would
+                                write:
+
+                                       c s i l f d func
+                                     -S1,2,2,2,4,8,
+                                    -S*2,2,2,2,2,2,2
+
+                                Note that all values must be specified.
+
+                -Uname          Undefine the name as if
+
+                                    #undef name
+
+                                were given.  On non-Unix systems, "name"
+                                will be forced to upper-case.
+                                                                          Page 3
+        cpp     C Pre-Processor
+
+
+                -Xnumber        Enable debugging code.  If no  value  is
+                                given,  a value of 1 will be used.  (For
+                                maintenence of CPP only.)
+
+
+        PRE-DEFINED VARIABLES:
+
+                When CPP begins processing, the following variables will
+                have been defined (unless the -N option is specified):
+
+                Target computer (as appropriate):
+
+                    pdp11, vax, M68000 m68000 m68k
+
+                Target operating system (as appropriate):
+
+                    rsx, rt11, vms, unix
+
+                Target compiler (as appropriate):
+
+                    decus, vax11c
+
+                The implementor may add definitions to this  list.   The
+                default  definitions  match  the  definition of the host
+                computer, operating system, and C compiler.
+
+                The following are always available unless undefined  (or
+                -N was specified twice):
+
+                    __FILE__    The  input  (or  #include)  file   being
+                                compiled (as a quoted string).
+
+                    __LINE__    The line number being compiled.
+
+                    __DATE__    The date and time of  compilation  as  a
+                                Unix  ctime  quoted string (the trailing
+                                newline is removed).  Thus,
+
+                                    printf("Bug at line %s,", __LINE__);
+                                    printf(" source file %s", __FILE__);
+                                    printf(" compiled on %s", __DATE__);
+
+
+        DRAFT PROPOSED ANSI STANDARD CONSIDERATIONS:
+
+                The current  version  of  the  Draft  Proposed  Standard
+                explicitly  states  that  "readers  are requested not to
+                specify or claim conformance to this draft." Readers and
+                users  of  Decus  CPP  should  not assume that Decus CPP
+                conforms to the standard, or that it will conform to the
+                actual C Language Standard.
+
+                When CPP is itself compiled, many features of the  Draft
+                Proposed  Standard  that  are incompatible with existing
+                                                                          Page 4
+        cpp     C Pre-Processor
+
+
+                preprocessors may be  disabled.   See  the  comments  in
+                CPP's source for details.
+
+                The latest version of the Draft  Proposed  Standard  (as
+                reflected in Decus CPP) is dated November 12, 1984.
+
+                Comments are removed from the input text.   The  comment
+                is  replaced by a single space character.  The -C option
+                preserves comments, writing them to the output file.
+
+                The '$' character is considered to be a letter.  This is
+                a permitted extension.
+
+                The following new features of C are processed by CPP:
+
+                    #elif expression (#else #if)
+                    '\xNNN' (Hexadecimal constant)
+                    '\a' (Ascii BELL)
+                    '\v' (Ascii Vertical Tab)
+                    #if defined NAME 1 if defined, 0 if not
+                    #if defined (NAME) 1 if defined, 0 if not
+                    #if sizeof (basic type)
+                    unary +
+                    123U, 123LU Unsigned ints and longs.
+                    12.3L Long double numbers
+                    token#token Token concatenation
+                    #include token Expands to filename
+
+                The Draft Proposed Standard has  extended  C,  adding  a
+                constant string concatenation operator, where
+
+                    "foo" "bar"
+
+                is regarded as the single string "foobar".   (This  does
+                not  affect  CPP's  processing but does permit a limited
+                form of macro argument substitution into strings as will
+                be discussed.)
+
+                The Standard Committee plans to add token  concatenation
+                to  #define command lines.  One suggested implementation
+                is as follows:  the sequence "Token1#Token2" is  treated
+                as  if  the programmer wrote "Token1Token2".  This could
+                be used as follows:
+
+                    #line 123
+                    #define ATLINE foo#__LINE__
+
+                ATLINE would be defined as foo123.
+
+                Note that "Token2" must either have  the  format  of  an
+                identifier or be a string of digits.  Thus, the string
+
+                    #define ATLINE foo#1x3
+                                                                          Page 5
+        cpp     C Pre-Processor
+
+
+                generates two tokens:  "foo1" and "x3".
+
+                If the tokens T1 and T2 are concatenated into  T3,  this
+                implementation operates as follows:
+
+                  1. Expand T1 if it is a macro.
+                  2. Expand T2 if it is a macro.
+                  3. Join the tokens, forming T3.
+                  4. Expand T3 if it is a macro.
+
+                A macro formal parameter  will  be  substituted  into  a
+                string or character constant if it is the only component
+                of that constant:
+
+                    #define VECSIZE 123
+                    #define vprint(name, size) \
+                      printf("name" "[" "size" "] = {\n")
+                      ... vprint(vector, VECSIZE);
+
+                expands (effectively) to
+
+                      vprint("vector[123] = {\n");
+
+                Note that  this  will  be  useful  if  your  C  compiler
+                supports  the  new  string concatenation operation noted
+                above.  As implemented here, if you write
+
+                    #define string(arg) "arg"
+                      ... string("foo") ...
+
+                This implementation generates  "foo",  rather  than  the
+                strictly  correct  ""foo"" (which will probably generate
+                an error message).  This is, strictly speaking, an error
+                in CPP and may be removed from future releases.
+
+        ERROR MESSAGES:
+
+                Many.  CPP prints warning or error messages if  you  try
+                to     use     multiple-byte     character     constants
+                (non-transportable) if you #undef a symbol that was  not
+                defined,  or  if  your  program  has  potentially nested
+                comments.
+
+        AUTHOR:
+
+                Martin Minow
+
+        BUGS:
+
+                The #if expression processor uses signed integers  only.
+                I.e, #if 0xFFFFu < 0 may be TRUE.
+
diff --git a/cpp/cpp.rno b/cpp/cpp.rno
new file mode 100644
index 0000000..42c4aa2
--- /dev/null
+++ b/cpp/cpp.rno
@@ -0,0 +1,291 @@
+.lm 8.rm 72.nhy
+
+.no autosubtitle .style headers 3,0,0
+.pg.uc.ps 58,80.lm 8.rm 72
+.hd
+.hd mixed
+.head mixed
+
+.st ########cpp#####C Pre-Processor
+.pg
+.hl 1 ^&C Pre-Processor\&
+.s 2
+.c ;*******
+.c ;* cpp *
+.c ;*******
+.s 2
+.lm +8
+.s.i -8;NAME:	cpp -- C Pre-Processor
+.s.f
+.i -8;SYNOPSIS:
+.s.nf
+cpp [-options] [infile [outfile]]
+.s.f
+.i -8;DESCRIPTION:
+.s
+CPP reads a C source file, expands macros and include
+files, and writes an input file for the C compiler.
+If no file arguments are given, CPP reads from stdin
+and writes to stdout.  If one file argument is given,
+it will define the input file, while two file arguments
+define both input and output files.  The file name "-"
+is a synonym for stdin or stdout as appropriate.
+.s
+The following options are supported.  Options may
+be given in either case.
+.lm +16
+.p -16
+-C		If set, source-file comments are written
+to the output file.  This allows the output of CPP to be
+used as the input to a program, such as lint, that expects
+commands embedded in specially-formatted comments.
+.p -16
+-Dname=value	Define the name as if the programmer wrote
+.s
+.nf
+    _#define name value
+.s
+.fill
+at the start of the first file.  If "=value" is not
+given, a value of "1" will be used.
+.s
+On non-unix systems, all alphabetic text will be forced
+to upper-case.
+.p -16
+-E		Always return "success" to the operating
+system, even if errors were detected.  Note that some fatal
+errors, such as a missing _#include file, will terminate
+CPP, returning "failure" even if the -E option is given.
+.p -16
+-Idirectory	Add this directory to the list of
+directories searched for _#include "..." and _#include <...>
+commands.  Note that there is no space between the
+"-I" and the directory string.  More than one -I command
+is permitted.  On non-Unix systems "directory" is forced
+to upper-case.
+.p -16
+-N		CPP normally predefines some symbols defining
+the target computer and operating system.  If -N is specified,
+no symbols will be predefined.  If -N -N is specified, the
+"always present" symbols, ____LINE____, ____FILE____, and ____DATE____
+are not defined.
+.p -16
+-Stext		CPP normally assumes that the size of
+the target computer's basic variable types is the same as the size
+of these types of the host computer.  (This can be overridden
+when CPP is compiled, however.)  The -S option allows dynamic
+respecification of these values.  "text" is a string of
+numbers, separated by commas, that specifies correct sizes.
+The sizes must be specified in the exact order:
+.s
+.nf
+    char short int long float double
+.s
+.fill
+If you specify the option as "-S*text", pointers to these
+types will be specified.  -S* takes one additional argument
+for pointer to function (e.g. int (*)())
+.s
+For example, to specify sizes appropriate for a PDP-11,
+you would write:
+.s
+.nf
+       c s i l f d func
+     -S1,2,2,2,4,8,
+    -S*2,2,2,2,2,2,2
+.s
+.fill
+Note that all values must be specified.
+.p -16
+-Uname		Undefine the name as if
+.s
+.nf
+    _#undef name
+.s
+.fill
+were given.  On non-Unix systems, "name" will be forced to
+upper-case.
+.p -16
+-Xnumber	Enable debugging code.  If no value is
+given, a value of 1 will be used.  (For maintenence of
+CPP only.)
+.s.lm -16
+.s
+.i -8;PRE-DEFINED VARIABLES:
+.s
+When CPP begins processing, the following variables will
+have been defined (unless the -N option is specified):
+.s
+Target computer (as appropriate):
+.s
+.nf
+    pdp11, vax, M68000 m68000 m68k
+.fill
+.s
+Target operating system (as appropriate):
+.s
+.nf
+    rsx, rt11, vms, unix
+.fill
+.s
+Target compiler (as appropriate):
+.s
+.nf
+    decus, vax11c
+.fill
+.s
+The implementor may add definitions to this list.
+The default definitions match the definition of the
+host computer, operating system, and C compiler.
+.s
+The following are always available unless undefined (or
+-N was specified twice):
+.lm +16
+.p -12
+____FILE____	The input (or _#include) file being compiled
+(as a quoted string).
+.p -12
+____LINE____	The line number being compiled.
+.p -12
+____DATE____	The date and time of compilation as
+a Unix ctime quoted string (the trailing newline is removed).
+Thus,
+.s
+.nf
+    printf("Bug at line _%s,", ____LINE____);
+    printf(" source file _%s", ____FILE____);
+    printf(" compiled on _%s", ____DATE____);
+.fill
+.s.lm -16
+.s
+.i -8;DRAFT PROPOSED ANSI STANDARD CONSIDERATIONS:
+.s
+The current version of the Draft Proposed Standard
+explicitly states that "readers are requested not to specify
+or claim conformance to this draft."  Readers and users
+of Decus CPP should not assume that Decus CPP conforms
+to the standard, or that it will conform to the actual
+C Language Standard.
+.s
+When CPP is itself compiled, many features of the Draft
+Proposed Standard that are incompatible with existing
+preprocessors may be disabled.  See the comments in CPP's
+source for details.
+.s
+The latest version of the Draft Proposed Standard (as reflected
+in Decus CPP) is dated November 12, 1984.
+.s
+Comments are removed from the input text.  The comment
+is replaced by a single space character.  The -C option
+preserves comments, writing them to the output file.
+.s
+The '$' character is considered to be a letter.  This is
+a permitted extension.
+.s
+The following new features of C are processed by CPP:
+.s.comment Note: significant spaces, not tabs, .br quotes #if, #elif
+.br;####_#elif expression    (_#else _#if)
+.br;####'_\xNNN'             (Hexadecimal constant)
+.br;####'_\a'                (Ascii BELL)
+.br;####'_\v'                (Ascii Vertical Tab)
+.br;####_#if defined NAME    1 if defined, 0 if not
+.br;####_#if defined (NAME)  1 if defined, 0 if not
+.br;####_#if sizeof (basic type)
+.br;####unary +
+.br;####123U, 123LU          Unsigned ints and longs.
+.br;####12.3L                Long double numbers
+.br;####token_#token         Token concatenation
+.br;####_#include token      Expands to filename
+.s
+The Draft Proposed Standard has extended C, adding a constant
+string concatenation operator, where
+.s
+.nf
+    "foo" "bar"
+.s
+.fill
+is regarded as the single string "foobar".  (This does not
+affect CPP's processing but does permit a limited form of
+macro argument substitution into strings as will be discussed.)
+.s
+The Standard Committee plans to add token concatenation
+to _#define command lines.  One suggested implementation
+is as follows:  the sequence "Token1_#Token2" is treated
+as if the programmer wrote "Token1Token2".  This could
+be used as follows:
+.s
+.nf
+    _#line 123
+    _#define ATLINE foo_#____LINE____
+.s
+.fill
+ATLINE would be defined as foo123.
+.s
+Note that "Token2" must either have the format of an
+identifier or be a string of digits.  Thus, the string
+.s
+.nf
+    _#define ATLINE foo_#1x3
+.s
+.fill
+generates two tokens: "foo1" and "x3".
+.s
+If the tokens T1 and T2 are concatenated into T3,
+this implementation operates as follows:
+.s
+.nf
+  1. Expand T1 if it is a macro.
+  2. Expand T2 if it is a macro.
+  3. Join the tokens, forming T3.
+  4. Expand T3 if it is a macro.
+.s
+.fill
+A macro formal parameter will be substituted into a string
+or character constant if it is the only component of that
+constant:
+.s
+.nf
+    _#define VECSIZE 123
+    _#define vprint(name, size) _\
+      printf("name" "[" "size" "] = {_\n")
+      ... vprint(vector, VECSIZE);
+.s
+.fill
+expands (effectively) to
+.s
+.nf
+      vprint("vector[123] = {_\n");
+.s
+.fill
+Note that this will be useful if your C compiler supports
+the new string concatenation operation noted above.
+As implemented here, if you write
+.s
+.nf
+    _#define string(arg) "arg"
+      ... string("foo") ...
+.s
+.fill
+This implementation generates "foo", rather than the strictly
+correct ""foo"" (which will probably generate an error message).
+This is, strictly speaking, an error in CPP and may be removed
+from future releases.
+.s
+.i -8;ERROR MESSAGES:
+.s
+Many.  CPP prints warning or error messages if you try to
+use multiple-byte character constants (non-transportable)
+if you _#undef a symbol that was not defined, or if your
+program has potentially nested comments.
+.s
+.i -8;AUTHOR:
+.s
+Martin Minow
+.s
+.i -8;BUGS:
+.s
+The _#if expression processor uses signed integers only.
+I.e, _#if 0xFFFFu < 0 may be TRUE.
+.s
+.lm 8.rm 72.nhy
+
diff --git a/cpp/cpp1.c b/cpp/cpp1.c
new file mode 100644
index 0000000..b3923bc
--- /dev/null
+++ b/cpp/cpp1.c
@@ -0,0 +1,724 @@
+/*
+ * CPP main program.
+ *
+ * Edit history
+ * 21-May-84	MM	"Field test" release
+ * 23-May-84	MM	Some minor hacks.
+ * 30-May-84	ARF	Didn't get enough memory for __DATE__
+ *			Added code to read stdin if no input
+ *			files are provided.
+ * 29-Jun-84	MM	Added ARF's suggestions, Unixifying cpp.
+ * 11-Jul-84	MM	"Official" first release (that's what I thought!)
+ * 22-Jul-84	MM/ARF/SCK Fixed line number bugs, added cpp recognition
+ *			of #line, fixed problems with #include.
+ * 23-Jul-84	MM	More (minor) include hacking, some documentation.
+ *			Also, redid cpp's #include files
+ * 25-Jul-84	MM	#line filename isn't used for #include searchlist
+ *			#line format is <number> <optional name>
+ * 25-Jul-84	ARF/MM	Various bugs, mostly serious.  Removed homemade doprint
+ * 01-Aug-84	MM	Fixed recursion bug, remove extra newlines and
+ *			leading whitespace from cpp output.
+ * 02-Aug-84	MM	Hacked (i.e. optimized) out blank lines and unneeded
+ *			whitespace in general.  Cleaned up unget()'s.
+ * 03-Aug-84	Keie	Several bug fixes from Ed Keizer, Vrije Universitet.
+ *			-- corrected arg. count in -D and pre-defined
+ *			macros.  Also, allow \n inside macro actual parameter
+ *			lists.
+ * 06-Aug-84	MM	If debugging, dump the preset vector at startup.
+ * 12-Aug-84	MM/SCK	Some small changes from Sam Kendall
+ * 15-Aug-84	Keie/MM	cerror, cwarn, etc. take a single string arg.
+ *			cierror, etc. take a single int. arg.
+ *			changed LINE_PREFIX slightly so it can be
+ *			changed in the makefile.
+ * 31-Aug-84	MM	USENET net.sources release.
+ *  7-Sep-84	SCH/ado Lint complaints
+ * 10-Sep-84	Keie	Char's can't be signed in some implementations
+ * 11-Sep-84	ado	Added -C flag, pathological line number fix
+ * 13-Sep-84	ado	Added -E flag (does nothing) and "-" file for stdin.
+ * 14-Sep-84	MM	Allow # 123 as a synonym for #line 123
+ * 19-Sep-84	MM	scanid always reads to token, make sure #line is
+ *			written to a new line, even if -C switch given.
+ *			Also, cpp - - reads stdin, writes stdout.
+ * 03-Oct-84	ado/MM	Several changes to line counting and keepcomments
+ *			stuff.  Also a rewritten control() hasher -- much
+ *			simpler and no less "perfect". Note also changes
+ *			in cpp3.c to fix numeric scanning.
+ * 04-Oct-84	MM	Added recognition of macro formal parameters if
+ *			they are the only thing in a string, per the
+ *			draft standard.
+ * 08-Oct-84	MM	One more attack on scannumber
+ * 15-Oct-84	MM/ado	Added -N to disable predefined symbols.  Fixed
+ *			linecount if COMMENT_INVISIBLE enabled.
+ * 22-Oct-84	MM	Don't evaluate the #if/#ifdef argument if
+ *			compilation is supressed.  This prevents
+ *			unnecessary error messages in sequences such as
+ *			    #ifdef FOO		-- undefined
+ *			    #if FOO == 10	-- shouldn't print warning
+ * 25-Oct-84	MM	Fixed bug in false ifdef supression.  On vms,
+ *			#include <foo> should open foo.h -- this duplicates
+ *			the behavior of Vax-C
+ * 31-Oct-84	ado/MM	Parametized $ in indentifiers.  Added a better
+ *			token concatenator and took out the trial
+ *			concatenation code.  Also improved #ifdef code
+ *			and cleaned up the macro recursion tester.
+ *  2-Nov-84	MM/ado	Some bug fixes in token concatenation, also
+ *			a variety of minor (uninteresting) hacks.
+ *  6-Nov-84	MM	Happy Birthday.  Broke into 4 files and added
+ *			#if sizeof (basic_types)
+ *  9-Nov-84	MM	Added -S* for pointer type sizes
+ * 13-Nov-84	MM	Split cpp1.c, added vms defaulting
+ * 23-Nov-84	MM/ado	-E supresses error exit, added CPP_INCLUDE,
+ *			fixed strncpy bug.
+ *  3-Dec-84	ado/MM	Added OLD_PREPROCESSOR
+ *  7-Dec-84	MM	Stuff in Nov 12 Draft Standard
+ * 17-Dec-84	george	Fixed problems with recursive macros
+ * 17-Dec-84	MM	Yet another attack on #if's (f/t)level removed.
+ * 07-Jan-85	ado	Init defines before doing command line options
+ *			so -Uunix works.
+ * 21-Oct-85	RMS	Rename `token' to `tokenbuf'.
+ *			Allocate it dynamically, with size in `tokenbsize'.
+ * 23-Oct-85	RMS	Do not print message about number of errors.
+ */
+
+/*)BUILD
+	$(PROGRAM)	= cpp
+	$(FILES)	= { cpp1 cpp2 cpp3 cpp4 cpp5 cpp6 }
+	$(INCLUDE)	= { cppdef.h cpp.h }
+	$(STACK)	= 2000
+	$(TKBOPTIONS)	= {
+		STACK	= 2000
+	}
+*/
+
+#ifdef	DOCUMENTATION
+
+title	cpp		C Pre-Processor
+index			C pre-processor
+
+synopsis
+	.s.nf
+	cpp [-options] [infile [outfile]]
+	.s.f
+description
+
+	CPP reads a C source file, expands macros and include
+	files, and writes an input file for the C compiler.
+	If no file arguments are given, CPP reads from stdin
+	and writes to stdout.  If one file argument is given,
+	it will define the input file, while two file arguments
+	define both input and output files.  The file name "-"
+	is a synonym for stdin or stdout as appropriate.
+
+	The following options are supported.  Options may
+	be given in either case.
+	.lm +16
+	.p -16
+	-C		If set, source-file comments are written
+	to the output file.  This allows the output of CPP to be
+	used as the input to a program, such as lint, that expects
+	commands embedded in specially-formatted comments.
+	.p -16
+	-Dname=value	Define the name as if the programmer wrote
+
+	    #define name value
+
+	at the start of the first file.  If "=value" is not
+	given, a value of "1" will be used.
+
+	On non-unix systems, all alphabetic text will be forced
+	to upper-case.
+	.p -16
+	-E		Always return "success" to the operating
+	system, even if errors were detected.  Note that some fatal
+	errors, such as a missing #include file, will terminate
+	CPP, returning "failure" even if the -E option is given.
+	.p -16
+	-Idirectory	Add this directory to the list of
+	directories searched for #include "..." and #include <...>
+	commands.  Note that there is no space between the
+	"-I" and the directory string.  More than one -I command
+	is permitted.  On non-Unix systems "directory" is forced
+	to upper-case.
+	.p -16
+	-N		CPP normally predefines some symbols defining
+	the target computer and operating system.  If -N is specified,
+	no symbols will be predefined.  If -N -N is specified, the
+	"always present" symbols, __LINE__, __FILE__, and __DATE__
+	are not defined.
+	.p -16
+	-Stext		CPP normally assumes that the size of
+	the target computer's basic variable types is the same as the size
+	of these types of the host computer.  (This can be overridden
+	when CPP is compiled, however.)  The -S option allows dynamic
+	respecification of these values.  "text" is a string of
+	numbers, separated by commas, that specifies correct sizes.
+	The sizes must be specified in the exact order:
+
+	    char short int long float double
+
+	If you specify the option as "-S*text", pointers to these
+	types will be specified.  -S* takes one additional argument
+	for pointer to function (e.g. int (*)())
+
+	For example, to specify sizes appropriate for a PDP-11,
+	you would write:
+
+	       c s i l f d func
+	     -S1,2,2,2,4,8,
+	    -S*2,2,2,2,2,2,2
+
+	Note that all values must be specified.
+	.p -16
+	-Uname		Undefine the name as if
+
+	    #undef name
+
+	were given.  On non-Unix systems, "name" will be forced to
+	upper-case.
+	.p -16
+	-Xnumber	Enable debugging code.  If no value is
+	given, a value of 1 will be used.  (For maintenence of
+	CPP only.)
+	.s.lm -16
+
+Pre-Defined Variables
+
+	When CPP begins processing, the following variables will
+	have been defined (unless the -N option is specified):
+	.s
+	Target computer (as appropriate):
+	.s
+	    pdp11, vax, M68000 m68000 m68k
+	.s
+	Target operating system (as appropriate):
+	.s
+	    rsx, rt11, vms, unix
+	.s
+	Target compiler (as appropriate):
+	.s
+	    decus, vax11c
+	.s
+	The implementor may add definitions to this list.
+	The default definitions match the definition of the
+	host computer, operating system, and C compiler.
+	.s
+	The following are always available unless undefined (or
+	-N was specified twice):
+	.lm +16
+	.p -12
+	__FILE__	The input (or #include) file being compiled
+	(as a quoted string).
+	.p -12
+	__LINE__	The line number being compiled.
+	.p -12
+	__DATE__	The date and time of compilation as
+	a Unix ctime quoted string (the trailing newline is removed).
+	Thus,
+	.s
+	    printf("Bug at line %s,", __LINE__);
+	    printf(" source file %s", __FILE__);
+	    printf(" compiled on %s", __DATE__);
+	.s.lm -16
+
+Draft Proposed Ansi Standard Considerations
+
+	The current version of the Draft Proposed Standard
+	explicitly states that "readers are requested not to specify
+	or claim conformance to this draft."  Readers and users
+	of Decus CPP should not assume that Decus CPP conforms
+	to the standard, or that it will conform to the actual
+	C Language Standard.
+
+	When CPP is itself compiled, many features of the Draft
+	Proposed Standard that are incompatible with existing
+	preprocessors may be disabled.  See the comments in CPP's
+	source for details.
+
+	The latest version of the Draft Proposed Standard (as reflected
+	in Decus CPP) is dated November 12, 1984.
+
+	Comments are removed from the input text.  The comment
+	is replaced by a single space character.  The -C option
+	preserves comments, writing them to the output file.
+
+	The '$' character is considered to be a letter.  This is
+	a permitted extension.
+
+	The following new features of C are processed by CPP:
+	.s.comment Note: significant spaces, not tabs, .br quotes #if, #elif
+	.br;####_#elif expression    (_#else _#if)
+	.br;####'_\xNNN'             (Hexadecimal constant)
+	.br;####'_\a'                (Ascii BELL)
+	.br;####'_\v'                (Ascii Vertical Tab)
+	.br;####_#if defined NAME    1 if defined, 0 if not
+	.br;####_#if defined (NAME)  1 if defined, 0 if not  
+	.br;####_#if sizeof (basic type)
+	.br;####unary +
+	.br;####123U, 123LU          Unsigned ints and longs.
+	.br;####12.3L                Long double numbers
+	.br;####token_#token         Token concatenation
+	.br;####_#include token      Expands to filename
+
+	The Draft Proposed Standard has extended C, adding a constant
+	string concatenation operator, where
+
+	    "foo" "bar"
+
+	is regarded as the single string "foobar".  (This does not
+	affect CPP's processing but does permit a limited form of
+	macro argument substitution into strings as will be discussed.)
+
+	The Standard Committee plans to add token concatenation
+	to #define command lines.  One suggested implementation
+	is as follows:  the sequence "Token1#Token2" is treated
+	as if the programmer wrote "Token1Token2".  This could
+	be used as follows:
+
+	    #line 123
+	    #define ATLINE foo#__LINE__
+
+	ATLINE would be defined as foo123.
+
+	Note that "Token2" must either have the format of an
+	identifier or be a string of digits.  Thus, the string
+
+	    #define ATLINE foo#1x3
+
+	generates two tokens: "foo1" and "x3".
+
+	If the tokens T1 and T2 are concatenated into T3,
+	this implementation operates as follows:
+
+	  1. Expand T1 if it is a macro.
+	  2. Expand T2 if it is a macro.
+	  3. Join the tokens, forming T3.
+	  4. Expand T3 if it is a macro.
+
+	A macro formal parameter will be substituted into a string
+	or character constant if it is the only component of that
+	constant:
+
+	    #define VECSIZE 123
+	    #define vprint(name, size) \
+	      printf("name" "[" "size" "] = {\n")
+	      ... vprint(vector, VECSIZE);
+
+	expands (effectively) to
+
+	      vprint("vector[123] = {\n");
+
+	Note that this will be useful if your C compiler supports
+	the new string concatenation operation noted above.
+	As implemented here, if you write
+
+	    #define string(arg) "arg"
+	      ... string("foo") ...
+
+	This implementation generates "foo", rather than the strictly
+	correct ""foo"" (which will probably generate an error message).
+	This is, strictly speaking, an error in CPP and may be removed
+	from future releases.
+
+error messages
+
+	Many.  CPP prints warning or error messages if you try to
+	use multiple-byte character constants (non-transportable)
+	if you #undef a symbol that was not defined, or if your
+	program has potentially nested comments.
+
+author
+
+	Martin Minow
+
+bugs
+
+	The #if expression processor uses signed integers only.
+	I.e, #if 0xFFFFu < 0 may be TRUE.
+
+#endif
+
+#include	<stdio.h>
+#include	<ctype.h>
+#include	"cppdef.h"
+#include	"cpp.h"
+
+/*
+ * Commonly used global variables:
+ * line		is the current input line number.
+ * wrongline	is set in many places when the actual output
+ *		line is out of sync with the numbering, e.g,
+ *		when expanding a macro with an embedded newline.
+ *
+ * tokenbuf	holds the last identifier scanned (which might
+ *		be a candidate for macro expansion).
+ * errors	is the running cpp error counter.
+ * infile	is the head of a linked list of input files (extended by
+ *		#include and macros being expanded).  infile always points
+ *		to the current file/macro.  infile->parent to the includer,
+ *		etc.  infile->fd is NULL if this input stream is a macro.
+ */
+int		line;			/* Current line number		*/
+int		wrongline;		/* Force #line to compiler	*/
+char		*tokenbuf;		/* Buffer for current input token */
+int		tokenbsize;		/* Allocated size of tokenbuf, */
+					/* not counting zero at end.  */
+int		errors;			/* cpp error counter		*/
+FILEINFO	*infile = NULL;		/* Current input file		*/
+#if DEBUG
+int		debug;			/* TRUE if debugging now	*/
+#endif
+/*
+ * This counter is incremented when a macro expansion is initiated.
+ * If it exceeds a built-in value, the expansion stops -- this tests
+ * for a runaway condition:
+ *	#define X Y
+ *	#define Y X
+ *	X
+ * This can be disabled by falsifying rec_recover.  (Nothing does this
+ * currently: it is a hook for an eventual invocation flag.)
+ */
+int		recursion;		/* Infinite recursion counter	*/
+int		rec_recover = TRUE;	/* Unwind recursive macros	*/
+
+/*
+ * instring is set TRUE when a string is scanned.  It modifies the
+ * behavior of the "get next character" routine, causing all characters
+ * to be passed to the caller (except <DEF_MAGIC>).  Note especially that
+ * comments and \<newline> are not removed from the source.  (This
+ * prevents cpp output lines from being arbitrarily long).
+ *
+ * inmacro is set by #define -- it absorbs comments and converts
+ * form-feed and vertical-tab to space, but returns \<newline>
+ * to the caller.  Strictly speaking, this is a bug as \<newline>
+ * shouldn't delimit tokens, but we'll worry about that some other
+ * time -- it is more important to prevent infinitly long output lines.
+ *
+ * instring and inmarcor are parameters to the get() routine which
+ * were made global for speed.
+ */
+int		instring = FALSE;	/* TRUE if scanning string	*/
+int		inmacro = FALSE;	/* TRUE if #defining a macro	*/
+
+/*
+ * work[] and workp are used to store one piece of text in a temporay
+ * buffer.  To initialize storage, set workp = work.  To store one
+ * character, call save(c);  (This will fatally exit if there isn't
+ * room.)  To terminate the string, call save(EOS).  Note that
+ * the work buffer is used by several subroutines -- be sure your
+ * data won't be overwritten.  The extra byte in the allocation is
+ * needed for string formal replacement.
+ */
+char		work[NWORK + 1];	/* Work buffer			*/
+char		*workp;			/* Work buffer pointer		*/
+
+/*
+ * keepcomments is set TRUE by the -C option.  If TRUE, comments
+ * are written directly to the output stream.  This is needed if
+ * the output from cpp is to be passed to lint (which uses commands
+ * embedded in comments).  cflag contains the permanent state of the
+ * -C flag.  keepcomments is always falsified when processing #control
+ * commands and when compilation is supressed by a false #if
+ *
+ * If eflag is set, CPP returns "success" even if non-fatal errors
+ * were detected.
+ *
+ * If nflag is non-zero, no symbols are predefined except __LINE__.
+ * __FILE__, and __DATE__.  If nflag > 1, absolutely no symbols
+ * are predefined.
+ */
+int		keepcomments = FALSE;	/* Write out comments flag	*/
+int		cflag = FALSE;		/* -C option (keep comments)	*/
+int		eflag = FALSE;		/* -E option (never fail)	*/
+int		nflag = 0;		/* -N option (no predefines)	*/
+
+/*
+ * ifstack[] holds information about nested #if's.  It is always
+ * accessed via *ifptr.  The information is as follows:
+ *	WAS_COMPILING	state of compiling flag at outer level.
+ *	ELSE_SEEN	set TRUE when #else seen to prevent 2nd #else.
+ *	TRUE_SEEN	set TRUE when #if or #elif succeeds
+ * ifstack[0] holds the compiling flag.  It is TRUE if compilation
+ * is currently enabled.  Note that this must be initialized TRUE.
+ */
+char		ifstack[BLK_NEST] = { TRUE };	/* #if information	*/
+char		*ifptr = ifstack;		/* -> current ifstack[] */
+
+/*
+ * incdir[] stores the -i directories (and the system-specific
+ * #include <...> directories.
+ */
+char	*incdir[NINCLUDE];		/* -i directories		*/
+char	**incend = incdir;		/* -> free space in incdir[]	*/
+
+/*
+ * This is the table used to predefine target machine and operating
+ * system designators.  It may need hacking for specific circumstances.
+ * Note: it is not clear that this is part of the Ansi Standard.
+ * The -N option supresses preset definitions.
+ */
+char	*preset[] = {			/* names defined at cpp start	*/
+#ifdef	MACHINE
+	MACHINE,
+#endif
+#ifdef	SYSTEM
+	SYSTEM,
+#endif
+#ifdef	COMPILER
+	COMPILER,
+#endif
+#if	DEBUG
+	"decus_cpp",			/* Ourselves!			*/
+#endif
+	NULL				/* Must be last			*/
+};
+
+/*
+ * The value of these predefined symbols must be recomputed whenever
+ * they are evaluated.  The order must not be changed.
+ */
+char	*magic[] = {			/* Note: order is important	*/
+	"__LINE__",
+	"__FILE__",
+	NULL				/* Must be last			*/
+};
+
+main(argc, argv)
+int		argc;
+char		*argv[];
+{
+	register int	i;
+
+#if HOST == SYS_VMS
+	argc = getredirection(argc, argv);	/* vms >file and <file	*/
+#endif
+	initdefines();				/* O.S. specific def's	*/
+	i = dooptions(argc, argv);		/* Command line -flags	*/
+	switch (i) {
+	case 3:
+	    /*
+	     * Get output file, "-" means use stdout.
+	     */
+	    if (!streq(argv[2], "-")) {
+#if HOST == SYS_VMS
+		/*
+		 * On vms, reopen stdout with "vanilla rms" attributes.
+		 */
+		if ((i = creat(argv[2], 0, "rat=cr", "rfm=var")) == -1
+		 || dup2(i, fileno(stdout)) == -1) {
+#else
+		if (freopen(argv[2], "w", stdout) == NULL) {
+#endif
+		    perror(argv[2]);
+		    cerror("Can't open output file \"%s\"", argv[2]);
+		    exit(IO_ERROR);
+		}
+	    }				/* Continue by opening input	*/
+	case 2:				/* One file -> stdin		*/
+	    /*
+	     * Open input file, "-" means use stdin.
+	     */
+	    if (!streq(argv[1], "-")) {
+		if (freopen(argv[1], "r", stdin) == NULL) {
+		    perror(argv[1]);
+		    cerror("Can't open input file \"%s\"", argv[1]);
+		    exit(IO_ERROR);
+		}
+		strcpy(work, argv[1]);	/* Remember input filename	*/
+		break;
+	    }				/* Else, just get stdin		*/
+	case 0:				/* No args?			*/
+	case 1:				/* No files, stdin -> stdout	*/
+#if HOST == SYS_UNIX
+	    work[0] = EOS;		/* Unix can't find stdin name	*/
+#else
+	    fgetname(stdin, work);	/* Vax-11C, Decus C know name	*/
+#endif
+	    break;
+
+	default:
+	    exit(IO_ERROR);		/* Can't happen			*/
+	}
+	setincdirs();			/* Setup -I include directories	*/
+	addfile(stdin, work);		/* "open" main input file	*/
+#if DEBUG
+	if (debug > 0)
+	    dumpdef("preset #define symbols");
+#endif
+	cppmain();			/* Process main file		*/
+	if ((i = (ifptr - &ifstack[0])) != 0) {
+#if OLD_PREPROCESSOR
+	    ciwarn("Inside #ifdef block at end of input, depth = %d", i);
+#else
+	    cierror("Inside #ifdef block at end of input, depth = %d", i);
+#endif
+	}
+	fclose(stdout);
+	if (errors > 0 && !eflag)
+	  exit(IO_ERROR);
+	exit(IO_NORMAL);		/* No errors or -E option set	*/
+}
+
+FILE_LOCAL
+cppmain()
+/*
+ * Main process for cpp -- copies tokens from the current input
+ * stream (main file, include file, or a macro) to the output
+ * file.
+ */
+{
+	register int		c;		/* Current character	*/
+	register int		counter;	/* newlines and spaces	*/
+	extern int		output();	/* Output one character	*/
+
+	/* Initialize for reading tokens */
+	tokenbsize = 50;
+	tokenbuf = getmem (tokenbsize + 1);
+
+	/*
+	 * Explicitly output a #line at the start of cpp output so
+	 * that lint (etc.) knows the name of the original source
+	 * file.  If we don't do this explicitly, we may get
+	 * the name of the first #include file instead.
+	 */
+	sharp();
+	/*
+	 * This loop is started "from the top" at the beginning of each line
+	 * wrongline is set TRUE in many places if it is necessary to write
+	 * a #line record.  (But we don't write them when expanding macros.)
+	 *
+	 * The counter variable has two different uses:  at
+	 * the start of a line, it counts the number of blank lines that
+	 * have been skipped over.  These are then either output via
+	 * #line records or by outputting explicit blank lines.
+ 	 * When expanding tokens within a line, the counter remembers
+	 * whether a blank/tab has been output.  These are dropped
+	 * at the end of the line, and replaced by a single blank
+	 * within lines.
+	 */
+	for (;;) {
+	    counter = 0;			/* Count empty lines	*/
+	    for (;;) {				/* For each line, ...	*/
+		while (type[(c = get())] == SPA) /* Skip leading blanks	*/
+		    ;				/* in this line.	*/
+		if (c == '\n')			/* If line's all blank,	*/
+		    ++counter;			/* Do nothing now	*/
+		else if (c == '#') {		/* Is 1st non-space '#'	*/
+		    keepcomments = FALSE;	/* Don't pass comments	*/
+		    counter = control(counter);	/* Yes, do a #command	*/
+		    keepcomments = (cflag && compiling);
+		}
+		else if (c == EOF_CHAR)		/* At end of file?	*/
+		    break;
+		else if (!compiling) {		/* #ifdef false?	*/
+		    skipnl();			/* Skip to newline	*/
+		    counter++;			/* Count it, too.	*/
+		}
+		else {
+		    break;			/* Actual token		*/
+		}
+	    }
+	    if (c == EOF_CHAR)			/* Exit process at	*/
+		break;				/* End of file		*/
+	    /*
+	     * If the loop didn't terminate because of end of file, we
+	     * know there is a token to compile.  First, clean up after
+	     * absorbing newlines.  counter has the number we skipped.
+	     */
+	    if ((wrongline && infile->fp != NULL) || counter > 4)
+		sharp();			/* Output # line number	*/
+	    else {				/* If just a few, stuff	*/
+		while (--counter >= 0)		/* them out ourselves	*/
+		    putchar('\n');
+	    }
+	    /*
+	     * Process each token on this line.
+	     */
+	    unget();				/* Reread the char.	*/
+	    for (;;) {				/* For the whole line,	*/
+		do {				/* Token concat. loop	*/
+		    for (counter = 0; (type[(c = get())] == SPA);) {
+#if COMMENT_INVISIBLE
+			if (c != COM_SEP)
+			    counter++;
+#else
+			counter++;		/* Skip over blanks	*/
+#endif
+		    }
+		    if (c == EOF_CHAR || c == '\n')
+			goto end_line;		/* Exit line loop	*/
+		    else if (counter > 0)	/* If we got any spaces	*/
+			putchar(' ');		/* Output one space	*/
+		    c = macroid(c);		/* Grab the token	*/
+		} while (type[c] == LET && catenate());
+		if (c == EOF_CHAR || c == '\n')	/* From macro exp error	*/
+		    goto end_line;		/* Exit line loop	*/
+		switch (type[c]) {
+		case LET:
+		    fputs(tokenbuf, stdout);	/* Quite ordinary token	*/
+		    break;
+
+
+		case DIG:			/* Output a number	*/
+		case DOT:			/* Dot may begin floats	*/
+		    scannumber(c, output);
+		    break;
+
+		case QUO:			/* char or string const	*/
+		    scanstring(c, output);	/* Copy it to output	*/
+		    break;
+
+		default:			/* Some other character	*/
+		    cput(c);			/* Just output it	*/
+		    break;
+		}				/* Switch ends		*/
+	    }					/* Line for loop	*/
+end_line:   if (c == '\n') {			/* Compiling at EOL?	*/
+		putchar('\n');			/* Output newline, if	*/
+		if (infile->fp == NULL)		/* Expanding a macro,	*/
+		    wrongline = TRUE;		/* Output # line later	*/
+	    }
+	}					/* Continue until EOF	*/
+}
+
+output(c)
+int		c;
+/*
+ * Output one character to stdout -- output() is passed as an
+ * argument to scanstring()
+ */
+{
+#if COMMENT_INVISIBLE
+	if (c != TOK_SEP && c != COM_SEP)
+#else
+	if (c != TOK_SEP)
+#endif
+	    putchar(c);
+}
+
+static char	*sharpfilename = NULL;
+
+FILE_LOCAL
+sharp()
+/*
+ * Output a line number line.
+ */
+{
+	register char		*name;
+
+	if (keepcomments)			/* Make sure # comes on	*/
+	    putchar('\n');			/* a fresh, new line.	*/
+	printf("#%s %d", LINE_PREFIX, line);
+	if (infile->fp != NULL) {
+	    name = (infile->progname != NULL)
+		? infile->progname : infile->filename;
+	    if (sharpfilename == NULL
+	     || sharpfilename != NULL && !streq(name, sharpfilename)) {
+		if (sharpfilename != NULL)
+		    free(sharpfilename);
+		sharpfilename = savestring(name);
+		printf(" \"%s\"", name);
+	     }
+	}
+	putchar('\n');
+	wrongline = FALSE;
+}
diff --git a/cpp/cpp2.c b/cpp/cpp2.c
new file mode 100644
index 0000000..3f74ec8
--- /dev/null
+++ b/cpp/cpp2.c
@@ -0,0 +1,584 @@
+/*
+ *				C P P 2 . C
+ *
+ *			   Process #control lines
+ *
+ * Edit history
+ * 13-Nov-84	MM	Split from cpp1.c
+ * 21-Oct-85	RMS	Do not turn on `instring' while reading #include arg.
+ *			Rename `token' to `tokenbuf'.
+ *			Flush tabs at end of #include line, like spaces.
+ */
+
+#include	<stdio.h>
+#include	<ctype.h>
+#include	"cppdef.h"
+#include	"cpp.h"
+#if HOST == SYS_VMS
+/*
+ * Include the rms stuff.  (We can't just include rms.h as it uses the
+ * VaxC-specific library include syntax that Decus CPP doesn't support.
+ * By including things by hand, we can CPP ourself.)
+ */
+#include	<nam.h>
+#include	<fab.h>
+#include	<rab.h>
+#include	<rmsdef.h>
+#endif
+
+/*
+ * Generate (by hand-inspection) a set of unique values for each control
+ * operator.  Note that this is not guaranteed to work for non-Ascii
+ * machines.  CPP won't compile if there are hash conflicts.
+ */
+
+#define	L_assert	('a' + ('s' << 1))
+#define	L_define	('d' + ('f' << 1))
+#define	L_elif		('e' + ('i' << 1))
+#define	L_else		('e' + ('s' << 1))
+#define	L_endif		('e' + ('d' << 1))
+#define	L_if		('i' + (EOS << 1))
+#define	L_ifdef		('i' + ('d' << 1))
+#define	L_ifndef	('i' + ('n' << 1))
+#define	L_include	('i' + ('c' << 1))
+#define	L_line		('l' + ('n' << 1))
+#define	L_nogood	(EOS + (EOS << 1))	/* To catch #i		*/
+#define	L_pragma	('p' + ('a' << 1))
+#define L_undef		('u' + ('d' << 1))
+#if DEBUG
+#define	L_debug		('d' + ('b' << 1))	/* #debug		*/
+#define	L_nodebug	('n' + ('d' << 1))	/* #nodebug		*/
+#endif
+
+int
+control(counter)
+int		counter;	/* Pending newline counter		*/
+/*
+ * Process #control lines.  Simple commands are processed inline,
+ * while complex commands have their own subroutines.
+ *
+ * The counter is used to force out a newline before #line, and
+ * #pragma commands.  This prevents these commands from ending up at
+ * the end of the previous line if cpp is invoked with the -C option.
+ */
+{
+	register int		c;
+	register char		*tp;
+	register int		hash;
+	char			*ep;
+
+	c = skipws();
+	if (c == '\n' || c == EOF_CHAR)
+	    return (counter + 1);
+	if (!isdigit(c))
+	    scanid(c);			/* Get #word to tokenbuf	*/
+	else {
+	    unget();			/* Hack -- allow #123 as a	*/
+	    strcpy(tokenbuf, "line");	/* synonym for #line 123	*/
+	}
+	hash = (tokenbuf[1] == EOS) ? L_nogood : (tokenbuf[0] + (tokenbuf[2] << 1));
+	switch (hash) {
+	case L_assert:	tp = "assert";		break;
+	case L_define:	tp = "define";		break;
+	case L_elif:	tp = "elif";		break;
+	case L_else:	tp = "else";		break;
+	case L_endif:	tp = "endif";		break;
+	case L_if:	tp = "if";		break;
+	case L_ifdef:	tp = "ifdef";		break;
+	case L_ifndef:	tp = "ifndef";		break;
+	case L_include:	tp = "include";		break;
+	case L_line:	tp = "line";		break;
+	case L_pragma:	tp = "pragma";		break;
+	case L_undef:	tp = "undef";		break;
+#if DEBUG
+	case L_debug:	tp = "debug";		break;
+	case L_nodebug:	tp = "nodebug";		break;
+#endif
+	default:	hash = L_nogood;
+	case L_nogood:	tp = "";		break;
+	}
+	if (!streq(tp, tokenbuf))
+	    hash = L_nogood;
+	/*
+	 * hash is set to a unique value corresponding to the
+	 * control keyword (or L_nogood if we think it's nonsense).
+	 */
+	if (infile->fp == NULL)
+	    cwarn("Control line \"%s\" within macro expansion", tokenbuf);
+	if (!compiling) {			/* Not compiling now	*/
+	    switch (hash) {
+	    case L_if:				/* These can't turn	*/
+	    case L_ifdef:			/*  compilation on, but	*/
+	    case L_ifndef:			/*   we must nest #if's	*/
+		if (++ifptr >= &ifstack[BLK_NEST])
+		    goto if_nest_err;
+		*ifptr = 0;			/* !WAS_COMPILING	*/
+	    case L_line:			/* Many			*/
+	    /*
+	     * Are pragma's always processed?
+	     */
+	    case L_pragma:			/*  options		*/
+	    case L_include:			/*   are uninteresting	*/
+	    case L_define:			/*    if we		*/
+	    case L_undef:			/*     aren't		*/
+	    case L_assert:			/*      compiling.	*/
+dump_line:	skipnl();			/* Ignore rest of line	*/
+		return (counter + 1);
+	    }
+	}
+	/*
+	 * Make sure that #line and #pragma are output on a fresh line.
+	 */
+	if (counter > 0 && (hash == L_line || hash == L_pragma)) {
+	    putchar('\n');
+	    counter--;
+	}
+	switch (hash) {
+	case L_line:
+	    /*
+	     * Parse the line to update the line number and "progname"
+	     * field and line number for the next input line.
+	     * Set wrongline to force it out later.
+	     */
+	    c = skipws();
+	    workp = work;			/* Save name in work	*/
+	    while (c != '\n' && c != EOF_CHAR) {
+		save(c);
+		c = get();
+	    }
+	    unget();
+	    save(EOS);
+	    /*
+	     * Split #line argument into <line-number> and <name>
+	     * We subtract 1 as we want the number of the next line.
+	     */
+	    line = atoi(work) - 1;		/* Reset line number	*/
+	    for (tp = work; isdigit(*tp) || type[*tp] == SPA; tp++)
+		;				/* Skip over digits	*/
+	    if (*tp != EOS) {			/* Got a filename, so:	*/
+		if (*tp == '"' && (ep = strrchr(tp + 1, '"')) != NULL) {
+		    tp++;			/* Skip over left quote	*/
+		    *ep = EOS;			/* And ignore right one	*/
+		}
+		if (infile->progname != NULL)	/* Give up the old name	*/
+		    free(infile->progname);	/* if it's allocated.	*/
+	        infile->progname = savestring(tp);
+	    }
+	    wrongline = TRUE;			/* Force output later	*/
+	    break;
+
+	case L_include:
+	    doinclude();
+	    break;
+
+	case L_define:
+	    dodefine();
+	    break;
+
+	case L_undef:
+	    doundef();
+	    break;
+
+	case L_else:
+	    if (ifptr == &ifstack[0])
+		goto nest_err;
+	    else if ((*ifptr & ELSE_SEEN) != 0)
+		goto else_seen_err;
+	    *ifptr |= ELSE_SEEN;
+	    if ((*ifptr & WAS_COMPILING) != 0) {
+		if (compiling || (*ifptr & TRUE_SEEN) != 0)
+		    compiling = FALSE;
+		else {
+		    compiling = TRUE;
+		}
+	    }
+	    break;
+
+	case L_elif:
+	    if (ifptr == &ifstack[0])
+		goto nest_err;
+	    else if ((*ifptr & ELSE_SEEN) != 0) {
+else_seen_err:	cerror("#%s may not follow #else", tokenbuf);
+		goto dump_line;
+	    }
+	    if ((*ifptr & (WAS_COMPILING | TRUE_SEEN)) != WAS_COMPILING) {
+		compiling = FALSE;		/* Done compiling stuff	*/
+		goto dump_line;			/* Skip this clause	*/
+	    }
+	    doif(L_if);
+	    break;
+
+	case L_if:
+	case L_ifdef:
+	case L_ifndef:
+	    if (++ifptr >= &ifstack[BLK_NEST])
+if_nest_err:	cfatal("Too many nested #%s statements", tokenbuf);
+	    *ifptr = WAS_COMPILING;
+	    doif(hash);
+	    break;
+
+	case L_endif:
+	    if (ifptr == &ifstack[0]) {
+nest_err:	cerror("#%s must be in an #if", tokenbuf);
+		goto dump_line;
+	    }
+	    if (!compiling && (*ifptr & WAS_COMPILING) != 0)
+		wrongline = TRUE;
+	    compiling = ((*ifptr & WAS_COMPILING) != 0);
+	    --ifptr;
+	    break;
+
+	case L_assert:
+	    if (eval() == 0)
+		cerror("Preprocessor assertion failure", NULLST);
+	    break;
+
+	case L_pragma:
+	    /*
+	     * #pragma is provided to pass "options" to later
+	     * passes of the compiler.  cpp doesn't have any yet.
+	     */
+	    printf("#pragma ");
+	    while ((c = get()) != '\n' && c != EOF_CHAR)
+		cput(c);
+	    unget();
+	    break;
+ 
+#if DEBUG
+	case L_debug:
+	    if (debug == 0)
+		dumpdef("debug set on");
+	    debug++;
+	    break;
+
+	case L_nodebug:
+	    debug--;
+	    break;
+#endif
+
+	default:
+	    /*
+	     * Undefined #control keyword.
+	     * Note: the correct behavior may be to warn and
+	     * pass the line to a subsequent compiler pass.
+	     * This would allow #asm or similar extensions.
+	     */
+	    cerror("Illegal # command \"%s\"", tokenbuf);
+	    break;
+	}
+	if (hash != L_include) {
+#if OLD_PREPROCESSOR
+	    /*
+	     * Ignore the rest of the #control line so you can write
+	     *		#if	foo
+	     *		#endif	foo
+	     */
+	    goto dump_line;			/* Take common exit	*/
+#else
+	    if (skipws() != '\n') {
+		cwarn("Unexpected text in #control line ignored", NULLST);
+		skipnl();
+	    }
+#endif
+	}
+	return (counter + 1);
+}
+
+FILE_LOCAL
+doif(hash)
+int		hash;
+/*
+ * Process an #if, #ifdef, or #ifndef.  The latter two are straightforward,
+ * while #if needs a subroutine of its own to evaluate the expression.
+ *
+ * doif() is called only if compiling is TRUE.  If false, compilation
+ * is always supressed, so we don't need to evaluate anything.  This
+ * supresses unnecessary warnings.
+ */
+{
+	register int		c;
+	register int		found;
+
+	if ((c = skipws()) == '\n' || c == EOF_CHAR) {
+	    unget();
+	    goto badif;
+	}
+	if (hash == L_if) {
+	    unget();
+	    found = (eval() != 0);	/* Evaluate expr, != 0 is  TRUE	*/
+	    hash = L_ifdef;		/* #if is now like #ifdef	*/
+	}
+	else {
+	    if (type[c] != LET)		/* Next non-blank isn't letter	*/
+		goto badif;		/* ... is an error		*/
+	    found = (lookid(c) != NULL); /* Look for it in symbol table	*/
+	}
+	if (found == (hash == L_ifdef)) {
+	    compiling = TRUE;
+	    *ifptr |= TRUE_SEEN;
+	}
+	else {
+	    compiling = FALSE;
+	}
+	return;
+
+badif:	cerror("#if, #ifdef, or #ifndef without an argument", NULLST);
+#if !OLD_PREPROCESSOR
+	skipnl();				/* Prevent an extra	*/
+	unget();				/* Error message	*/
+#endif
+	return;
+}
+
+FILE_LOCAL
+doinclude()
+/*
+ * Process the #include control line.
+ * There are three variations:
+ *	#include "file"		search somewhere relative to the
+ *				current source file, if not found,
+ *				treat as #include <file>.
+ *	#include <file>		Search in an implementation-dependent
+ *				list of places.
+ *	#include token		Expand the token, it must be one of
+ *				"file" or <file>, process as such.
+ *
+ * Note: the November 12 draft forbids '>' in the #include <file> format.
+ * This restriction is unnecessary and not implemented.
+ */
+{
+	register int		c;
+	register int		delim;
+#if HOST == SYS_VMS
+	char			def_filename[NAM$C_MAXRSS + 1];
+#endif
+
+	delim = macroid(skipws());
+	if (delim != '<' && delim != '"')
+	    goto incerr;
+	if (delim == '<')
+	    delim = '>';
+	workp = work;
+	while ((c = get()) != '\n' && c != EOF_CHAR)
+	    save(c);			/* Put it away.			*/
+	unget();			/* Force nl after includee	*/
+	/*
+	 * The draft is unclear if the following should be done.
+	 */
+	while (--workp >= work && (*workp == ' ' || *workp == '\t'))
+	    ;				/* Trim blanks from filename	*/
+	if (*workp != delim)
+	    goto incerr;
+	*workp = EOS;			/* Terminate filename		*/
+#if HOST == SYS_VMS
+	/*
+	 * Assume the default .h filetype.
+	 */
+	if (!vmsparse(work, ".H", def_filename)) {
+	    perror(work);		/* Oops.			*/
+	    goto incerr;
+	}
+	else if (openinclude(def_filename, (delim == '"')))
+	    return;
+#else
+	if (openinclude(work, (delim == '"')))
+	    return;
+#endif
+	/*
+	 * No sense continuing if #include file isn't there.
+	 */
+	cfatal("Cannot open include file \"%s\"", work);
+
+incerr:	cerror("#include syntax error", NULLST);
+	return;
+}
+
+FILE_LOCAL int
+openinclude(filename, searchlocal)
+char		*filename;		/* Input file name		*/
+int		searchlocal;		/* TRUE if #include "file"	*/
+/*
+ * Actually open an include file.  This routine is only called from
+ * doinclude() above, but was written as a separate subroutine for
+ * programmer convenience.  It searches the list of directories
+ * and actually opens the file, linking it into the list of
+ * active files.  Returns TRUE if the file was opened, FALSE
+ * if openinclude() fails.  No error message is printed.
+ */
+{
+	register char		**incptr;
+#if HOST == SYS_VMS
+#if NWORK < (NAM$C_MAXRSS + 1)
+    << error, NWORK isn't greater than NAM$C_MAXRSS >>
+#endif
+#endif
+	char			tmpname[NWORK];	/* Filename work area	*/
+
+	if (searchlocal) {
+	    /*
+	     * Look in local directory first
+	     */
+#if HOST == SYS_UNIX
+	    /*
+	     * Try to open filename relative to the directory of the current
+	     * source file (as opposed to the current directory). (ARF, SCK).
+	     */
+	    if (filename[0] != '/'
+	     && hasdirectory(infile->filename, tmpname))
+		strcat(tmpname, filename);
+	    else {
+		strcpy(tmpname, filename);
+	    }
+#else
+	    if (!hasdirectory(filename, tmpname)
+	     && hasdirectory(infile->filename, tmpname))
+		strcat(tmpname, filename);
+	    else {
+		strcpy(tmpname, filename);
+	    }
+#endif
+	    if (openfile(tmpname))
+		return (TRUE);
+	}
+	/*
+	 * Look in any directories specified by -I command line
+	 * arguments, then in the builtin search list.
+	 */
+	for (incptr = incdir; incptr < incend; incptr++) {
+	    if (strlen(*incptr) + strlen(filename) >= (NWORK - 1))
+		cfatal("Filename work buffer overflow", NULLST);
+	    else {
+#if HOST == SYS_UNIX
+		if (filename[0] == '/')
+		    strcpy(tmpname, filename);
+		else {
+		    sprintf(tmpname, "%s/%s", *incptr, filename);
+		}
+#else
+		if (!hasdirectory(filename, tmpname))
+		    sprintf(tmpname, "%s%s", *incptr, filename);
+#endif
+		if (openfile(tmpname))
+		    return (TRUE);
+	    }
+	}
+	return (FALSE);
+}
+
+FILE_LOCAL int
+hasdirectory(source, result)
+char		*source;	/* Directory to examine			*/
+char		*result;	/* Put directory stuff here		*/
+/*
+ * If a device or directory is found in the source filename string, the
+ * node/device/directory part of the string is copied to result and
+ * hasdirectory returns TRUE.  Else, nothing is copied and it returns FALSE.
+ */
+{
+#if HOST == SYS_UNIX
+	register char		*tp;
+
+	if ((tp = strrchr(source, '/')) == NULL)
+	    return (FALSE);
+	else {
+	    strncpy(result, source, tp - source + 1);
+	    result[tp - source + 1] = EOS;
+	    return (TRUE);
+	}
+#else
+#if HOST == SYS_VMS
+	if (vmsparse(source, NULLST, result)
+	 && result[0] != EOS)
+	    return (TRUE);
+	else {
+	    return (FALSE);
+	}
+#else
+	/*
+	 * Random DEC operating system (RSX, RT11, RSTS/E)
+	 */
+	register char		*tp;
+
+	if ((tp = strrchr(source, ']')) == NULL
+	 && (tp = strrchr(source, ':')) == NULL)
+	    return (FALSE);
+	else {
+	    strncpy(result, source, tp - source + 1);
+	    result[tp - source + 1] = EOS;
+	    return (TRUE);
+	}
+#endif
+#endif
+}
+
+#if HOST == SYS_VMS
+
+/*
+ * EXP_DEV is set if a device was specified, EXP_DIR if a directory
+ * is specified.  (Both set indicate a file-logical, but EXP_DEV
+ * would be set by itself if you are reading, say, SYS$INPUT:)
+ */
+#define DEVDIR (NAM$M_EXP_DEV | NAM$M_EXP_DIR)
+
+FILE_LOCAL int
+vmsparse(source, defstring, result)
+char		*source;
+char		*defstring;	/* non-NULL -> default string.		*/
+char		*result;	/* Size is at least NAM$C_MAXRSS + 1	*/
+/*
+ * Parse the source string, applying the default (properly, using
+ * the system parse routine), storing it in result.
+ * TRUE if it parsed, FALSE on error.
+ *
+ * If defstring is NULL, there are no defaults and result gets
+ * (just) the node::[directory] part of the string (possibly "")
+ */
+{
+	struct FAB	fab = cc$rms_fab;	/* File access block	*/
+	struct NAM	nam = cc$rms_nam;	/* File name block	*/
+	char		fullname[NAM$C_MAXRSS + 1];
+	register char	*rp;			/* Result pointer	*/
+
+	fab.fab$l_nam = &nam;			/* fab -> nam		*/
+	fab.fab$l_fna = source;			/* Source filename	*/
+	fab.fab$b_fns = strlen(source);		/* Size of source	*/
+	fab.fab$l_dna = defstring;		/* Default string	*/
+	if (defstring != NULLST)
+	    fab.fab$b_dns = strlen(defstring);	/* Size of default	*/
+	nam.nam$l_esa = fullname;		/* Expanded filename	*/
+	nam.nam$b_ess = NAM$C_MAXRSS;		/* Expanded name size	*/
+	if (sys$parse(&fab) == RMS$_NORMAL) {	/* Parse away		*/
+	    fullname[nam.nam$b_esl] = EOS;	/* Terminate string	*/
+	    result[0] = EOS;			/* Just in case		*/
+	    rp = &result[0];
+	    /*
+	     * Remove stuff added implicitly, accepting node names and
+	     * dev:[directory] strings (but not process-permanent files).
+	     */
+	    if ((nam.nam$l_fnb & NAM$M_PPF) == 0) {
+		if ((nam.nam$l_fnb & NAM$M_NODE) != 0) {
+		    strncpy(result, nam.nam$l_node, nam.nam$b_node);
+		    rp += nam.nam$b_node;
+		    *rp = EOS;
+		}
+		if ((nam.nam$l_fnb & DEVDIR) == DEVDIR) {
+		    strncpy(rp, nam.nam$l_dev, nam.nam$b_dev + nam.nam$b_dir);
+		    rp += nam.nam$b_dev + nam.nam$b_dir;
+		    *rp = EOS;
+		}
+	    }
+	    if (defstring != NULLST) {
+		strncpy(rp, nam.nam$l_name, nam.nam$b_name + nam.nam$b_type);
+		rp += nam.nam$b_name + nam.nam$b_type;
+		*rp = EOS;
+		if ((nam.nam$l_fnb & NAM$M_EXP_VER) != 0) {
+		    strncpy(rp, nam.nam$l_ver, nam.nam$b_ver);
+		    rp[nam.nam$b_ver] = EOS;
+		}
+	    }
+	    return (TRUE);
+	}
+	return (FALSE);
+}
+#endif
+
diff --git a/cpp/cpp3.c b/cpp/cpp3.c
new file mode 100644
index 0000000..3d976e9
--- /dev/null
+++ b/cpp/cpp3.c
@@ -0,0 +1,437 @@
+/*
+ *				C P P 3 . C
+ *
+ *		    File open and command line options
+ *
+ * Edit history
+ * 13-Nov-84	MM	Split from cpp1.c
+ * 21-Oct-85	rms	Make -g command arg not cause an error.
+ */
+
+#include	<stdio.h>
+#include	<ctype.h>
+#include	"cppdef.h"
+#include	"cpp.h"
+#if DEBUG && (HOST == SYS_VMS || HOST == SYS_UNIX)
+#include	<signal.h>
+extern int	abort();		/* For debugging		*/
+#endif
+
+int
+openfile(filename)
+char		*filename;
+/*
+ * Open a file, add it to the linked list of open files.
+ * This is called only from openfile() above.
+ */
+{
+	register FILE		*fp;
+
+	if ((fp = fopen(filename, "r")) == NULL) {
+#if DEBUG
+	    perror(filename);
+#endif
+	    return (FALSE);
+	}
+#if DEBUG
+	if (debug)
+	    fprintf(stderr, "Reading from \"%s\"\n", filename);
+#endif
+	addfile(fp, filename);
+	return (TRUE);
+}
+
+addfile(fp, filename)
+FILE		*fp;			/* Open file pointer		*/
+char		*filename;		/* Name of the file		*/
+/*
+ * Initialize tables for this open file.  This is called from openfile()
+ * above (for #include files), and from the entry to cpp to open the main
+ * input file.  It calls a common routine, getfile() to build the FILEINFO
+ * structure which is used to read characters.  (getfile() is also called
+ * to setup a macro replacement.)
+ */
+{
+	register FILEINFO	*file;
+	extern FILEINFO		*getfile();
+
+	file = getfile(NBUFF, filename);
+	file->fp = fp;			/* Better remember FILE *	*/
+	file->buffer[0] = EOS;		/* Initialize for first read	*/
+	line = 1;			/* Working on line 1 now	*/
+	wrongline = TRUE;		/* Force out initial #line	*/
+}
+
+setincdirs()
+/*
+ * Append system-specific directories to the include directory list.
+ * Called only when cpp is started.
+ */
+{
+
+#ifdef	CPP_INCLUDE
+	*incend++ = CPP_INCLUDE;
+#define	IS_INCLUDE	1
+#else
+#define	IS_INCLUDE	0
+#endif
+
+#if HOST == SYS_UNIX
+	*incend++ = "/usr/include";
+#define	MAXINCLUDE	(NINCLUDE - 1 - IS_INCLUDE)
+#endif
+
+#if HOST == SYS_VMS
+	extern char	*getenv();
+
+	if (getenv("C$LIBRARY") != NULL)
+	    *incend++ = "C$LIBRARY:";
+	*incend++ = "SYS$LIBRARY:";
+#define	MAXINCLUDE	(NINCLUDE - 2 - IS_INCLUDE)
+#endif
+
+#if HOST == SYS_RSX
+	extern int	$$rsts;			/* TRUE on RSTS/E	*/
+	extern int	$$pos;			/* TRUE on PRO-350 P/OS	*/
+	extern int	$$vms;			/* TRUE on VMS compat.	*/
+
+	if ($$pos) {				/* P/OS?		*/
+	    *incend++ = "SY:[ZZDECUSC]";	/* C #includes		*/
+	    *incend++ = "LB:[1,5]";		/* RSX library		*/
+	}
+	else if ($$rsts) {			/* RSTS/E?		*/
+	    *incend++ = "SY:@";			/* User-defined account	*/
+	    *incend++ = "C:";			/* Decus-C library	*/
+	    *incend++ = "LB:[1,1]";		/* RSX library		*/
+	}
+	else if ($$vms) {			/* VMS compatibility?	*/
+	    *incend++ = "C:";
+	}
+	else {					/* Plain old RSX/IAS	*/
+	    *incend++ = "LB:[1,1]";
+	}
+#define	MAXINCLUDE	(NINCLUDE - 3 - IS_INCLUDE)
+#endif
+
+#if HOST == SYS_RT11
+	extern int	$$rsts;			/* RSTS/E emulation?	*/
+
+	if ($$rsts)
+	    *incend++ = "SY:@";			/* User-defined account	*/
+	*incend++ = "C:";			/* Decus-C library disk	*/
+	*incend++ = "SY:";			/* System (boot) disk	*/
+#define	MAXINCLUDE	(NINCLUDE - 3 - IS_INCLUDE)
+#endif
+}
+
+int
+dooptions(argc, argv)
+int		argc;
+char		*argv[];
+/*
+ * dooptions is called to process command line arguments (-Detc).
+ * It is called only at cpp startup.
+ */
+{
+	register char		*ap;
+	register DEFBUF		*dp;
+	register int		c;
+	int			i, j;
+	char			*arg;
+	SIZES			*sizp;		/* For -S		*/
+	int			size;		/* For -S		*/
+	int			isdatum;	/* FALSE for -S*	*/
+	int			endtest;	/* For -S		*/
+
+	for (i = j = 1; i < argc; i++) {
+	    arg = ap = argv[i];
+	    if (*ap++ != '-' || *ap == EOS)
+		argv[j++] = argv[i];
+	    else {
+		c = *ap++;			/* Option byte		*/
+		if (islower(c))			/* Normalize case	*/
+		    c = toupper(c);
+		switch (c) {			/* Command character	*/
+		case 'C':			/* Keep comments	*/
+		    cflag = TRUE;
+		    keepcomments = TRUE;
+		    break;
+
+		case 'D':			/* Define symbol	*/
+#if HOST != SYS_UNIX
+		    zap_uc(ap);			/* Force define to U.C.	*/
+#endif
+		    /*
+		     * If the option is just "-Dfoo", make it -Dfoo=1
+		     */
+		    while (*ap != EOS && *ap != '=')
+			ap++;
+		    if (*ap == EOS)
+			ap = "1";
+		    else
+			*ap++ = EOS;
+		    /*
+		     * Now, save the word and its definition.
+		     */
+		    dp = defendel(argv[i] + 2, FALSE);
+		    dp->repl = savestring(ap);
+		    dp->nargs = DEF_NOARGS;
+		    break;
+
+		case 'E':			/* Ignore non-fatal	*/
+		    eflag = TRUE;		/* errors.		*/
+		    break;
+
+		case 'G':			/* Cmpiler's debug switch */
+		    break;
+
+		case 'I':			/* Include directory	*/
+		    if (incend >= &incdir[MAXINCLUDE])
+			cfatal("Too many include directories", NULLST);
+		    *incend++ = ap;
+		    break;
+
+		case 'N':			/* No predefineds	*/
+		    nflag++;			/* Repeat to undefine	*/
+		    break;			/* __LINE__, etc.	*/
+
+		case 'S':
+		    sizp = size_table;
+		    if (isdatum = (*ap != '*'))	/* If it's just -S,	*/
+			endtest = T_FPTR;	/* Stop here		*/
+		    else {			/* But if it's -S*	*/
+			ap++;			/* Step over '*'	*/
+			endtest = 0;		/* Stop at end marker	*/
+		    }
+		    while (sizp->bits != endtest && *ap != EOS) {
+			if (!isdigit(*ap)) {	/* Skip to next digit	*/
+			    ap++;
+			    continue;
+			}
+			size = 0;		/* Compile the value	*/
+			while (isdigit(*ap)) {
+			    size *= 10;
+			    size += (*ap++ - '0');
+			}
+			if (isdatum)
+			    sizp->size = size;	/* Datum size		*/
+			else
+			    sizp->psize = size;	/* Pointer size		*/
+			sizp++;
+		    }
+		    if (sizp->bits != endtest)
+			cwarn("-S, too few values specified in %s", argv[i]);
+		    else if (*ap != EOS)
+			cwarn("-S, too many values, \"%s\" unused", ap);
+		    break;
+
+		case 'U':			/* Undefine symbol	*/
+#if HOST != SYS_UNIX
+		    zap_uc(ap);
+#endif
+		    if (defendel(ap, TRUE) == NULL)
+			cwarn("\"%s\" wasn't defined", ap);
+		    break;
+
+#if DEBUG
+		case 'X':			/* Debug		*/
+		    debug = (isdigit(*ap)) ? atoi(ap) : 1;
+#if (HOST == SYS_VMS || HOST == SYS_UNIX)
+		    signal(SIGINT, abort);	/* Trap "interrupt"	*/
+#endif
+		    fprintf(stderr, "Debug set to %d\n", debug);
+		    break;
+#endif
+
+		default:			/* What is this one?	*/
+		    cwarn("Unknown option \"%s\"", arg);
+		    fprintf(stderr, "The following options are valid:\n\
+  -C\t\t\tWrite source file comments to output\n\
+  -Dsymbol=value\tDefine a symbol with the given (optional) value\n\
+  -Idirectory\t\tAdd a directory to the #include search list\n\
+  -N\t\t\tDon't predefine target-specific names\n\
+  -Stext\t\tSpecify sizes for #if sizeof\n\
+  -Usymbol\t\tUndefine symbol\n");
+#if DEBUG
+		    fprintf(stderr, "  -Xvalue\t\tSet internal debug flag\n");
+#endif
+		    break;
+		}			/* Switch on all options	*/
+	    }				/* If it's a -option		*/
+	}				/* For all arguments		*/
+	if (j > 3) {
+	    cerror(
+		"Too many file arguments.  Usage: cpp [input [output]]",
+		NULLST);
+	}
+	return (j);			/* Return new argc		*/
+}
+
+#if HOST != SYS_UNIX
+FILE_LOCAL
+zap_uc(ap)
+register char	*ap;
+/*
+ * Dec operating systems mangle upper-lower case in command lines.
+ * This routine forces the -D and -U arguments to uppercase.
+ * It is called only on cpp startup by dooptions().
+ */
+{
+	while (*ap != EOS) {
+	    /*
+	     * Don't use islower() here so it works with Multinational
+	     */
+	    if (*ap >= 'a' && *ap <= 'z')
+		*ap = toupper(*ap);
+	    ap++;
+	}
+}
+#endif
+
+initdefines()
+/*
+ * Initialize the built-in #define's.  There are two flavors:
+ * 	#define decus	1		(static definitions)
+ *	#define	__FILE__ ??		(dynamic, evaluated by magic)
+ * Called only on cpp startup.
+ *
+ * Note: the built-in static definitions are supressed by the -N option.
+ * __LINE__, __FILE__, and __DATE__ are always present.
+ */
+{
+	register char		**pp;
+	register char		*tp;
+	register DEFBUF		*dp;
+	int			i;
+	long			tvec;
+	extern char		*ctime();
+
+	/*
+	 * Predefine the built-in symbols.  Allow the
+	 * implementor to pre-define a symbol as "" to
+	 * eliminate it.
+	 */
+	if (nflag == 0) {
+	    for (pp = preset; *pp != NULL; pp++) {
+		if (*pp[0] != EOS) {
+		    dp = defendel(*pp, FALSE);
+		    dp->repl = savestring("1");
+		    dp->nargs = DEF_NOARGS;
+		}
+	    }
+	}
+	/*
+	 * The magic pre-defines (__FILE__ and __LINE__ are
+	 * initialized with negative argument counts.  expand()
+	 * notices this and calls the appropriate routine.
+	 * DEF_NOARGS is one greater than the first "magic" definition.
+	 */
+	if (nflag < 2) {
+	    for (pp = magic, i = DEF_NOARGS; *pp != NULL; pp++) {
+		dp = defendel(*pp, FALSE);
+		dp->nargs = --i;
+	    }
+#if OK_DATE
+	    /*
+	     * Define __DATE__ as today's date.
+	     */
+	    dp = defendel("__DATE__", FALSE);
+	    dp->repl = tp = getmem(27);
+	    dp->nargs = DEF_NOARGS;
+	    time(&tvec);
+	    *tp++ = '"';
+	    strcpy(tp, ctime(&tvec));
+	    tp[24] = '"';			/* Overwrite newline	*/
+#endif
+	}
+}
+
+#if HOST == SYS_VMS
+/*
+ * getredirection() is intended to aid in porting C programs
+ * to VMS (Vax-11 C) which does not support '>' and '<'
+ * I/O redirection.  With suitable modification, it may
+ * useful for other portability problems as well.
+ */
+
+int
+getredirection(argc, argv)
+int		argc;
+char		**argv;
+/*
+ * Process vms redirection arg's.  Exit if any error is seen.
+ * If getredirection() processes an argument, it is erased
+ * from the vector.  getredirection() returns a new argc value.
+ *
+ * Warning: do not try to simplify the code for vms.  The code
+ * presupposes that getredirection() is called before any data is
+ * read from stdin or written to stdout.
+ *
+ * Normal usage is as follows:
+ *
+ *	main(argc, argv)
+ *	int		argc;
+ *	char		*argv[];
+ *	{
+ *		argc = getredirection(argc, argv);
+ *	}
+ */
+{
+	register char		*ap;	/* Argument pointer	*/
+	int			i;	/* argv[] index		*/
+	int			j;	/* Output index		*/
+	int			file;	/* File_descriptor 	*/
+	extern int		errno;	/* Last vms i/o error 	*/
+
+	for (j = i = 1; i < argc; i++) {   /* Do all arguments	*/
+	    switch (*(ap = argv[i])) {
+	    case '<':			/* <file		*/
+		if (freopen(++ap, "r", stdin) == NULL) {
+		    perror(ap);		/* Can't find file	*/
+		    exit(errno);	/* Is a fatal error	*/
+		}
+		break;
+
+	    case '>':			/* >file or >>file	*/
+		if (*++ap == '>') {	/* >>file		*/
+		    /*
+		     * If the file exists, and is writable by us,
+		     * call freopen to append to the file (using the
+		     * file's current attributes).  Otherwise, create
+		     * a new file with "vanilla" attributes as if the
+		     * argument was given as ">filename".
+		     * access(name, 2) returns zero if we can write on
+		     * the specified file.
+		     */
+		    if (access(++ap, 2) == 0) {
+			if (freopen(ap, "a", stdout) != NULL)
+			    break;	/* Exit case statement	*/
+			perror(ap);	/* Error, can't append	*/
+			exit(errno);	/* After access test	*/
+		    }			/* If file accessable	*/
+		}
+		/*
+		 * On vms, we want to create the file using "standard"
+		 * record attributes.  creat(...) creates the file
+		 * using the caller's default protection mask and
+		 * "variable length, implied carriage return"
+		 * attributes. dup2() associates the file with stdout.
+		 */
+		if ((file = creat(ap, 0, "rat=cr", "rfm=var")) == -1
+		 || dup2(file, fileno(stdout)) == -1) {
+		    perror(ap);		/* Can't create file	*/
+		    exit(errno);	/* is a fatal error	*/
+		}			/* If '>' creation	*/
+		break;			/* Exit case test	*/
+
+	    default:
+		argv[j++] = ap;		/* Not a redirector	*/
+		break;			/* Exit case test	*/
+	    }
+	}				/* For all arguments	*/
+	argv[j] = NULL;			/* Terminate argv[]	*/
+	return (j);			/* Return new argc	*/
+}
+#endif
+
+
diff --git a/cpp/cpp4.c b/cpp/cpp4.c
new file mode 100644
index 0000000..87d8fe8
--- /dev/null
+++ b/cpp/cpp4.c
@@ -0,0 +1,589 @@
+/*
+ *			    C P P 4 . C
+ *		M a c r o  D e f i n i t i o n s
+ *
+ * Edit History
+ * 31-Aug-84	MM	USENET net.sources release
+ * 04-Oct-84	MM	__LINE__ and __FILE__ must call ungetstring()
+ *			so they work correctly with token concatenation.
+ *			Added string formal recognition.
+ * 25-Oct-84	MM	"Short-circuit" evaluate #if's so that we
+ *			don't print unnecessary error messages for
+ *			#if !defined(FOO) && FOO != 0 && 10 / FOO ...
+ * 31-Oct-84	ado/MM	Added token concatenation
+ *  6-Nov-84	MM	Split off eval stuff
+ * 21-Oct-85	RMS	Rename `token' to `tokenbuf'.
+ *			In doundef, don't complain if arg already not defined.
+ */
+
+#include	<stdio.h>
+#include	<ctype.h>
+#include	"cppdef.h"
+#include	"cpp.h"
+/*
+ * parm[], parmp, and parlist[] are used to store #define() argument
+ * lists.  nargs contains the actual number of parameters stored.
+ */
+static char	parm[NPARMWORK + 1];	/* define param work buffer 	*/
+static char	*parmp;			/* Free space in parm		*/
+static char	*parlist[LASTPARM];	/* -> start of each parameter	*/
+static int	nargs;			/* Parameters for this macro	*/
+
+dodefine()
+/*
+ * Called from control when a #define is scanned.  This module
+ * parses formal parameters and the replacement string.  When
+ * the formal parameter name is encountered in the replacement
+ * string, it is replaced by a character in the range 128 to
+ * 128+NPARAM (this allows up to 32 parameters within the
+ * Dec Multinational range).  If cpp is ported to an EBCDIC
+ * machine, you will have to make other arrangements.
+ *
+ * There is some special case code to distinguish
+ *	#define foo	bar
+ * from	#define foo()	bar
+ *
+ * Also, we make sure that
+ *	#define	foo	foo
+ * expands to "foo" but doesn't put cpp into an infinite loop.
+ *
+ * A warning message is printed if you redefine a symbol to a
+ * different text.  I.e,
+ *	#define	foo	123
+ *	#define foo	123
+ * is ok, but
+ *	#define foo	123
+ *	#define	foo	+123
+ * is not.
+ *
+ * The following subroutines are called from define():
+ * checkparm	called when a token is scanned.  It checks through the
+ *		array of formal parameters.  If a match is found, the
+ *		token is replaced by a control byte which will be used
+ *		to locate the parameter when the macro is expanded.
+ * textput	puts a string in the macro work area (parm[]), updating
+ *		parmp to point to the first free byte in parm[].
+ *		textput() tests for work buffer overflow.
+ * charput	puts a single character in the macro work area (parm[])
+ *		in a manner analogous to textput().
+ */
+{
+	register int		c;
+	register DEFBUF		*dp;		/* -> new definition	*/
+	int			isredefine;	/* TRUE if redefined	*/
+	char			*old;		/* Remember redefined	*/
+	extern int		save();		/* Save char in work[]	*/
+
+	if (type[(c = skipws())] != LET)
+	    goto bad_define;
+	isredefine = FALSE;			/* Set if redefining	*/
+	if ((dp = lookid(c)) == NULL)		/* If not known now	*/
+	    dp = defendel(tokenbuf, FALSE);	/* Save the name	*/
+	else {					/* It's known:		*/
+	    isredefine = TRUE;			/* Remember this fact	*/
+	    old = dp->repl;			/* Remember replacement	*/
+	    dp->repl = NULL;			/* No replacement now	*/
+	}
+	parlist[0] = parmp = parm;		/* Setup parm buffer	*/
+	if ((c = get()) == '(') {		/* With arguments?	*/
+	    nargs = 0;				/* Init formals counter	*/
+	    do {				/* Collect formal parms	*/
+		if (nargs >= LASTPARM)
+		    cfatal("Too many arguments for macro", NULLST);
+		else if ((c = skipws()) == ')')
+		    break;			/* Got them all		*/
+		else if (type[c] != LET)	/* Bad formal syntax	*/
+		    goto bad_define;
+		scanid(c);			/* Get the formal param	*/
+		parlist[nargs++] = parmp;	/* Save its start	*/
+		textput(tokenbuf);		/* Save text in parm[]	*/
+	    } while ((c = skipws()) == ',');	/* Get another argument	*/
+	    if (c != ')')			/* Must end at )	*/
+		goto bad_define;
+	    c = ' ';				/* Will skip to body	*/
+	}
+	else {
+	    /*
+	     * DEF_NOARGS is needed to distinguish between
+	     * "#define foo" and "#define foo()".
+	     */
+	    nargs = DEF_NOARGS;			/* No () parameters	*/
+	}
+	if (type[c] == SPA)			/* At whitespace?	*/
+	    c = skipws();			/* Not any more.	*/
+	workp = work;				/* Replacement put here	*/
+	inmacro = TRUE;				/* Keep \<newline> now	*/
+	while (c != EOF_CHAR && c != '\n') {	/* Compile macro body	*/
+#if OK_CONCAT
+	    if (c == '#') {			/* Token concatenation?	*/
+		while (workp > work && type[workp[-1]] == SPA)
+		    --workp;			/* Erase leading spaces	*/
+		save(TOK_SEP);			/* Stuff a delimiter	*/
+		c = skipws();			/* Eat whitespace	*/
+		if (type[c] == LET)		/* Another token here?	*/
+		    ;				/* Stuff it normally	*/
+		else if (type[c] == DIG) {	/* Digit string after?	*/
+		    while (type[c] == DIG) {	/* Stuff the digits	*/
+			save(c);
+			c = get();
+		    }
+		    save(TOK_SEP);		/* Delimit 2nd token	*/
+		}
+		else {
+		    ciwarn("Strange character after # (%d.)", c);
+		}
+		continue;
+	    }
+#endif
+	    switch (type[c]) {
+	    case LET:
+		checkparm(c, dp);		/* Might be a formal	*/
+		break;
+
+	    case DIG:				/* Number in mac. body	*/
+	    case DOT:				/* Maybe a float number	*/
+		scannumber(c, save);		/* Scan it off		*/
+		break;
+
+	    case QUO:				/* String in mac. body	*/
+#if STRING_FORMAL
+		stparmscan(c, dp);		/* Do string magic	*/
+#else
+		stparmscan(c);
+#endif
+		break;
+
+	    case BSH:				/* Backslash		*/
+		save('\\');
+		if ((c = get()) == '\n')
+		    wrongline = TRUE;
+		save(c);
+		break;
+
+	    case SPA:				/* Absorb whitespace	*/
+		/*
+		 * Note: the "end of comment" marker is passed on
+		 * to allow comments to separate tokens.
+		 */
+		if (workp[-1] == ' ')		/* Absorb multiple	*/
+		    break;			/* spaces		*/
+		else if (c == '\t')
+		    c = ' ';			/* Normalize tabs	*/
+		/* Fall through to store character			*/
+	    default:				/* Other character	*/
+		save(c);
+		break;
+	    }
+	    c = get();
+	}
+	inmacro = FALSE;			/* Stop newline hack	*/
+	unget();				/* For control check	*/
+	if (workp > work && workp[-1] == ' ')	/* Drop trailing blank	*/
+	    workp--;
+	*workp = EOS;				/* Terminate work	*/
+	dp->repl = savestring(work);		/* Save the string	*/
+	dp->nargs = nargs;			/* Save arg count	*/
+#if DEBUG
+	if (debug)
+	    dumpadef("macro definition", dp);
+#endif
+	if (isredefine) {			/* Error if redefined	*/
+	    if ((old != NULL && dp->repl != NULL && !streq(old, dp->repl))
+	     || (old == NULL && dp->repl != NULL)
+	     || (old != NULL && dp->repl == NULL)) {
+		cerror("Redefining defined variable \"%s\"", dp->name);
+	    }
+	    if (old != NULL)			/* We don't need the	*/
+		free(old);			/* old definition now.	*/
+	}	 
+	return;
+
+bad_define:
+	cerror("#define syntax error", NULLST);
+	inmacro = FALSE;			/* Stop <newline> hack	*/
+}
+
+checkparm(c, dp)
+register int	c;
+DEFBUF		*dp;
+/*
+ * Replace this param if it's defined.  Note that the macro name is a
+ * possible replacement token.  We stuff DEF_MAGIC in front of the token
+ * which is treated as a LETTER by the token scanner and eaten by
+ * the output routine.  This prevents the macro expander from
+ * looping if someone writes "#define foo foo".
+ */
+{
+	register int		i;
+	register char		*cp;
+
+	scanid(c);				/* Get parm to tokenbuf */
+	for (i = 0; i < nargs; i++) {		/* For each argument	*/
+	    if (streq(parlist[i], tokenbuf)) {	/* If it's known	*/
+		save(i + MAC_PARM);		/* Save a magic cookie	*/
+		return;				/* And exit the search	*/
+	    }
+	}
+	if (streq(dp->name, tokenbuf))		/* Macro name in body?	*/
+	    save(DEF_MAGIC);			/* Save magic marker	*/
+	for (cp = tokenbuf; *cp != EOS;)	/* And save		*/
+	    save(*cp++);			/* The token itself	*/
+}
+
+#if STRING_FORMAL
+stparmscan(delim, dp)
+int		delim;
+register DEFBUF	*dp;
+/*
+ * Scan the string (starting with the given delimiter).
+ * The token is replaced if it is the only text in this string or
+ * character constant.  The algorithm follows checkparm() above.
+ * Note that scanstring() has approved of the string.
+ */
+{
+	register int		c;
+
+	/*
+	 * Warning -- this code hasn't been tested for a while.
+	 * It exists only to preserve compatibility with earlier
+	 * implementations of cpp.  It is not part of the Draft
+	 * ANSI Standard C language.
+	 */
+	save(delim);
+	instring = TRUE;
+	while ((c = get()) != delim
+	     && c != '\n'
+	     && c != EOF_CHAR) {
+	    if (type[c] == LET)			/* Maybe formal parm	*/
+		checkparm(c, dp);
+	    else {
+		save(c);
+		if (c == '\\')
+		    save(get());
+	    }
+	}
+	instring = FALSE;
+	if (c != delim)
+	    cerror("Unterminated string in macro body", NULLST);
+	save(c);
+}
+#else
+stparmscan(delim)
+int		delim;
+/*
+ * Normal string parameter scan.
+ */
+{
+	register char		*wp;
+	register int		i;
+	extern int		save();
+
+	wp = workp;			/* Here's where it starts	*/
+	if (!scanstring(delim, save))
+	    return;			/* Exit on scanstring error	*/
+	workp[-1] = EOS;		/* Erase trailing quote		*/
+	wp++;				/* -> first string content byte	*/ 
+	for (i = 0; i < nargs; i++) {
+	    if (streq(parlist[i], wp)) {
+		*wp++ = MAC_PARM + PAR_MAC;	/* Stuff a magic marker	*/
+		*wp++ = (i + MAC_PARM);		/* Make a formal marker	*/
+		*wp = wp[-3];			/* Add on closing quote	*/
+		workp = wp + 1;			/* Reset string end	*/
+		return;
+	    }
+	}
+	workp[-1] = wp[-1];		/* Nope, reset end quote.	*/
+}
+#endif
+
+doundef()
+/*
+ * Remove the symbol from the defined list.
+ * Called from the #control processor.
+ */
+{
+  register int c;
+
+  if (type[(c = skipws())] != LET)
+    cerror("Illegal #undef argument", NULLST);
+  else
+    {
+      scanid(c);				/* Get name to tokenbuf */
+      defendel(tokenbuf, TRUE);
+    }
+}
+
+textput(text)
+char		*text;
+/*
+ * Put the string in the parm[] buffer.
+ */
+{
+	register int	size;
+
+	size = strlen(text) + 1;
+	if ((parmp + size) >= &parm[NPARMWORK])
+	    cfatal("Macro work area overflow", NULLST);
+	else {
+	    strcpy(parmp, text);
+	    parmp += size;
+	}
+}
+
+charput(c)
+register int	c;
+/*
+ * Put the byte in the parm[] buffer.
+ */
+{
+	if (parmp >= &parm[NPARMWORK])
+	    cfatal("Macro work area overflow", NULLST);
+	else {
+	    *parmp++ = c;
+	}
+}
+
+/*
+ *		M a c r o   E x p a n s i o n
+ */
+
+static DEFBUF	*macro;		/* Catches start of infinite macro	*/
+
+expand(tokenp)
+register DEFBUF	*tokenp;
+/*
+ * Expand a macro.  Called from the cpp mainline routine (via subroutine
+ * macroid()) when a token is found in the symbol table.  It calls
+ * expcollect() to parse actual parameters, checking for the correct number.
+ * It then creates a "file" containing a single line containing the
+ * macro with actual parameters inserted appropriately.  This is
+ * "pushed back" onto the input stream.  (When the get() routine runs
+ * off the end of the macro line, it will dismiss the macro itself.)
+ */
+{
+	register int		c;
+	register FILEINFO	*file;
+	extern FILEINFO		*getfile();
+
+#if DEBUG
+	if (debug)
+	    dumpadef("expand entry", tokenp);
+#endif
+	/*
+	 * If no macro is pending, save the name of this macro
+	 * for an eventual error message.
+	 */
+	if (recursion++ == 0)
+	    macro = tokenp;
+	else if (recursion == RECURSION_LIMIT) {
+	    cerror("Recursive macro definition of \"%s\"", tokenp->name);
+	    fprintf(stderr, "(Defined by \"%s\")\n", macro->name);
+	    if (rec_recover) {
+		do {
+		    c = get();
+		} while (infile != NULL && infile->fp == NULL);
+		unget();
+		recursion = 0;
+		return;
+	    }
+	}
+	/*
+	 * Here's a macro to expand.
+	 */
+	nargs = 0;				/* Formals counter	*/
+	parmp = parm;				/* Setup parm buffer	*/
+	switch (tokenp->nargs) {
+	case (-2):				/* __LINE__		*/
+	    sprintf(work, "%d", line);
+	    ungetstring(work);
+	    break;
+
+	case (-3):				/* __FILE__		*/
+	    for (file = infile; file != NULL; file = file->parent) {
+		if (file->fp != NULL) {
+		    sprintf(work, "\"%s\"", (file->progname != NULL)
+			? file->progname : file->filename);
+		    ungetstring(work);
+		    break;
+		}
+	    }
+	    break;
+
+	default:
+	    /*
+	     * Nothing funny about this macro.
+	     */
+	    if (tokenp->nargs < 0)
+		cfatal("Bug: Illegal __ macro \"%s\"", tokenp->name);
+	    while ((c = skipws()) == '\n')	/* Look for (, skipping	*/
+		wrongline = TRUE;		/* spaces and newlines	*/
+	    if (c != '(') {
+		/*
+		 * If the programmer writes
+		 *	#define foo() ...
+		 *	...
+		 *	foo [no ()]
+		 * just write foo to the output stream.
+		 */
+		unget();
+		cwarn("Macro \"%s\" needs arguments", tokenp->name);
+		fputs(tokenp->name, stdout);
+		return;
+	    }
+	    else if (expcollect()) {		/* Collect arguments	*/
+		if (tokenp->nargs != nargs) {	/* Should be an error?	*/
+		    cwarn("Wrong number of macro arguments for \"%s\"",
+			tokenp->name);
+		}
+#if DEBUG
+		if (debug)
+		    dumpparm("expand");
+#endif
+	    }				/* Collect arguments		*/
+	case DEF_NOARGS:		/* No parameters just stuffs	*/
+	    expstuff(tokenp);		/* Do actual parameters		*/
+	}				/* nargs switch			*/
+}
+
+FILE_LOCAL int
+expcollect()
+/*
+ * Collect the actual parameters for this macro.  TRUE if ok.
+ */
+{
+	register int	c;
+	register int	paren;			/* For embedded ()'s	*/
+	extern int	charput();
+
+	for (;;) {
+	    paren = 0;				/* Collect next arg.	*/
+	    while ((c = skipws()) == '\n')	/* Skip over whitespace	*/
+		wrongline = TRUE;		/* and newlines.	*/
+	    if (c == ')') {			/* At end of all args?	*/
+		/*
+		 * Note that there is a guard byte in parm[]
+		 * so we don't have to check for overflow here.
+		 */
+		*parmp = EOS;			/* Make sure terminated	*/
+		break;				/* Exit collection loop	*/
+	    }
+	    else if (nargs >= LASTPARM)
+		cfatal("Too many arguments in macro expansion", NULLST);
+	    parlist[nargs++] = parmp;		/* At start of new arg	*/
+	    for (;; c = cget()) {		/* Collect arg's bytes	*/
+		if (c == EOF_CHAR) {
+		    cerror("end of file within macro argument", NULLST);
+		    return (FALSE);		/* Sorry.		*/
+		}
+		else if (c == '\\') {		/* Quote next character	*/
+		    charput(c);			/* Save the \ for later	*/
+		    charput(cget());		/* Save the next char.	*/
+		    continue;			/* And go get another	*/
+		}
+		else if (type[c] == QUO) {	/* Start of string?	*/
+		    scanstring(c, charput);	/* Scan it off		*/
+		    continue;			/* Go get next char	*/
+		}
+		else if (c == '(')		/* Worry about balance	*/
+		    paren++;			/* To know about commas	*/
+		else if (c == ')') {		/* Other side too	*/
+		    if (paren == 0) {		/* At the end?		*/
+			unget();		/* Look at it later	*/
+			break;			/* Exit arg getter.	*/
+		    }
+		    paren--;			/* More to come.	*/
+		}
+		else if (c == ',' && paren == 0) /* Comma delimits args	*/
+		    break;
+		else if (c == '\n')		/* Newline inside arg?	*/
+		    wrongline = TRUE;		/* We'll need a #line	*/
+		charput(c);			/* Store this one	*/
+	    }					/* Collect an argument	*/
+	    charput(EOS);			/* Terminate argument	*/
+#if DEBUG
+	    if (debug)
+	        printf("parm[%d] = \"%s\"\n", nargs, parlist[nargs - 1]);
+#endif
+	}					/* Collect all args.	*/
+	return (TRUE);				/* Normal return	*/
+}
+
+FILE_LOCAL
+expstuff(tokenp)
+DEFBUF		*tokenp;		/* Current macro being expanded	*/
+/*
+ * Stuff the macro body, replacing formal parameters by actual parameters.
+ */
+{
+	register int	c;			/* Current character	*/
+	register char	*inp;			/* -> repl string	*/
+	register char	*defp;			/* -> macro output buff	*/
+	int		size;			/* Actual parm. size	*/
+	char		*defend;		/* -> output buff end	*/
+	int		string_magic;		/* String formal hack	*/
+	FILEINFO	*file;			/* Funny #include	*/
+	extern FILEINFO	*getfile();
+
+	file = getfile(NBUFF, tokenp->name);
+	inp = tokenp->repl;			/* -> macro replacement	*/
+	defp = file->buffer;			/* -> output buffer	*/
+	defend = defp + (NBUFF - 1);		/* Note its end		*/
+	if (inp != NULL) {
+	    while ((c = (*inp++ & 0xFF)) != EOS) {
+		if (c >= MAC_PARM && c <= (MAC_PARM + PAR_MAC)) {
+		    string_magic = (c == (MAC_PARM + PAR_MAC));
+		    if (string_magic)
+		 	c = (*inp++ & 0xFF);
+		    /*
+		     * Replace formal parameter by actual parameter string.
+		     */
+		    if ((c -= MAC_PARM) < nargs) {
+			size = strlen(parlist[c]);
+			if ((defp + size) >= defend)
+			    goto nospace;
+			/*
+			 * Erase the extra set of quotes.
+			 */
+			if (string_magic && defp[-1] == parlist[c][0]) {
+			    strcpy(defp-1, parlist[c]);
+			    defp += (size - 2);
+			}
+			else {
+			    strcpy(defp, parlist[c]);
+			    defp += size;
+			}
+		    }
+		}
+		else if (defp >= defend) {
+nospace:	    cfatal("Out of space in macro \"%s\" arg expansion",
+			tokenp->name);
+		}
+		else {
+		    *defp++ = c;
+		}
+	    }
+	}
+	*defp = EOS;
+#if DEBUG
+	if (debug > 1)
+	    printf("macroline: \"%s\"\n", file->buffer);
+#endif
+}
+
+#if DEBUG
+dumpparm(why)
+char		*why;
+/*
+ * Dump parameter list.
+ */
+{
+	register int	i;
+
+	printf("dump of %d parameters (%d bytes total) %s\n",
+	    nargs, parmp - parm, why);
+	for (i = 0; i < nargs; i++) {
+	    printf("parm[%d] (%d) = \"%s\"\n",
+		i + 1, strlen(parlist[i]), parlist[i]);
+	}
+}
+#endif
diff --git a/cpp/cpp5.c b/cpp/cpp5.c
new file mode 100644
index 0000000..d9bfe2b
--- /dev/null
+++ b/cpp/cpp5.c
@@ -0,0 +1,900 @@
+/*
+ *			    C P P 5 . C
+ *		E x p r e s s i o n   E v a l u a t i o n
+ *
+ * Edit History
+ * 31-Aug-84	MM	USENET net.sources release
+ * 04-Oct-84	MM	__LINE__ and __FILE__ must call ungetstring()
+ *			so they work correctly with token concatenation.
+ *			Added string formal recognition.
+ * 25-Oct-84	MM	"Short-circuit" evaluate #if's so that we
+ *			don't print unnecessary error messages for
+ *			#if !defined(FOO) && FOO != 0 && 10 / FOO ...
+ * 31-Oct-84	ado/MM	Added token concatenation
+ *  6-Nov-84	MM	Split from #define stuff, added sizeof stuff
+ * 19-Nov-84	ado	#if error returns TRUE for (sigh) compatibility
+ * 21-Oct-85	RMS	Rename `token' to `tokenbuf'
+ * 23-Oct-85	RMS	Treat undefined symbols as having value zero.
+ */
+
+#include	<stdio.h>
+#include	<ctype.h>
+#include	"cppdef.h"
+#include	"cpp.h"
+
+/*
+ * Evaluate an #if expression.
+ */
+
+static char	*opname[] = {		/* For debug and error messages	*/
+"end of expression", "val", "id",
+  "+",   "-",  "*",  "/",  "%",
+  "<<", ">>",  "&",  "|",  "^",
+  "==", "!=",  "<", "<=", ">=",  ">",
+  "&&", "||",  "?",  ":",  ",",
+  "unary +", "unary -", "~", "!",  "(",  ")", "(none)",
+};
+
+/*
+ * opdope[] has the operator precedence:
+ *     Bits
+ *	  7	Unused (so the value is always positive)
+ *	6-2	Precedence (000x .. 017x)
+ *	1-0	Binary op. flags:
+ *	    01	The binop flag should be set/cleared when this op is seen.
+ *	    10	The new value of the binop flag.
+ * Note:  Expected, New binop
+ * constant	0	1	Binop, end, or ) should follow constants
+ * End of line	1	0	End may not be preceeded by an operator
+ * binary	1	0	Binary op follows a value, value follows.
+ * unary	0	0	Unary op doesn't follow a value, value follows
+ *   (		0	0	Doesn't follow value, value or unop follows
+ *   )		1	1	Follows value.  Op follows.
+ */
+
+static char	opdope[OP_MAX] = {
+  0001,					/* End of expression		*/
+  0002,					/* Digit			*/
+  0000,					/* Letter (identifier)		*/
+  0141, 0141, 0151, 0151, 0151,		/* ADD, SUB, MUL, DIV, MOD	*/
+  0131, 0131, 0101, 0071, 0071,		/* ASL, ASR, AND,  OR, XOR	*/
+  0111, 0111, 0121, 0121, 0121,	0121,	/*  EQ,  NE,  LT,  LE,  GE,  GT	*/
+  0061, 0051, 0041, 0041, 0031,		/* ANA, ORO, QUE, COL, CMA	*/
+/*
+ * Unary op's follow
+ */
+  0160, 0160, 0160, 0160,		/* NEG, PLU, COM, NOT		*/
+  0170, 0013, 0023,			/* LPA, RPA, END		*/
+};
+/*
+ * OP_QUE and OP_RPA have alternate precedences:
+ */
+#define	OP_RPA_PREC	0013
+#define OP_QUE_PREC	0034
+
+/*
+ * S_ANDOR and S_QUEST signal "short-circuit" boolean evaluation, so that
+ *	#if FOO != 0 && 10 / FOO ...
+ * doesn't generate an error message.  They are stored in optab.skip.
+ */
+#define S_ANDOR		2
+#define S_QUEST		1
+
+typedef struct optab {
+    char	op;			/* Operator			*/
+    char	prec;			/* Its precedence		*/
+    char	skip;			/* Short-circuit: TRUE to skip	*/
+} OPTAB;
+static int	evalue;			/* Current value from evallex()	*/
+
+#ifdef	nomacargs
+FILE_LOCAL int
+isbinary(op)
+register int	op;
+{
+	return (op >= FIRST_BINOP && op <= LAST_BINOP);
+}
+
+FILE_LOCAL int
+isunary(op)
+register int	op;
+{
+	return (op >= FIRST_UNOP && op <= LAST_UNOP);
+}
+#else
+#define	isbinary(op)	(op >= FIRST_BINOP && op <= LAST_BINOP)
+#define	isunary(op)	(op >= FIRST_UNOP  && op <= LAST_UNOP)
+#endif
+
+/*
+ * The following definitions are used to specify basic variable sizes.
+ */
+
+#ifndef	S_CHAR
+#define	S_CHAR		(sizeof (char))
+#endif
+#ifndef	S_SINT
+#define	S_SINT		(sizeof (short int))
+#endif
+#ifndef	S_INT
+#define	S_INT		(sizeof (int))
+#endif
+#ifndef	S_LINT
+#define	S_LINT		(sizeof (long int))
+#endif
+#ifndef	S_FLOAT
+#define	S_FLOAT		(sizeof (float))
+#endif
+#ifndef	S_DOUBLE
+#define	S_DOUBLE	(sizeof (double))
+#endif
+#ifndef	S_PCHAR
+#define	S_PCHAR		(sizeof (char *))
+#endif
+#ifndef	S_PSINT
+#define	S_PSINT		(sizeof (short int *))
+#endif
+#ifndef	S_PINT
+#define	S_PINT		(sizeof (int *))
+#endif
+#ifndef	S_PLINT
+#define	S_PLINT		(sizeof (long int *))
+#endif
+#ifndef	S_PFLOAT
+#define	S_PFLOAT	(sizeof (float *))
+#endif
+#ifndef	S_PDOUBLE
+#define	S_PDOUBLE	(sizeof (double *))
+#endif
+#ifndef	S_PFPTR
+#define S_PFPTR		(sizeof (int (*)()))
+#endif
+
+typedef struct types {
+    short	type;			/* This is the bit if		*/
+    char	*name;			/* this is the token word	*/
+} TYPES;
+
+static TYPES basic_types[] = {
+	{ T_CHAR,	"char",		},
+	{ T_INT,	"int",		},
+	{ T_FLOAT,	"float",	},
+	{ T_DOUBLE,	"double",	},
+	{ T_SHORT,	"short",	},
+	{ T_LONG,	"long",		},
+	{ T_SIGNED,	"signed",	},
+	{ T_UNSIGNED,	"unsigned",	},
+	{ 0,		NULL,		},	/* Signal end		*/
+};
+
+/*
+ * Test_table[] is used to test for illegal combinations.
+ */
+static short test_table[] = {
+	T_FLOAT | T_DOUBLE | T_LONG | T_SHORT,
+	T_FLOAT | T_DOUBLE | T_CHAR | T_INT,
+	T_FLOAT | T_DOUBLE | T_SIGNED | T_UNSIGNED,
+	T_LONG  | T_SHORT  | T_CHAR,
+	0						/* end marker	*/
+};
+
+/*
+ * The order of this table is important -- it is also referenced by
+ * the command line processor to allow run-time overriding of the
+ * built-in size values.  The order must not be changed:
+ *	char, short, int, long, float, double (func pointer)
+ */
+SIZES size_table[] = {
+    { T_CHAR,	S_CHAR,		S_PCHAR		},	/* char		*/
+    { T_SHORT,	S_SINT,		S_PSINT		},	/* short int	*/
+    { T_INT,	S_INT,		S_PINT		},	/* int		*/
+    { T_LONG,	S_LINT,		S_PLINT		},	/* long		*/
+    { T_FLOAT,	S_FLOAT,	S_PFLOAT	},	/* float	*/
+    { T_DOUBLE,	S_DOUBLE,	S_PDOUBLE	},	/* double	*/
+    { T_FPTR,	0,		S_PFPTR		},	/* int (*()) 	*/
+    { 0,	0,		0		},	/* End of table	*/
+};
+
+int
+eval()
+/*
+ * Evaluate an expression.  Straight-forward operator precedence.
+ * This is called from control() on encountering an #if statement.
+ * It calls the following routines:
+ * evallex	Lexical analyser -- returns the type and value of
+ *		the next input token.
+ * evaleval	Evaluate the current operator, given the values on
+ *		the value stack.  Returns a pointer to the (new)
+ *		value stack.
+ * For compatiblity with older cpp's, this return returns 1 (TRUE)
+ * if a syntax error is detected.
+ */
+{
+	register int	op;		/* Current operator		*/
+	register int	*valp;		/* -> value vector		*/
+	register OPTAB	*opp;		/* Operator stack		*/
+	int		prec;		/* Op precedence		*/
+	int		binop;		/* Set if binary op. needed	*/
+	int		op1;		/* Operand from stack		*/
+	int		skip;		/* For short-circuit testing	*/
+	int		value[NEXP];	/* Value stack			*/
+	OPTAB		opstack[NEXP];	/* Operand stack		*/
+	extern int	*evaleval();	/* Does actual evaluation	*/
+
+	valp = value;
+	opp = opstack;
+	opp->op = OP_END;		/* Mark bottom of stack		*/
+	opp->prec = opdope[OP_END];	/* And its precedence		*/
+	opp->skip = 0;			/* Not skipping now		*/
+	binop = 0;
+again:	;
+#ifdef	DEBUG_EVAL
+	printf("In #if at again: skip = %d, binop = %d, line is: %s",
+	    opp->skip, binop, infile->bptr);
+#endif
+	if ((op = evallex(opp->skip)) == OP_SUB && binop == 0)
+	    op = OP_NEG;			/* Unary minus		*/
+	else if (op == OP_ADD && binop == 0)
+	    op = OP_PLU;			/* Unary plus		*/
+	else if (op == OP_FAIL)
+	    return (1);				/* Error in evallex	*/
+#ifdef	DEBUG_EVAL
+	printf("op = %s, opdope = %03o, binop = %d, skip = %d\n",
+	    opname[op], opdope[op], binop, opp->skip);
+#endif
+	if (op == DIG) {			/* Value?		*/
+	    if (binop != 0) {
+		cerror("misplaced constant in #if", NULLST);
+		return (1);
+	    }
+	    else if (valp >= &value[NEXP-1]) {
+		cerror("#if value stack overflow", NULLST);
+		return (1);
+	    }
+	    else {
+#ifdef	DEBUG_EVAL
+		printf("pushing %d onto value stack[%d]\n",
+		    evalue, valp - value);
+#endif
+		*valp++ = evalue;
+		binop = 1;
+	    }
+	    goto again;
+	}
+	else if (op > OP_END) {
+	    cerror("Illegal #if line", NULLST);
+	    return (1);
+	}
+	prec = opdope[op];
+	if (binop != (prec & 1)) {
+	    cerror("Operator %s in incorrect context", opname[op]);
+	    return (1);
+	}
+	binop = (prec & 2) >> 1;
+	for (;;) {
+#ifdef	DEBUG_EVAL
+	    printf("op %s, prec %d., stacked op %s, prec %d, skip %d\n",
+		opname[op], prec, opname[opp->op], opp->prec, opp->skip);
+#endif
+	    if (prec > opp->prec) {
+		if (op == OP_LPA)
+		    prec = OP_RPA_PREC;
+		else if (op == OP_QUE)
+		    prec = OP_QUE_PREC;
+		op1 = opp->skip;		/* Save skip for test	*/
+		/*
+		 * Push operator onto op. stack.
+		 */
+		opp++;
+		if (opp >= &opstack[NEXP]) {
+		    cerror("expression stack overflow at op \"%s\"",
+			opname[op]);
+		    return (1);
+		}
+		opp->op = op;
+		opp->prec = prec;
+		skip = (valp[-1] != 0);		/* Short-circuit tester	*/
+		/*
+		 * Do the short-circuit stuff here.  Short-circuiting
+		 * stops automagically when operators are evaluated.
+		 */
+		if ((op == OP_ANA && !skip)
+		 || (op == OP_ORO && skip))
+		    opp->skip = S_ANDOR;	/* And/or skip starts	*/
+		else if (op == OP_QUE)		/* Start of ?: operator	*/
+		    opp->skip = (op1 & S_ANDOR) | ((!skip) ? S_QUEST : 0);
+		else if (op == OP_COL) {	/* : inverts S_QUEST	*/
+		    opp->skip = (op1 & S_ANDOR)
+			      | (((op1 & S_QUEST) != 0) ? 0 : S_QUEST);
+		}
+		else {				/* Other ops leave	*/
+		    opp->skip = op1;		/*  skipping unchanged.	*/
+		}
+#ifdef	DEBUG_EVAL
+		printf("stacking %s, valp[-1] == %d at %s",
+		    opname[op], valp[-1], infile->bptr);
+		dumpstack(opstack, opp, value, valp);
+#endif
+		goto again;
+	    }
+	    /*
+	     * Pop operator from op. stack and evaluate it.
+	     * End of stack and '(' are specials.
+	     */
+	    skip = opp->skip;			/* Remember skip value	*/
+	    switch ((op1 = opp->op)) {		/* Look at stacked op	*/
+	    case OP_END:			/* Stack end marker	*/
+		if (op == OP_EOE)
+		    return (valp[-1]);		/* Finished ok.		*/
+		goto again;			/* Read another op.	*/
+
+	    case OP_LPA:			/* ( on stack		*/
+		if (op != OP_RPA) {		/* Matches ) on input	*/
+		    cerror("unbalanced paren's, op is \"%s\"", opname[op]);
+		    return (1);
+		}
+		opp--;				/* Unstack it		*/
+		/* goto again;			-- Fall through		*/
+
+	    case OP_QUE:
+		goto again;			/* Evaluate true expr.	*/
+
+	    case OP_COL:			/* : on stack.		*/
+		opp--;				/* Unstack :		*/
+		if (opp->op != OP_QUE) {	/* Matches ? on stack?	*/
+		    cerror("Misplaced '?' or ':', previous operator is %s",
+			opname[opp->op]);
+		    return (1);
+		}
+		/*
+		 * Evaluate op1.
+		 */
+	    default:				/* Others:		*/
+		opp--;				/* Unstack the operator	*/
+#ifdef	DEBUG_EVAL
+		printf("Stack before evaluation of %s\n", opname[op1]);
+		dumpstack(opstack, opp, value, valp);
+#endif
+		valp = evaleval(valp, op1, skip);
+#ifdef	DEBUG_EVAL
+		printf("Stack after evaluation\n");
+		dumpstack(opstack, opp, value, valp);
+#endif
+	    }					/* op1 switch end	*/
+	}					/* Stack unwind loop	*/
+}
+
+FILE_LOCAL int
+evallex(skip)
+int		skip;		/* TRUE if short-circuit evaluation	*/
+/*
+ * Return next eval operator or value.  Called from eval().  It
+ * calls a special-purpose routines for 'char' strings and
+ * numeric values:
+ * evalchar	called to evaluate 'x'
+ * evalnum	called to evaluate numbers.
+ */
+{
+	register int	c, c1, t;
+
+again:  do {					/* Collect the token	*/
+	    c = skipws();
+	    if ((c = macroid(c)) == EOF_CHAR || c == '\n') {
+		unget();
+		return (OP_EOE);		/* End of expression	*/
+	    }
+	} while ((t = type[c]) == LET && catenate());
+	if (t == INV) {				/* Total nonsense	*/
+	    if (!skip) {
+		if (isascii(c) && isprint(c))
+		    cierror("illegal character '%c' in #if", c);
+		else
+		    cierror("illegal character (%d decimal) in #if", c);
+	    }
+	    return (OP_FAIL);
+	}
+	else if (t == QUO) {			/* ' or "		*/
+	    if (c == '\'') {			/* Character constant	*/
+		evalue = evalchar(skip);	/* Somewhat messy	*/
+#ifdef	DEBUG_EVAL
+		printf("evalchar returns %d.\n", evalue);
+#endif
+		return (DIG);			/* Return a value	*/
+	    }
+	    cerror("Can't use a string in an #if", NULLST);
+	    return (OP_FAIL);
+	}
+	else if (t == LET) {			/* ID must be a macro	*/
+	    if (streq(tokenbuf, "defined")) {	/* Or defined name	*/
+		c1 = c = skipws();
+		if (c == '(')			/* Allow defined(name)	*/
+		    c = skipws();
+		if (type[c] == LET) {
+		    evalue = (lookid(c) != NULL);
+		    if (c1 != '('		/* Need to balance	*/
+		     || skipws() == ')')	/* Did we balance?	*/
+			return (DIG);		/* Parsed ok		*/
+		}
+		cerror("Bad #if ... defined() syntax", NULLST);
+		return (OP_FAIL);
+	    }
+	    else if (streq(tokenbuf, "sizeof"))	/* New sizeof hackery	*/
+		return (dosizeof());		/* Gets own routine	*/
+	    evalue = 0;
+	    return (DIG);
+	}
+	else if (t == DIG) {			/* Numbers are harder	*/
+	    evalue = evalnum(c);
+#ifdef	DEBUG_EVAL
+	    printf("evalnum returns %d.\n", evalue);
+#endif
+	}
+	else if (strchr("!=<>&|\\", c) != NULL) {
+	    /*
+	     * Process a possible multi-byte lexeme.
+	     */
+	    c1 = cget();			/* Peek at next char	*/
+	    switch (c) {
+	    case '!':
+		if (c1 == '=')
+		    return (OP_NE);
+		break;
+
+	    case '=':
+		if (c1 != '=') {		/* Can't say a=b in #if	*/
+		    unget();
+		    cerror("= not allowed in #if", NULLST);
+		    return (OP_FAIL);
+		}
+		return (OP_EQ);
+
+	    case '>':
+	    case '<':
+		if (c1 == c)
+		    return ((c == '<') ? OP_ASL : OP_ASR);
+		else if (c1 == '=')
+		    return ((c == '<') ? OP_LE  : OP_GE);
+		break;
+
+	    case '|':
+	    case '&':
+		if (c1 == c)
+		    return ((c == '|') ? OP_ORO : OP_ANA);
+		break;
+
+	    case '\\':
+		if (c1 == '\n')			/* Multi-line if	*/
+		    goto again;
+		cerror("Unexpected \\ in #if", NULLST);
+		return (OP_FAIL);
+	    }
+	    unget();
+	}
+	return (t);
+}
+
+FILE_LOCAL int
+dosizeof()
+/*
+ * Process the sizeof (basic type) operation in an #if string.
+ * Sets evalue to the size and returns
+ *	DIG		success
+ *	OP_FAIL		bad parse or something.
+ */
+{
+	register int	c;
+	register TYPES	*tp;
+	register SIZES	*sizp;
+	register short	*testp;
+	short		typecode;
+
+	if ((c = skipws()) != '(')
+	    goto nogood;
+	/*
+	 * Scan off the tokens.
+	 */
+	typecode = 0;
+	while ((c = skipws())) {
+	    if ((c = macroid(c)) == EOF_CHAR || c == '\n')
+		goto nogood;			/* End of line is a bug	*/
+	    else if (c == '(') {		/* thing (*)() func ptr	*/
+		if (skipws() == '*'
+		 && skipws() == ')') {		/* We found (*)		*/
+		    if (skipws() != '(')	/* Let () be optional	*/
+			unget();
+		    else if (skipws() != ')')
+			goto nogood;
+		    typecode |= T_FPTR;		/* Function pointer	*/
+		}
+		else {				/* Junk is a bug	*/
+		    goto nogood;
+		}
+	    }
+	    else if (type[c] != LET)		/* Exit if not a type	*/
+		break;
+	    else if (!catenate()) {		/* Maybe combine tokens	*/
+		/*
+		 * Look for this unexpandable token in basic_types.
+		 * The code accepts "int long" as well as "long int"
+		 * which is a minor bug as bugs go (and one shared with
+		 * a lot of C compilers).
+		 */
+		for (tp = basic_types; tp->name != NULLST; tp++) {
+		    if (streq(tokenbuf, tp->name))
+			break;
+		}
+		if (tp->name == NULLST) {
+		    cerror("#if sizeof, unknown type \"%s\"", tokenbuf);
+		    return (OP_FAIL);
+		}
+		typecode |= tp->type;		/* Or in the type bit	*/
+	    }
+	}
+	/*
+	 * We are at the end of the type scan.  Chew off '*' if necessary.
+	 */
+	if (c == '*') {
+	    typecode |= T_PTR;
+	    c = skipws();
+	}
+	if (c == ')') {				/* Last syntax check	*/
+	    for (testp = test_table; *testp != 0; testp++) {
+		if (!bittest(typecode & *testp)) {
+		    cerror("#if ... sizeof: illegal type combination", NULLST);
+		    return (OP_FAIL);
+		}
+	    }
+	    /*
+	     * We assume that all function pointers are the same size:
+	     *		sizeof (int (*)()) == sizeof (float (*)())
+	     * We assume that signed and unsigned don't change the size:
+	     *		sizeof (signed int) == (sizeof unsigned int)
+	     */
+	    if ((typecode & T_FPTR) != 0)	/* Function pointer	*/
+		typecode = T_FPTR | T_PTR;
+	    else {				/* Var or var * datum	*/
+		typecode &= ~(T_SIGNED | T_UNSIGNED);
+		if ((typecode & (T_SHORT | T_LONG)) != 0)
+		    typecode &= ~T_INT;
+	    }
+	    if ((typecode & ~T_PTR) == 0) {
+		cerror("#if sizeof() error, no type specified", NULLST);
+		return (OP_FAIL);
+	    }
+	    /*
+	     * Exactly one bit (and possibly T_PTR) may be set.
+	     */
+	    for (sizp = size_table; sizp->bits != 0; sizp++) {
+		if ((typecode & ~T_PTR) == sizp->bits) {
+		    evalue = ((typecode & T_PTR) != 0)
+			? sizp->psize : sizp->size;
+		    return (DIG);
+		}
+	    }					/* We shouldn't fail	*/
+	    cierror("#if ... sizeof: bug, unknown type code 0x%x", typecode);
+	    return (OP_FAIL);
+	}
+
+nogood:	unget();
+	cerror("#if ... sizeof() syntax error", NULLST);
+	return (OP_FAIL);
+}
+
+FILE_LOCAL int
+bittest(value)
+/*
+ * TRUE if value is zero or exactly one bit is set in value.
+ */
+{
+#if (4096 & ~(-4096)) == 0
+	return ((value & ~(-value)) == 0);
+#else
+	/*
+	 * Do it the hard way (for non 2's complement machines)
+	 */
+	return (value == 0 || value ^ (value - 1) == (value * 2 - 1));
+#endif
+}
+
+FILE_LOCAL int
+evalnum(c)
+register int	c;
+/*
+ * Expand number for #if lexical analysis.  Note: evalnum recognizes
+ * the unsigned suffix, but only returns a signed int value.
+ */
+{
+	register int	value;
+	register int	base;
+	register int	c1;
+
+	if (c != '0')
+	    base = 10;
+	else if ((c = cget()) == 'x' || c == 'X') {
+		base = 16;
+		c = cget();
+	}
+	else base = 8;
+	value = 0;
+	for (;;) {
+	    c1 = c;
+	    if (isascii(c) && isupper(c1))
+		c1 = tolower(c1);
+	    if (c1 >= 'a')
+		c1 -= ('a' - 10);
+	    else c1 -= '0';
+	    if (c1 < 0 || c1 >= base)
+		break;
+	    value *= base;
+	    value += c1;
+	    c = cget();
+	}
+	if (c == 'u' || c == 'U')	/* Unsigned nonsense		*/
+	    c = cget();
+	unget();
+	return (value);
+}
+
+FILE_LOCAL int
+evalchar(skip)
+int		skip;		/* TRUE if short-circuit evaluation	*/
+/*
+ * Get a character constant
+ */
+{
+	register int	c;
+	register int	value;
+	register int	count;
+
+	instring = TRUE;
+	if ((c = cget()) == '\\') {
+	    switch ((c = cget())) {
+	    case 'a':				/* New in Standard	*/
+#if ('a' == '\a' || '\a' == ALERT)
+		value = ALERT;			/* Use predefined value	*/
+#else
+		value = '\a';			/* Use compiler's value	*/
+#endif
+		break;
+
+	    case 'b':
+		value = '\b';
+		break;
+
+	    case 'f':
+		value = '\f';
+		break;
+
+	    case 'n':
+		value = '\n';
+		break;
+
+	    case 'r':
+		value = '\r';
+		break;
+
+	    case 't':
+		value = '\t';
+		break;
+
+	    case 'v':				/* New in Standard	*/
+#if ('v' == '\v' || '\v' == VT)
+		value = VT;			/* Use predefined value	*/
+#else
+		value = '\v';			/* Use compiler's value	*/
+#endif
+		break;
+
+	    case 'x':				/* '\xFF'		*/
+		count = 3;
+		value = 0;
+		while ((((c = get()) >= '0' && c <= '9')
+		     || (c >= 'a' && c <= 'f')
+		     || (c >= 'A' && c <= 'F'))
+		    && (--count >= 0)) {
+			value *= 16;
+			value += (c <= '9') ? (c - '0') : ((c & 0xF) + 9);
+		}
+		unget();
+		break;
+
+	    default:
+		if (c >= '0' && c <= '7') {
+		    count = 3;
+		    value = 0;
+		    while (c >= '0' && c <= '7' && --count >= 0) {
+			value *= 8;
+			value += (c - '0');
+			c = get();
+		    }
+		    unget();
+		}
+		else value = c;
+		break;
+	    }
+	}
+	else if (c == '\'')
+	    value = 0;
+	else value = c;
+	/*
+	 * We warn on multi-byte constants and try to hack
+	 * (big|little)endian machines.
+	 */
+#if BIG_ENDIAN
+	count = 0;
+#endif
+	while ((c = get()) != '\'' && c != EOF_CHAR && c != '\n') {
+	    if (!skip)
+		ciwarn("multi-byte constant '%c' isn't portable", c);
+#if BIG_ENDIAN
+	    count += BITS_CHAR;
+	    value += (c << count);
+#else
+	    value <<= BITS_CHAR;
+	    value += c;
+#endif
+	}
+	instring = FALSE;
+	return (value);
+}
+
+FILE_LOCAL int *
+evaleval(valp, op, skip)
+register int	*valp;
+int		op;
+int		skip;		/* TRUE if short-circuit evaluation	*/
+/*
+ * Apply the argument operator to the data on the value stack.
+ * One or two values are popped from the value stack and the result
+ * is pushed onto the value stack.
+ *
+ * OP_COL is a special case.
+ *
+ * evaleval() returns the new pointer to the top of the value stack.
+ */
+{
+	register int	v1, v2;
+
+	if (isbinary(op))
+	    v2 = *--valp;
+	v1 = *--valp;
+#ifdef	DEBUG_EVAL
+	printf("%s op %s", (isbinary(op)) ? "binary" : "unary",
+	    opname[op]);
+	if (isbinary(op))
+	    printf(", v2 = %d.", v2);
+	printf(", v1 = %d.\n", v1);
+#endif
+	switch (op) {
+	case OP_EOE:
+	     break;
+
+	case OP_ADD:
+	    v1 += v2;
+	    break;
+
+	case OP_SUB:
+	    v1 -= v2;
+	    break;
+
+	case OP_MUL:
+	    v1 *= v2;
+	    break;
+
+	case OP_DIV:
+	case OP_MOD:
+	    if (v2 == 0) {
+		if (!skip) {
+		    cwarn("%s by zero in #if, zero result assumed",
+			(op == OP_DIV) ? "divide" : "mod");
+		}
+		v1 = 0;
+	    }
+	    else if (op == OP_DIV)
+		v1 /= v2;
+	    else
+		v1 %= v2;
+	    break;
+
+	case OP_ASL:
+	    v1 <<= v2;
+	    break;
+
+	case OP_ASR:
+	    v1 >>= v2;
+	    break;
+
+	case OP_AND:
+	    v1 &= v2;
+	    break;
+
+	case OP_OR:
+	    v1 |= v2;
+	    break;
+
+	case OP_XOR:
+	    v1 ^= v2;
+	    break;
+
+	case OP_EQ:
+	    v1 = (v1 == v2);
+	    break;
+
+	case OP_NE:
+	    v1 = (v1 != v2);
+	    break;
+
+	case OP_LT:
+	    v1 = (v1 < v2);
+	    break;
+
+	case OP_LE:
+	    v1 = (v1 <= v2);
+	    break;
+
+	case OP_GE:
+	    v1 = (v1 >= v2);
+	    break;
+
+	case OP_GT:
+	    v1 = (v1 > v2);
+	    break;
+
+	case OP_ANA:
+	    v1 = (v1 && v2);
+	    break;
+
+	case OP_ORO:
+	    v1 = (v1 || v2);
+	    break;
+
+	case OP_COL:
+	    /*
+	     * v1 has the "true" value, v2 the "false" value.
+	     * The top of the value stack has the test.
+	     */
+	    v1 = (*--valp) ? v1 : v2;
+	    break;
+
+	case OP_NEG:
+	    v1 = (-v1);
+	    break;
+
+	case OP_PLU:
+	    break;
+
+	case OP_COM:
+	    v1 = ~v1;
+	    break;
+
+	case OP_NOT:
+	    v1 = !v1;
+	    break;
+
+	default:
+	    cierror("#if bug, operand = %d.", op);
+	    v1 = 0;
+	}
+	*valp++ = v1;
+	return (valp);
+}
+
+#ifdef	DEBUG_EVAL
+dumpstack(opstack, opp, value, valp)
+OPTAB		opstack[NEXP];	/* Operand stack		*/
+register OPTAB	*opp;		/* Operator stack		*/
+int		value[NEXP];	/* Value stack			*/
+register int	*valp;		/* -> value vector		*/
+{
+	printf("index op prec skip name -- op stack at %s", infile->bptr);
+	while (opp > opstack) {
+	    printf(" [%2d] %2d  %03o    %d %s\n", opp - opstack,
+		opp->op, opp->prec, opp->skip, opname[opp->op]);
+	    opp--;
+	}
+	while (--valp >= value) {
+	    printf("value[%d] = %d\n", (valp - value), *valp);
+	}
+}
+#endif
+
diff --git a/cpp/cpp6.c b/cpp/cpp6.c
new file mode 100644
index 0000000..6d520f8
--- /dev/null
+++ b/cpp/cpp6.c
@@ -0,0 +1,996 @@
+/*
+ *			    C P P 6 . C
+ *		S u p p o r t   R o u t i n e s
+ *
+ * Edit History
+ * 25-May-84 MM		Added 8-bit support to type table.
+ * 30-May-84 ARF	sharp() should output filename in quotes
+ * 02-Aug-84 MM		Newline and #line hacking.  sharp() now in cpp1.c
+ * 31-Aug-84 MM		USENET net.sources release
+ * 11-Sep-84 ado/MM	Keepcomments, also line number pathological
+ * 12-Sep-84 ado/MM	bug if comment changes to space and we unget later.
+ * 03-Oct-84 gkr/MM	Fixed scannumber bug for '.e' (as in struct.element).
+ * 04-Oct-84 MM		Added ungetstring() for token concatenation
+ * 08-Oct-84 MM		Yet another attack on number scanning
+ * 31-Oct-84 ado	Parameterized $ in identifiers
+ *  2-Nov-84 MM		Token concatenation is messier than I thought
+ *  6-Dec-84 MM		\<nl> is everywhere invisible.
+ * 21-Oct-85 RMS	Rename `token' to `tokenbuf'.
+ *			Dynamically allocate it, and make it as big as needed.
+ * 23-Oct-85 RMS	Fix bugs storing into tokenbuf as it gets bigger.
+ * 			Change error msg to  cpp: "FILE", line LINE: MSG
+ * 24-Oct-85 RMS	Turn off warnings about /* inside a comment.
+ */
+
+#include	<stdio.h>
+#include	<ctype.h>
+#include	"cppdef.h"
+#include	"cpp.h"
+
+/*
+ * skipnl()	skips over input text to the end of the line.
+ * skipws()	skips over "whitespace" (spaces or tabs), but
+ *		not skip over the end of the line.  It skips over
+ *		TOK_SEP, however (though that shouldn't happen).
+ * scanid()	reads the next token (C identifier) into tokenbuf.
+ *		The caller has already read the first character of
+ *		the identifier.  Unlike macroid(), the token is
+ *		never expanded.
+ * macroid()	reads the next token (C identifier) into tokenbuf.
+ *		If it is a #defined macro, it is expanded, and
+ *		macroid() returns TRUE, otherwise, FALSE.
+ * catenate()	Does the dirty work of token concatenation, TRUE if it did.
+ * scanstring()	Reads a string from the input stream, calling
+ *		a user-supplied function for each character.
+ *		This function may be output() to write the
+ *		string to the output file, or save() to save
+ *		the string in the work buffer.
+ * scannumber()	Reads a C numeric constant from the input stream,
+ *		calling the user-supplied function for each
+ *		character.  (output() or save() as noted above.)
+ * save()	Save one character in the work[] buffer.
+ * savestring()	Saves a string in malloc() memory.
+ * getfile()	Initialize a new FILEINFO structure, called when
+ *		#include opens a new file, or a macro is to be
+ *		expanded.
+ * getmem()	Get a specified number of bytes from malloc memory.
+ * output()	Write one character to stdout (calling putchar) --
+ *		implemented as a function so its address may be
+ *		passed to scanstring() and scannumber().
+ * lookid()	Scans the next token (identifier) from the input
+ *		stream.  Looks for it in the #defined symbol table.
+ *		Returns a pointer to the definition, if found, or NULL
+ *		if not present.  The identifier is stored in tokenbuf.
+ * defnedel()	Define enter/delete subroutine.  Updates the
+ *		symbol table.
+ * get()	Read the next byte from the current input stream,
+ *		handling end of (macro/file) input and embedded
+ *		comments appropriately.  Note that the global
+ *		instring is -- essentially -- a parameter to get().
+ * cget()	Like get(), but skip over TOK_SEP.
+ * unget()	Push last gotten character back on the input stream.
+ * cerror(), cwarn(), cfatal(), cierror(), ciwarn()
+ *		These routines format an print messages to the user.
+ *		cerror & cwarn take a format and a single string argument.
+ *		cierror & ciwarn take a format and a single int (char) argument.
+ *		cfatal takes a format and a single string argument.
+ */
+
+/*
+ * This table must be rewritten for a non-Ascii machine.
+ *
+ * Note that several "non-visible" characters have special meaning:
+ * Hex 1D DEF_MAGIC -- a flag to prevent #define recursion.
+ * Hex 1E TOK_SEP   -- a delimiter for token concatenation
+ * Hex 1F COM_SEP   -- a zero-width whitespace for comment concatenation
+ */
+#if TOK_SEP != 0x1E || COM_SEP != 0x1F || DEF_MAGIC != 0x1D
+	<< error type table isn't correct >>
+#endif
+
+#if OK_DOLLAR
+#define	DOL	LET
+#else
+#define	DOL	000
+#endif
+
+char type[256] = {		/* Character type codes    Hex		*/
+   END,   000,   000,   000,   000,   000,   000,   000, /* 00		*/
+   000,   SPA,   000,   000,   000,   000,   000,   000, /* 08		*/
+   000,   000,   000,   000,   000,   000,   000,   000, /* 10		*/
+   000,   000,   000,   000,   000,   LET,   000,   SPA, /* 18		*/
+   SPA,OP_NOT,   QUO,   000,   DOL,OP_MOD,OP_AND,   QUO, /* 20  !"#$%&'	*/
+OP_LPA,OP_RPA,OP_MUL,OP_ADD,   000,OP_SUB,   DOT,OP_DIV, /* 28 ()*+,-./	*/
+   DIG,   DIG,   DIG,   DIG,   DIG,   DIG,   DIG,   DIG, /* 30 01234567	*/
+   DIG,   DIG,OP_COL,   000, OP_LT, OP_EQ, OP_GT,OP_QUE, /* 38 89:;<=>?	*/
+   000,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 40 @ABCDEFG	*/
+   LET,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 48 HIJKLMNO	*/
+   LET,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 50 PQRSTUVW	*/
+   LET,   LET,   LET,   000,   BSH,   000,OP_XOR,   LET, /* 58 XYZ[\]^_	*/
+   000,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 60 `abcdefg	*/
+   LET,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 68 hijklmno	*/
+   LET,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 70 pqrstuvw	*/
+   LET,   LET,   LET,   000, OP_OR,   000,OP_NOT,   000, /* 78 xyz{|}~	*/
+   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
+   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
+   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
+   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
+   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
+   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
+   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
+   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
+};
+
+skipnl()
+/*
+ * Skip to the end of the current input line.
+ */
+{
+	register int		c;
+
+	do {				/* Skip to newline	*/
+	    c = get();
+	} while (c != '\n' && c != EOF_CHAR);
+}
+
+int
+skipws()
+/*
+ * Skip over whitespace
+ */
+{
+	register int		c;
+
+	do {				/* Skip whitespace	*/
+	    c = get();
+#if COMMENT_INVISIBLE
+	} while (type[c] == SPA || c == COM_SEP);
+#else
+	} while (type[c] == SPA);
+#endif
+	return (c);
+}
+
+scanid(c)
+register int	c;				/* First char of id	*/
+/*
+ * Get the next token (an id) into the token buffer.
+ * Note: this code is duplicated in lookid().
+ * Change one, change both.
+ */
+{
+	register int ct;
+
+	if (c == DEF_MAGIC)			/* Eat the magic token	*/
+	    c = get();				/* undefiner.		*/
+	ct = 0;
+	do
+	  {
+	    if (ct == tokenbsize)
+	      tokenbuf = incmem (tokenbuf, 1 + (tokenbsize *= 2));
+	    tokenbuf[ct++] = c;
+	    c = get();
+	  }
+	while (type[c] == LET || type[c] == DIG);
+	unget();
+	tokenbuf[ct] = EOS;
+}
+
+int
+macroid(c)
+register int		c;
+/*
+ * If c is a letter, scan the id.  if it's #defined, expand it and scan
+ * the next character and try again.
+ *
+ * Else, return the character.  If type[c] is a LET, the token is in tokenbuf.
+ */
+{
+	register DEFBUF	*dp;
+
+	if (infile != NULL && infile->fp != NULL)
+	    recursion = 0;
+	while (type[c] == LET && (dp = lookid(c)) != NULL) {
+	    expand(dp);
+	    c = get();
+	}
+	return (c);
+}
+
+int
+catenate()
+/*
+ * A token was just read (via macroid).
+ * If the next character is TOK_SEP, concatenate the next token
+ * return TRUE -- which should recall macroid after refreshing
+ * macroid's argument.  If it is not TOK_SEP, unget() the character
+ * and return FALSE.
+ */
+{
+	register int		c;
+	register char		*token1;
+
+#if OK_CONCAT
+	if (get() != TOK_SEP) {			/* Token concatenation	*/
+	    unget();
+	    return (FALSE);
+	}
+	else {
+	    token1 = savestring(tokenbuf);	/* Save first token	*/
+	    c = macroid(get());			/* Scan next token	*/
+	    switch(type[c]) {			/* What was it?		*/
+	    case LET:				/* An identifier, ...	*/
+		if (strlen(token1) + strlen(tokenbuf) >= NWORK)
+		    cfatal("work buffer overflow doing %s #", token1);
+		sprintf(work, "%s%s", token1, tokenbuf);
+		break;
+
+	    case DIG:				/* A digit string	*/
+		strcpy(work, token1);
+		workp = work + strlen(work);
+		do {
+		    save(c);
+		} while ((c = get()) != TOK_SEP);
+		/*
+		 * The trailing TOK_SEP is no longer needed.
+		 */
+		save(EOS);
+		break;
+
+	    default:				/* An error, ...	*/
+		if (isprint(c))
+		    cierror("Strange character '%c' after #", c);
+		else
+		    cierror("Strange character (%d.) after #", c);
+		strcpy(work, token1);
+		unget();
+		break;
+	    }
+	    /*
+	     * work has the concatenated token and token1 has
+	     * the first token (no longer needed).  Unget the
+	     * new (concatenated) token after freeing token1.
+	     * Finally, setup to read the new token.
+	     */
+	    free(token1);			/* Free up memory	*/
+	    ungetstring(work);			/* Unget the new thing,	*/
+	    return (TRUE);
+	}
+#else
+	return (FALSE);				/* Not supported	*/
+#endif
+}
+
+int
+scanstring(delim, outfun)
+register int	delim;			/* ' or "			*/
+int		(*outfun)();		/* Output function		*/
+/*
+ * Scan off a string.  Warning if terminated by newline or EOF.
+ * outfun() outputs the character -- to a buffer if in a macro.
+ * TRUE if ok, FALSE if error.
+ */
+{
+	register int		c;
+
+	instring = TRUE;		/* Don't strip comments		*/
+	(*outfun)(delim);
+	while ((c = get()) != delim
+	     && c != '\n'
+	     && c != EOF_CHAR) {
+	    (*outfun)(c);
+	    if (c == '\\')
+		(*outfun)(get());
+	}
+	instring = FALSE;
+	if (c == delim) {
+	    (*outfun)(c);
+	    return (TRUE);
+	}
+	else {
+	    cerror("Unterminated string", NULLST);
+	    unget();
+	    return (FALSE);
+	}
+}
+
+scannumber(c, outfun)
+register int	c;				/* First char of number	*/
+register int	(*outfun)();			/* Output/store func	*/
+/*
+ * Process a number.  We know that c is from 0 to 9 or dot.
+ * Algorithm from Dave Conroy's Decus C.
+ */
+{
+	register int	radix;			/* 8, 10, or 16		*/
+	int		expseen;		/* 'e' seen in floater	*/
+	int		signseen;		/* '+' or '-' seen	*/
+	int		octal89;		/* For bad octal test	*/
+	int		dotflag;		/* TRUE if '.' was seen	*/
+
+	expseen = FALSE;			/* No exponent seen yet	*/
+	signseen = TRUE;			/* No +/- allowed yet	*/
+	octal89 = FALSE;			/* No bad octal yet	*/
+	radix = 10;				/* Assume decimal	*/
+	if ((dotflag = (c == '.')) != FALSE) {	/* . something?		*/
+	    (*outfun)('.');			/* Always out the dot	*/
+	    if (type[(c = get())] != DIG) {	/* If not a float numb,	*/
+		unget();			/* Rescan strange char	*/
+		return;				/* All done for now	*/
+	    }
+	}					/* End of float test	*/
+	else if (c == '0') {			/* Octal or hex?	*/
+	    (*outfun)(c);			/* Stuff initial zero	*/
+	    radix = 8;				/* Assume it's octal	*/
+	    c = get();				/* Look for an 'x'	*/
+	    if (c == 'x' || c == 'X') {		/* Did we get one?	*/
+		radix = 16;			/* Remember new radix	*/
+		(*outfun)(c);			/* Stuff the 'x'	*/
+		c = get();			/* Get next character	*/
+	    }
+	}
+	for (;;) {				/* Process curr. char.	*/
+	    /*
+	     * Note that this algorithm accepts "012e4" and "03.4"
+	     * as legitimate floating-point numbers.
+	     */
+	    if (radix != 16 && (c == 'e' || c == 'E')) {
+		if (expseen)			/* Already saw 'E'?	*/
+		    break;			/* Exit loop, bad nbr.	*/
+		expseen = TRUE;			/* Set exponent seen	*/
+		signseen = FALSE;		/* We can read '+' now	*/
+		radix = 10;			/* Decimal exponent	*/
+	    }
+	    else if (radix != 16 && c == '.') {
+		if (dotflag)			/* Saw dot already?	*/
+		    break;			/* Exit loop, two dots	*/
+		dotflag = TRUE;			/* Remember the dot	*/
+		radix = 10;			/* Decimal fraction	*/
+	    }
+	    else if (c == '+' || c == '-') {	/* 1.0e+10		*/
+		if (signseen)			/* Sign in wrong place?	*/
+		    break;			/* Exit loop, not nbr.	*/
+		/* signseen = TRUE; */		/* Remember we saw it	*/
+	    }
+	    else {				/* Check the digit	*/
+		switch (c) {
+		case '8': case '9':		/* Sometimes wrong	*/
+		    octal89 = TRUE;		/* Do check later	*/
+		case '0': case '1': case '2': case '3':
+		case '4': case '5': case '6': case '7':
+		    break;			/* Always ok		*/
+
+		case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+		case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+		    if (radix == 16)		/* Alpha's are ok only 	*/
+			break;			/* if reading hex.	*/
+		default:			/* At number end	*/
+		    goto done;			/* Break from for loop	*/
+		}				/* End of switch	*/
+	    }					/* End general case	*/
+	    (*outfun)(c);			/* Accept the character	*/
+	    signseen = TRUE;			/* Don't read sign now	*/
+	    c = get();				/* Read another char	*/
+	}					/* End of scan loop	*/
+	/*
+	 * When we break out of the scan loop, c contains the first
+	 * character (maybe) not in the number.  If the number is an
+	 * integer, allow a trailing 'L' for long and/or a trailing 'U'
+	 * for unsigned.  If not those, push the trailing character back
+	 * on the input stream.  Floating point numbers accept a trailing
+	 * 'L' for "long double".
+	 */
+done:	if (dotflag || expseen) {		/* Floating point?	*/
+	    if (c == 'l' || c == 'L') {
+		(*outfun)(c);
+		c = get();			/* Ungotten later	*/
+	    }
+	}
+	else {					/* Else it's an integer	*/
+	    /*
+	     * We know that dotflag and expseen are both zero, now:
+	     * dotflag signals "saw 'L'", and
+	     * expseen signals "saw 'U'".
+	     */
+	    for (;;) {
+		switch (c) {
+		case 'l':
+		case 'L':
+		    if (dotflag)
+			goto nomore;
+		    dotflag = TRUE;
+		    break;
+
+		case 'u':
+		case 'U':
+		    if (expseen)
+			goto nomore;
+		    expseen = TRUE;
+		    break;
+
+		default:
+		    goto nomore;
+		}
+		(*outfun)(c);			/* Got 'L' or 'U'.	*/
+		c = get();			/* Look at next, too.	*/
+	    }
+	}
+nomore:	unget();				/* Not part of a number	*/
+	if (octal89 && radix == 8)
+	    cwarn("Illegal digit in octal number", NULLST);
+}
+
+save(c)
+register int	c;
+{
+	if (workp >= &work[NWORK])
+	    cfatal("Work buffer overflow", NULLST);
+	else *workp++ = c;
+}
+
+char *
+savestring(text)
+char		*text;
+/*
+ * Store a string into free memory.
+ */
+{
+	register char	*result;
+
+	result = getmem(strlen(text) + 1);
+	strcpy(result, text);
+	return (result);
+}
+
+FILEINFO	*
+getfile(bufsize, name)
+int		bufsize;		/* Line or define buffer size	*/
+char		*name;			/* File or macro name string	*/
+/*
+ * Common FILEINFO buffer initialization for a new file or macro.
+ */
+{
+	register FILEINFO	*file;
+	register int		size;
+
+	size = strlen(name);			/* File/macro name	*/
+	file = (FILEINFO *) getmem(sizeof (FILEINFO) + bufsize + size);
+	file->parent = infile;			/* Chain files together	*/
+	file->fp = NULL;			/* No file yet		*/
+	file->filename = savestring(name);	/* Save file/macro name	*/
+	file->progname = NULL;			/* No #line seen yet	*/
+	file->unrecur = 0;			/* No macro fixup	*/
+	file->bptr = file->buffer;		/* Initialize line ptr	*/
+	file->buffer[0] = EOS;			/* Force first read	*/
+	file->line = 0;				/* (Not used just yet)	*/
+	if (infile != NULL)			/* If #include file	*/
+	    infile->line = line;		/* Save current line	*/
+	infile = file;				/* New current file	*/
+	line = 1;				/* Note first line	*/
+	return (file);				/* All done.		*/
+}
+
+char *
+getmem(size)
+int		size;
+/*
+ * Get a block of free memory.
+ */
+{
+	register char	*result;
+	extern char	*malloc();
+
+	if ((result = malloc((unsigned) size)) == NULL)
+	    cfatal("Out of memory", NULLST);
+	return (result);
+}
+
+char *
+incmem(obj,size)
+char		*obj;
+int		size;
+/*
+ * Get a block of free memory.
+ */
+{
+	register char	*result;
+	extern char	*realloc();
+
+	if ((result = realloc(obj, (unsigned) size)) == NULL)
+	    cfatal("Out of memory", NULLST);
+	return (result);
+}
+
+/*
+ *			C P P   S y m b o l   T a b l e s
+ */
+
+/*
+ * SBSIZE defines the number of hash-table slots for the symbol table.
+ * It must be a power of 2.
+ */
+#ifndef	SBSIZE
+#define	SBSIZE	64
+#endif
+#define	SBMASK	(SBSIZE - 1)
+#if (SBSIZE ^ SBMASK) != ((SBSIZE * 2) - 1)
+	<< error, SBSIZE must be a power of 2 >>
+#endif
+
+static DEFBUF	*symtab[SBSIZE];	/* Symbol table queue headers	*/
+
+DEFBUF *
+lookid(c)
+int	c;				/* First character of token	*/
+/*
+ * Look for the next token in the symbol table.  Returns token in tokenbuf.
+ * If found, returns the table pointer;  Else returns NULL.
+ */
+{
+	register int		nhash;
+	register DEFBUF		*dp;
+	register int		ct;
+	int			temp;
+	int			isrecurse;	/* For #define foo foo	*/
+
+	nhash = 0;
+	if ((isrecurse = (c == DEF_MAGIC)))	/* If recursive macro	*/
+	    c = get();				/* hack, skip DEF_MAGIC	*/
+	ct = 0;
+	do
+	  {
+	    if (ct == tokenbsize)
+	      tokenbuf = incmem(tokenbuf, 1 + (tokenbsize *= 2));
+	    tokenbuf[ct++] = c;		/* Store token byte	*/
+	    nhash += c;			/* Update hash value	*/
+	    c = get();
+	  }
+	while (type[c] == LET || type[c] == DIG);
+	unget();				/* Rescan terminator	*/
+	tokenbuf[ct] = EOS;			/* Terminate token	*/
+	if (isrecurse)				/* Recursive definition	*/
+	    return (NULL);			/* undefined just now	*/
+	nhash += ct;				/* Fix hash value	*/
+	dp = symtab[nhash & SBMASK];		/* Starting bucket	*/
+	while (dp != (DEFBUF *) NULL) {		/* Search symbol table	*/
+	    if (dp->hash == nhash		/* Fast precheck	*/
+	     && (temp = strcmp(dp->name, tokenbuf)) >= 0)
+		break;
+	    dp = dp->link;			/* Nope, try next one	*/
+	}
+	return ((temp == 0) ? dp : NULL);
+}
+
+DEFBUF *
+defendel(name, delete)
+char		*name;
+int		delete;			/* TRUE to delete a symbol	*/
+/*
+ * Enter this name in the lookup table (delete = FALSE)
+ * or delete this name (delete = TRUE).
+ * Returns a pointer to the define block (delete = FALSE)
+ * Returns NULL if the symbol wasn't defined (delete = TRUE).
+ */
+{
+	register DEFBUF		*dp;
+	register DEFBUF		**prevp;
+	register char		*np;
+	int			nhash;
+	int			temp;
+	int			size;
+
+	for (nhash = 0, np = name; *np != EOS;)
+	    nhash += *np++;
+	size = (np - name);
+	nhash += size;
+	prevp = &symtab[nhash & SBMASK];
+	while ((dp = *prevp) != (DEFBUF *) NULL) {
+	    if (dp->hash == nhash
+	     && (temp = strcmp(dp->name, name)) >= 0) {
+		if (temp > 0)
+		    dp = NULL;			/* Not found		*/
+		else {
+		    *prevp = dp->link;		/* Found, unlink and	*/
+		    if (dp->repl != NULL)	/* Free the replacement	*/
+			free(dp->repl);		/* if any, and then	*/
+		    free((char *) dp);		/* Free the symbol	*/
+		}
+		break;
+	    }
+	    prevp = &dp->link;
+	}
+	if (!delete) {
+	    dp = (DEFBUF *) getmem(sizeof (DEFBUF) + size);
+	    dp->link = *prevp;
+	    *prevp = dp;
+	    dp->hash = nhash;
+	    dp->repl = NULL;
+	    dp->nargs = 0;
+	    strcpy(dp->name, name);
+	}
+	return (dp);
+}
+
+#if DEBUG
+
+dumpdef(why)
+char		*why;
+{
+	register DEFBUF		*dp;
+	register DEFBUF		**syp;
+
+	printf("CPP symbol table dump %s\n", why);
+	for (syp = symtab; syp < &symtab[SBSIZE]; syp++) {
+	    if ((dp = *syp) != (DEFBUF *) NULL) {
+		printf("symtab[%d]\n", (syp - symtab));
+		do {
+		    dumpadef((char *) NULL, dp);
+		} while ((dp = dp->link) != (DEFBUF *) NULL);
+	    }
+	}
+}
+
+dumpadef(why, dp)
+char		*why;			/* Notation			*/
+register DEFBUF	*dp;
+{
+	register char		*cp;
+	register int		c;
+
+	printf(" \"%s\" [%d]", dp->name, dp->nargs);
+	if (why != NULL)
+	    printf(" (%s)", why);
+	if (dp->repl != NULL) {
+	    printf(" => ");
+	    for (cp = dp->repl; (c = *cp++ & 0xFF) != EOS;) {
+		if (c >= MAC_PARM && c <= (MAC_PARM + PAR_MAC))
+		    printf("<%d>", c - MAC_PARM);
+		else if (isprint(c) || c == '\n' || c == '\t')
+		    putchar(c);
+		else if (c < ' ')
+		    printf("<^%c>", c + '@');
+		else
+		    printf("<\\0%o>", c);
+	    }
+	}
+	else {
+	    printf(", no replacement.");
+	}
+	putchar('\n');
+}
+#endif
+
+/*
+ *			G E T
+ */
+
+int
+get()
+/*
+ * Return the next character from a macro or the current file.
+ * Handle end of file from #include files.
+ */
+{
+	register int		c;
+	register FILEINFO	*file;
+	register int		popped;		/* Recursion fixup	*/
+
+	popped = 0;
+get_from_file:
+	if ((file = infile) == NULL)
+	    return (EOF_CHAR);
+newline:
+#if 0
+	printf("get(%s), recursion %d, line %d, bptr = %d, buffer \"%s\"\n",
+	    file->filename, recursion, line,
+	    file->bptr - file->buffer, file->buffer);
+#endif
+	/*
+	 * Read a character from the current input line or macro.
+	 * At EOS, either finish the current macro (freeing temp.
+	 * storage) or read another line from the current input file.
+	 * At EOF, exit the current file (#include) or, at EOF from
+	 * the cpp input file, return EOF_CHAR to finish processing.
+	 */
+	if ((c = *file->bptr++ & 0xFF) == EOS) {
+	    /*
+	     * Nothing in current line or macro.  Get next line (if
+	     * input from a file), or do end of file/macro processing.
+	     * In the latter case, jump back to restart from the top.
+	     */
+	    if (file->fp == NULL) {		/* NULL if macro	*/
+		popped++;
+		recursion -= file->unrecur;
+		if (recursion < 0)
+		    recursion = 0;
+		infile = file->parent;		/* Unwind file chain	*/
+	    }
+	    else {				/* Else get from a file	*/
+		if ((file->bptr = fgets(file->buffer, NBUFF, file->fp))
+			!= NULL) {
+#if DEBUG
+		    if (debug > 1) {		/* Dump it to stdout	*/
+			printf("\n#line %d (%s), %s",
+			    line, file->filename, file->buffer);
+		    }
+#endif
+		    goto newline;		/* process the line	*/
+		}
+		else {
+		    fclose(file->fp);		/* Close finished file	*/
+		    if ((infile = file->parent) != NULL) {
+			/*
+			 * There is an "ungotten" newline in the current
+			 * infile buffer (set there by doinclude() in
+			 * cpp1.c).  Thus, we know that the mainline code
+			 * is skipping over blank lines and will do a
+			 * #line at its convenience.
+			 */
+			wrongline = TRUE;	/* Need a #line now	*/
+		    }
+		}
+	    }
+	    /*
+	     * Free up space used by the (finished) file or macro and
+	     * restart input from the parent file/macro, if any.
+	     */
+	    free(file->filename);		/* Free name and	*/
+	    if (file->progname != NULL)		/* if a #line was seen,	*/
+		free(file->progname);		/* free it, too.	*/
+	    free((char *) file);		/* Free file space	*/
+	    if (infile == NULL)			/* If at end of file	*/
+		return (EOF_CHAR);		/* Return end of file	*/
+	    line = infile->line; 		/* Reset line number	*/
+	    goto get_from_file;			/* Get from the top.	*/
+	}
+	/*
+	 * Common processing for the new character.
+	 */
+	if (c == DEF_MAGIC && file->fp != NULL)	/* Don't allow delete	*/
+	    goto newline;			/* from a file		*/
+	if (file->parent != NULL) {		/* Macro or #include	*/
+	    if (popped != 0)
+		file->parent->unrecur += popped;
+	    else {
+		recursion -= file->parent->unrecur;
+		if (recursion < 0)
+		    recursion = 0;
+		file->parent->unrecur = 0;
+	    }
+	}
+	if (c == '\n')				/* Maintain current	*/
+	    ++line;				/* line counter		*/
+	if (instring)				/* Strings just return	*/
+	    return (c);				/* the character.	*/
+	else if (c == '/') {			/* Comment?		*/
+	    instring = TRUE;			/* So get() won't loop	*/
+	    if ((c = get()) != '*') {		/* Next byte '*'?	*/
+		instring = FALSE;		/* Nope, no comment	*/
+		unget();			/* Push the char. back	*/
+		return ('/');			/* Return the slash	*/
+	    }
+	    if (keepcomments) {			/* If writing comments	*/
+		putchar('/');			/* Write out the	*/
+		putchar('*');			/*   initializer	*/
+	    }
+	    for (;;) {				/* Eat a comment	*/
+		c = get();
+test:		if (keepcomments && c != EOF_CHAR)
+		    cput(c);
+		switch (c) {
+		case EOF_CHAR:
+		    cerror("EOF in comment", NULLST);
+		    return (EOF_CHAR);
+
+#ifdef NOTDEF
+		case '/':
+		    if ((c = get()) != '*')	/* Don't let comments	*/
+			goto test;		/* Nest.		*/
+		    cwarn("Nested comments", NULLST);
+#endif /* NOTDEF */
+						/* Fall into * stuff	*/
+		case '*':
+		    if ((c = get()) != '/')	/* If comment doesn't	*/
+			goto test;		/* end, look at next	*/
+		    instring = FALSE;		/* End of comment,	*/
+		    if (keepcomments) {		/* Put out the comment	*/
+			cput(c);		/* terminator, too	*/
+		    }
+		    /*
+		     * A comment is syntactically "whitespace" --
+		     * however, there are certain strange sequences
+		     * such as
+		     *		#define foo(x)	(something)
+		     *			foo|* comment *|(123)
+		     *       these are '/' ^           ^
+		     * where just returning space (or COM_SEP) will cause
+		     * problems.  This can be "fixed" by overwriting the
+		     * '/' in the input line buffer with ' ' (or COM_SEP)
+		     * but that may mess up an error message.
+		     * So, we peek ahead -- if the next character is
+		     * "whitespace" we just get another character, if not,
+		     * we modify the buffer.  All in the name of purity.
+		     */
+		    if (*file->bptr == '\n'
+		     || type[*file->bptr & 0xFF] == SPA)
+			goto newline;
+#if COMMENT_INVISIBLE
+		    /*
+		     * Return magic (old-fashioned) syntactic space.
+		     */
+		    return ((file->bptr[-1] = COM_SEP));
+#else
+		    return ((file->bptr[-1] = ' '));
+#endif
+
+		case '\n':			/* we'll need a #line	*/
+		    if (!keepcomments)
+			wrongline = TRUE;	/* later...		*/
+		default:			/* Anything else is	*/
+		    break;			/* Just a character	*/
+		}				/* End switch		*/
+	    }					/* End comment loop	*/
+	}					/* End if in comment	*/
+	else if (!inmacro && c == '\\') {	/* If backslash, peek 	*/
+	    if ((c = get()) == '\n') {		/* for a <nl>.  If so,	*/
+		wrongline = TRUE;
+		goto newline;
+	    }
+	    else {				/* Backslash anything	*/
+		unget();			/* Get it later		*/
+		return ('\\');			/* Return the backslash	*/
+	    }
+	}
+	else if (c == '\f' || c == VT)		/* Form Feed, Vertical	*/
+	    c = ' ';				/* Tab are whitespace	*/
+	return (c);				/* Just return the char	*/
+}
+
+unget()
+/*
+ * Backup the pointer to reread the last character.  Fatal error
+ * (code bug) if we backup too far.  unget() may be called,
+ * without problems, at end of file.  Only one character may
+ * be ungotten.  If you need to unget more, call ungetstring().
+ */
+{
+	register FILEINFO	*file;
+
+	if ((file = infile) == NULL)
+	    return;			/* Unget after EOF		*/
+	if (--file->bptr < file->buffer)
+	    cfatal("Too much pushback", NULLST);
+	if (*file->bptr == '\n')	/* Ungetting a newline?		*/
+	    --line;			/* Unget the line number, too	*/
+}
+
+ungetstring(text)
+char		*text;
+/*
+ * Push a string back on the input stream.  This is done by treating
+ * the text as if it were a macro.
+ */
+{
+	register FILEINFO	*file;
+	extern FILEINFO		*getfile();
+
+	file = getfile(strlen(text) + 1, "");
+	strcpy(file->buffer, text);
+}
+
+int
+cget()
+/*
+ * Get one character, absorb "funny space" after comments or
+ * token concatenation
+ */
+{
+	register int	c;
+
+	do {
+	    c = get();
+#if COMMENT_INVISIBLE
+	} while (c == TOK_SEP || c == COM_SEP);
+#else
+	} while (c == TOK_SEP);
+#endif
+	return (c);
+}
+
+/*
+ * Error messages and other hacks.  The first byte of severity
+ * is 'S' for string arguments and 'I' for int arguments.  This
+ * is needed for portability with machines that have int's that
+ * are shorter than  char *'s.
+ */
+
+static
+domsg(severity, format, arg)
+char		*severity;		/* "Error", "Warning", "Fatal"	*/
+char		*format;		/* Format for the error message	*/
+char		*arg;			/* Something for the message	*/
+/*
+ * Print filenames, macro names, and line numbers for error messages.
+ */
+{
+	register char		*tp;
+	register FILEINFO	*file;
+
+	for (file = infile; file && !file->fp; file = file->parent)
+	  ;
+	tp = file ? file->filename : 0;
+	fprintf (stderr, "%s\"%s\", line %d: %s: ",
+		 MSG_PREFIX, tp, line, &severity[1]);
+	if (*severity == 'S')
+	  fprintf(stderr, format, arg);
+	else
+	  fprintf(stderr, format, (int) arg);
+	putc('\n', stderr);
+
+	while ((file = file->parent) != NULL) {	/* Print #includes, too	*/
+	    tp = file->parent ? "," : ".";
+	    if (file->fp == NULL)
+		fprintf(stderr, " from macro %s%s\n", file->filename, tp);
+	    else {
+		fprintf(stderr, " from file %s, line %d%s\n",
+		    (file->progname != NULL)
+			? file->progname : file->filename,
+		    file->line, tp);
+	    }
+	}
+}
+
+cerror(format, sarg)
+char		*format;
+char		*sarg;		/* Single string argument		*/
+/*
+ * Print a normal error message, string argument.
+ */
+{
+	domsg("SError", format, sarg);
+	errors++;
+}
+
+cierror(format, narg)
+char		*format;
+int		narg;		/* Single numeric argument		*/
+/*
+ * Print a normal error message, numeric argument.
+ */
+{
+	domsg("IError", format, (char *) narg);
+	errors++;
+}
+
+cfatal(format, sarg)
+char		*format;
+char		*sarg;			/* Single string argument	*/
+/*
+ * A real disaster
+ */
+{
+	domsg("SFatal error", format, sarg);
+	exit(IO_ERROR);
+}
+
+cwarn(format, sarg)
+char		*format;
+char		*sarg;			/* Single string argument	*/
+/*
+ * A non-fatal error, string argument.
+ */
+{
+	domsg("SWarning", format, sarg);
+}
+
+ciwarn(format, narg)
+char		*format;
+int		narg;			/* Single numeric argument	*/
+/*
+ * A non-fatal error, numeric argument.
+ */
+{
+	domsg("IWarning", format, (char *) narg);
+}
+
+
diff --git a/cpp/cppdef.h b/cpp/cppdef.h
new file mode 100644
index 0000000..a2ef0df
--- /dev/null
+++ b/cpp/cppdef.h
@@ -0,0 +1,385 @@
+#ifdef EMACS
+
+/* Use the Emacs config file to find out what type of machine */
+
+#define NO_SHORTNAMES
+#include "../src/config.h"
+
+/* Convert Emacs's conventions for BIG_ENDIAN to cpp's convention.  */
+#ifdef BIG_ENDIAN
+#undef BIG_ENDIAN
+#define BIG_ENDIAN TRUE
+#else /* not BIG_ENDIAN */
+#define BIG_ENDIAN FALSE
+#endif /* BIG_ENDIAN */
+
+/* Emacs uses the names index and rindex and defines them as str(r)chr if nec;
+   cpp uses the opposite convention.  Here we flush the macro definitions for
+   Emacs and add the ones cpp wants.  */
+
+#ifdef index
+#undef index
+#undef rindex
+#else /* index is not defined as a macro */
+#define strchr index
+#define strrchr rindex
+#endif /* index is not defined as a macro */
+
+#define NBUFF 2048
+#define NWORK 2048
+
+#endif /* EMACS */
+
+/*
+ *		   S y s t e m   D e p e n d e n t
+ *		D e f i n i t i o n s    f o r   C P P
+ *
+ * Definitions in this file may be edited to configure CPP for particular
+ * host operating systems and target configurations.
+ *
+ * NOTE: cpp assumes it is compiled by a compiler that supports macros
+ * with arguments.  If this is not the case (as for Decus C), #define
+ * nomacarg -- and provide function equivalents for all macros.
+ *
+ * cpp also assumes the host and target implement the Ascii character set.
+ * If this is not the case, you will have to do some editing here and there.
+ */
+
+/*
+ * This redundant definition of TRUE and FALSE works around
+ * a limitation of Decus C.
+ */
+#ifndef	TRUE
+#define	TRUE			1
+#define	FALSE			0
+#endif
+
+/*
+ * Define the HOST operating system.  This is needed so that
+ * cpp can use appropriate filename conventions.
+ */
+#define	SYS_UNKNOWN		0
+#define	SYS_UNIX		1
+#define	SYS_VMS			2
+#define	SYS_RSX			3
+#define	SYS_RT11		4
+#define	SYS_LATTICE		5
+#define	SYS_ONYX		6
+#define	SYS_68000		7
+
+#define HOST SYS_UNIX
+
+#ifndef	HOST
+#ifdef	unix
+#define	HOST			SYS_UNIX
+#else
+#ifdef	vms
+#define	HOST			SYS_VMS
+#else
+#ifdef	rsx
+#define	HOST			SYS_RSX
+#else
+#ifdef	rt11
+#define	HOST			SYS_RT11
+#endif
+#endif
+#endif
+#endif
+#endif
+
+#ifndef	HOST
+#define	HOST			SYS_UNKNOWN
+#endif
+
+/*
+ * We assume that the target is the same as the host system
+ */
+#ifndef	TARGET
+#define	TARGET			HOST
+#endif
+
+/*
+ * In order to predefine machine-dependent constants,
+ * several strings are defined here:
+ *
+ * MACHINE	defines the target cpu (by name)
+ * SYSTEM	defines the target operating system
+ * COMPILER	defines the target compiler
+ *
+ *	The above may be #defined as "" if they are not wanted.
+ *	They should not be #defined as NULL.
+ *
+ * LINE_PREFIX	defines the # output line prefix, if not "line"
+ *		This should be defined as "" if cpp is to replace
+ *		the "standard" C pre-processor.
+ *
+ * FILE_LOCAL	marks functions which are referenced only in the
+ *		file they reside.  Some C compilers allow these
+ *		to be marked "static" even though they are referenced
+ *		by "extern" statements elsewhere.
+ *
+ * OK_DOLLAR	Should be set TRUE if $ is a valid alphabetic character
+ *		in identifiers (default), or zero if $ is invalid.
+ *		Default is TRUE.
+ *
+ * OK_CONCAT	Should be set TRUE if # may be used to concatenate
+ *		tokens in macros (per the Ansi Draft Standard) or
+ *		FALSE for old-style # processing (needed if cpp is
+ *		to process assembler source code).
+ *
+ * OK_DATE	Predefines the compilation date if set TRUE.
+ *		Not permitted by the Nov. 12, 1984 Draft Standard.
+ *
+ * S_CHAR etc.	Define the sizeof the basic TARGET machine word types.
+ *		By default, sizes are set to the values for the HOST
+ *		computer.  If this is inappropriate, see the code in
+ *		cpp3.c for details on what to change.  Also, if you
+ *		have a machine where sizeof (signed int) differs from
+ *		sizeof (unsigned int), you will have to edit code and
+ *		tables in cpp3.c (and extend the -S option definition.)
+ *
+ * CPP_LIBRARY	May be defined if you have a site-specific include directory
+ *		which is to be searched *before* the operating-system
+ *		specific directories.
+ */
+
+#if TARGET == SYS_LATTICE
+/*
+ * We assume the operating system is pcdos for the IBM-PC.
+ * We also assume the small model (just like the PDP-11)
+ */
+#define MACHINE			"i8086"
+#define	SYSTEM			"pcdos"
+#endif
+
+#if TARGET == SYS_ONYX
+#define	MACHINE			"z8000"
+#define	SYSTEM			"unix"
+#endif
+
+#if TARGET == SYS_VMS
+#define	MACHINE			"vax"
+#define	SYSTEM			"vms"
+#define	COMPILER		"vax11c"
+#endif
+
+#if TARGET == SYS_RSX
+#define	MACHINE			"pdp11"
+#define	SYSTEM			"rsx"
+#define	COMPILER		"decus"
+#endif
+
+#if TARGET == SYS_RT11
+#define	MACHINE			"pdp11"
+#define	SYSTEM			"rt11"
+#define	COMPILER		"decus"
+#endif
+
+#if TARGET == SYS_68000
+/*
+ * All three machine designators have been seen in various systems.
+ * Warning -- compilers differ as to sizeof (int).  cpp3 assumes that
+ * sizeof (int) == 2
+ */
+#define	MACHINE			"M68000", "m68000", "m68k"
+#define	SYSTEM			"unix"
+#endif
+
+#if	TARGET == SYS_UNIX
+#define	SYSTEM			"unix"
+#ifdef	pdp11
+#define	MACHINE			"pdp11"
+#endif
+#ifdef	vax
+#define	MACHINE			"vax"
+#endif
+#endif
+
+/*
+ * defaults
+ */
+
+#ifndef MSG_PREFIX
+#define MSG_PREFIX		"cpp: "
+#endif
+
+#ifndef LINE_PREFIX
+#ifdef	decus
+#define	LINE_PREFIX		""
+#else
+#define LINE_PREFIX		"line"
+#endif
+#endif
+
+/*
+ * OLD_PREPROCESSOR forces the definition of OK_DOLLAR, OK_CONCAT,
+ * COMMENT_INVISIBLE, and STRING_FORMAL to values appropriate for
+ * an old-style preprocessor.
+ */
+
+#if	OLD_PREPROCESSOR
+#define	OK_DOLLAR		FALSE
+#define	OK_CONCAT		FALSE
+#define	COMMENT_INVISIBLE	TRUE
+#define	STRING_FORMAL		TRUE
+#endif
+
+/*
+ * RECURSION_LIMIT may be set to -1 to disable the macro recursion test.
+ */
+#ifndef	RECURSION_LIMIT
+#define	RECURSION_LIMIT	1000
+#endif
+
+/*
+ * BITS_CHAR may be defined to set the number of bits per character.
+ * it is needed only for multi-byte character constants.
+ */
+#ifndef	BITS_CHAR
+#define	BITS_CHAR		8
+#endif
+
+/*
+ * BIG_ENDIAN is set TRUE on machines (such as the IBM 360 series)
+ * where 'ab' stores 'a' in the high-bits and 'b' in the low-bits.
+ * It is set FALSE on machines (such as the PDP-11 and Vax-11)
+ * where 'ab' stores 'a' in the low-bits and 'b' in the high-bits.
+ * (Or is it the other way around?) -- Warning: BIG_ENDIAN code is untested.
+ */
+#ifndef	BIG_ENDIAN
+#define	BIG_ENDIAN 		FALSE
+#endif
+
+/*
+ * COMMENT_INVISIBLE may be defined to allow "old-style" comment
+ * processing, whereby the comment becomes a zero-length token
+ * delimiter.  This permitted tokens to be concatenated in macro
+ * expansions.  This was removed from the Draft Ansi Standard.
+ */
+#ifndef	COMMENT_INVISIBLE
+#define	COMMENT_INVISIBLE	FALSE
+#endif
+
+/*
+ * STRING_FORMAL may be defined to allow recognition of macro parameters
+ * anywhere in replacement strings.  This was removed from the Draft Ansi
+ * Standard and a limited recognition capability added.
+ */
+#ifndef	STRING_FORMAL
+#define	STRING_FORMAL		FALSE
+#endif
+
+/*
+ * OK_DOLLAR enables use of $ as a valid "letter" in identifiers.
+ * This is a permitted extension to the Ansi Standard and is required
+ * for e.g., VMS, RSX-11M, etc.   It should be set FALSE if cpp is
+ * used to preprocess assembler source on Unix systems.  OLD_PREPROCESSOR
+ * sets OK_DOLLAR FALSE for that reason.
+ */
+#ifndef	OK_DOLLAR
+#define	OK_DOLLAR		TRUE
+#endif
+
+/*
+ * OK_CONCAT enables (one possible implementation of) token concatenation.
+ * If cpp is used to preprocess Unix assembler source, this should be
+ * set FALSE as the concatenation character, #, is used by the assembler.
+ */
+#ifndef	OK_CONCAT
+#define	OK_CONCAT		TRUE
+#endif
+
+/*
+ * OK_DATE may be enabled to predefine today's date as a string
+ * at the start of each compilation.  This is apparently not permitted
+ * by the Draft Ansi Standard.
+ */
+#ifndef	OK_DATE
+#define	OK_DATE		TRUE
+#endif
+
+/*
+ * Some common definitions.
+ */
+
+#ifndef	DEBUG
+#define	DEBUG			FALSE
+#endif
+
+/*
+ * The following definitions are used to allocate memory for
+ * work buffers.  In general, they should not be modified
+ * by implementors.
+ *
+ * PAR_MAC	The maximum number of #define parameters (31 per Standard)
+ *		Note: we need another one for strings.
+ * NBUFF	Input buffer size
+ * NWORK	Work buffer size -- the longest macro
+ *		must fit here after expansion.
+ * NEXP		The nesting depth of #if expressions
+ * NINCLUDE	The number of directories that may be specified
+ *		on a per-system basis, or by the -I option.
+ * BLK_NEST	The number of nested #if's permitted.
+ */
+
+#ifndef PAR_MAC
+#define	PAR_MAC		   (31 + 1)
+#endif
+
+#ifndef NBUFF
+#define	NBUFF			512
+#endif
+
+#ifndef NWORK
+#define	NWORK			512
+#endif
+
+#ifndef NEXP
+#define	NEXP			128
+#endif
+
+#ifndef NINCLUDE
+#define	NINCLUDE		  7
+#endif
+
+#ifndef NPARMWORK
+#define	NPARMWORK		(NWORK * 2)
+#endif
+
+#ifndef BLK_NEST
+#define	BLK_NEST		32
+#endif
+
+
+/*
+ * Some special constants.  These may need to be changed if cpp
+ * is ported to a wierd machine.
+ *
+ * NOTE: if cpp is run on a non-ascii machine, ALERT and VT may
+ * need to be changed.  They are used to implement the proposed
+ * ANSI standard C control characters '\a' and '\v' only.
+ * DEL is used to tag macro tokens to prevent #define foo foo
+ * from looping.  Note that we don't try to prevent more elaborate
+ * #define loops from occurring.
+ */
+
+#ifndef	ALERT
+#define	ALERT			'\007'		/* '\a' is "Bell"	*/
+#endif
+
+#ifndef	VT
+#define	VT			'\013'		/* Vertical Tab CTRL/K	*/
+#endif
+
+
+#ifndef	FILE_LOCAL
+#ifdef	decus
+#define	FILE_LOCAL		static
+#else
+#ifdef	vax11c
+#define	FILE_LOCAL		static
+#else
+#define	FILE_LOCAL				/* Others are global	*/
+#endif
+#endif
+#endif
diff --git a/cpp/makefile b/cpp/makefile
new file mode 100644
index 0000000..a6d4008
--- /dev/null
+++ b/cpp/makefile
@@ -0,0 +1,132 @@
+# Unix makefile for cpp
+#
+# On certain systems, such as Unix System III, you may need to define
+# $(LINTFLAGS) in the make command line to set system-specific lint flags.
+#
+# This Makefile assumes cpp will replace the "standard" preprocessor.
+# Delete the reference to -DLINE_PREFIX=\"\" if cpp is used stand-alone.
+# LINEFIX is a sed script filter that reinserts #line -- used for testing
+# if LINE_PREFIX is set to "".   Note that we must stand on our heads to
+# match the # and a line had better not begin with $.  By the way, what
+# we really want is
+#	LINEFIX = | sed "s/^#/#line/"
+#
+CPPDEFINE = -DLINE_PREFIX=\"\"
+LINEFIX = | sed "s/^[^ !\"%-~]/&line/"
+#
+# Define OLD_PREPROCESSOR non-zero to make a preprocessor which is
+# "as compatible as possible" with the standard Unix V7 or Ultrix
+# preprocessors.  This is needed to rebuild 4.2bsd, for example, as
+# the preprocessor is used to modify assembler code, rather than C.
+# This is not recommended for current development.  OLD_PREPROCESSOR
+# forces the following definitions:
+#   OK_DOLLAR		FALSE	$ is not allowed in variables
+#   OK_CONCAT		FALSE	# cannot concatenate tokens
+#   COMMENT_INVISIBLE	TRUE	old-style comment concatenation
+#   STRING_FORMAL	TRUE	old-style string expansion
+#
+OLDDEFINE = -DOLD_PREPROCESSOR=1
+#
+# DEFINES collects all -D arguments for cc and lint:
+# Change DEFINES = $(CPPDEFINE) $(OLDDEFINE)
+# for an old-style preprocessor.
+# If being used for GNU Emacs, the macro EMACS will be defined as -DEMACS.
+#
+DEFINES = $(CPPDEFINE) $(OLDDEFINE) $(EMACS)
+
+CFLAGS = -g $(DEFINES)
+
+#
+# ** compile cpp
+#
+SRCS = cpp1.c cpp2.c cpp3.c cpp4.c cpp5.c cpp6.c
+OBJS = cpp1.o cpp2.o cpp3.o cpp4.o cpp5.o cpp6.o
+cpp: $(OBJS)
+	$(CC) $(CFLAGS) $(OBJS) -o cpp
+
+#
+# ** Test cpp by preprocessing itself, compiling the result,
+# ** repeating the process and diff'ing the result.  Note: this
+# ** is not a good test of cpp, but a simple verification.
+# ** The diff's should not report any changes.
+# ** Note that a sed script may be executed for each compile
+#
+test:
+	cpp cpp1.c $(LINEFIX) >old.tmp1.c
+	cpp cpp2.c $(LINEFIX) >old.tmp2.c
+	cpp cpp3.c $(LINEFIX) >old.tmp3.c
+	cpp cpp4.c $(LINEFIX) >old.tmp4.c
+	cpp cpp5.c $(LINEFIX) >old.tmp5.c
+	cpp cpp6.c $(LINEFIX) >old.tmp6.c
+	$(CC) $(CFLAGS) old.tmp[123456].c
+	a.out cpp1.c >new.tmp1.c
+	a.out cpp2.c >new.tmp2.c
+	a.out cpp3.c >new.tmp3.c
+	a.out cpp4.c >new.tmp4.c
+	a.out cpp5.c >new.tmp5.c
+	a.out cpp6.c >new.tmp6.c
+	diff old.tmp1.c new.tmp1.c
+	diff old.tmp2.c new.tmp2.c
+	diff old.tmp3.c new.tmp3.c
+	diff old.tmp4.c new.tmp4.c
+	diff old.tmp5.c new.tmp5.c
+	diff old.tmp6.c new.tmp6.c
+	rm a.out old.tmp[123456].* new.tmp[123456].*
+
+#
+# A somewhat more extensive test is provided by the "clock"
+# program (which is not distributed).  Substitute your favorite
+# macro-rich program here.
+#
+clock:	clock.c cpp
+	cpp clock.c $(LINEFIX) >temp.cpp.c
+	cc temp.cpp.c -lcurses -ltermcap -o clock
+	rm temp.cpp.c
+
+#
+# ** Lint the code
+#
+
+lint:	$(SRCS)
+	lint $(LINTFLAGS) $(DEFINES) $(SRCS)
+
+#
+# ** Remove unneeded files
+#
+clean:
+	rm -f $(OBJS) cpp
+
+#
+# ** Rebuild the archive files needed to distribute cpp
+# ** Uses the Decus C archive utility.
+#
+
+archc:	archc.c
+	$(CC) $(CFLAGS) archc.c -o archc
+
+archx:	archx.c
+	$(CC) $(CFLAGS) archx.c -o archx
+
+archive: archc
+	archc readme.txt cpp.mem archx.c archc.c cpp.rno makefile.txt \
+		cpp*.h >cpp1.arc
+	archc cpp1.c cpp2.c cpp3.c >cpp2.arc
+	archc cpp4.c cpp5.c cpp6.c >cpp3.arc
+
+#
+# Object module dependencies
+#
+
+cpp1.o	:	cpp1.c cpp.h cppdef.h
+
+cpp2.o	:	cpp2.c cpp.h cppdef.h
+
+cpp3.o	:	cpp3.c cpp.h cppdef.h
+
+cpp4.o	:	cpp4.c cpp.h cppdef.h
+
+cpp5.o	:	cpp5.c cpp.h cppdef.h
+
+cpp6.o	:	cpp6.c cpp.h cppdef.h
+
+
diff --git a/cpp/readme.txt b/cpp/readme.txt
new file mode 100644
index 0000000..3020c17
--- /dev/null
+++ b/cpp/readme.txt
@@ -0,0 +1,112 @@
+
+Decus cpp is a public-domain implementation of the C preprocessor.
+It runs on VMS native (Vax C), VMS compatibilty mode (Decus C),
+RSX-11M, RSTS/E, P/OS, and RT11, as well as on several varieties
+of Unix, including Ultrix.  Decus cpp attempts to implement features
+in the Draft ANSI Standard for the C language.  It should be noted,
+however, that this standard is under active development:  the current
+draft of the standard explicitly states that "readers are requested
+not to specify or claim conformance to this draft."  Thus readers
+and users of Decus cpp should not assume that it conforms to the
+draft standard, or that it will conform to the actual C language
+standard.
+
+These notes describe how to extract the cpp source files, configure it
+for your needs, and mention a few design decisions that may be of interest
+to maintainers.
+
+			Installation
+
+Because the primary development of cpp was not on Unix, it
+is distributed using the Decus C archive program (quite similar
+to the archiver published in Kernighan and Plauger's Software
+Tools).  To extract the files from the net.sources distribution,
+save this message as cpp1.arc and the other two distribution
+files as cpp2.arc and cpp3.arc.  Then, using your favorite editor,
+locate the archx.c program, just following the line beginning with
+"-h- archx.c" -- the format of the distribution is just:
+
+    -h- readme.txt
+      ... this file
+    -h- cpp.mem
+      ... description of cpp
+    -h- archx.c
+      ... archx.c program -- extracts archives
+    -h- archc.c
+      ... archc.c program -- creates archives
+
+Compile archx.c -- it shouldn't require any special editing.
+Then run it as follows:
+
+    archx *.arc
+
+You do not need to remove mail headers from the saved messages.
+
+You should then read through cppdef.h to make sure the HOST and
+TARGET (and other implementation-specific) definitions are set
+correctly for your machine, editing them as needed.
+
+You may then copy makefile.txt to Makefile, editing it as needed
+for your particular system.  On Unix, cpp should be compiled
+by make without further difficulty.  On other operating systems,
+you should compile the six source modules, linking them together.
+Note that, on Decus C based systems, you must extend the default
+stack allocation.  The Decus C build utility will create the
+appropriate command file.
+
+			Support Notes
+
+The USENET distribution kit was designed to keep all submissions around
+50,000 bytes:
+
+cpp1.arc:
+	readme.txt	This file
+	cpp.mem		Documentation page (see below)
+	archx.c		Archive extraction program
+	archc.c		Archive construction program
+	cpp.rno		Source for cpp.mem (see below)
+	makefile.txt	Unix makefile -- copy to Makefile
+	cpp.h		Main header file (structure def's and globals)
+	cppdef.h	Configuration file (host and target definitions)
+
+cpp2.arc:
+	cpp1.c		Mainline code, documentation master sources
+	cpp2.c		most #control processing
+	cpp3.c		filename stuff and command line parsing
+cpp3.arc:
+	cpp4.c		#define processor
+	cpp5.c		#if <expr> processor
+	cpp6.c		Support code (symbol table and I/O routines)
+	
+Cpp intentionally does not rely on the presence of a full-scale
+macro preprocessor, it does require the simple parameter substitution
+preprocessor capabilities of Unix V6 and Decus C.  If your C
+language lacks full preprocessing, you should make sure "nomacargs"
+is #define'd in cpp.h.  (This is done automatically by the Decus C
+compiler.)
+
+The documentation (manual page) for cpp is included as cpp.mem
+and cpp.rno.  Cpp.rno is in Dec Runoff format, built by a Decus C
+utility (getrno) from original source which is embedded in cpp1.c.
+To my knowledge, there is no equivalent program that creates
+the nroff source appropriate for Unix.
+
+I would be happy to receive fixes to any problems you encounter.
+As I do not maintain distribution kit base-levels, bare-bones
+diff listings without sufficient context are not very useful.
+It is unlikely that I can find time to help you with other
+difficulties.
+
+			Acknowledgements
+
+I received a great deal of help from many people in debugging cpp.
+Alan Feuer and Sam Kendall used "state of the art" run-time code
+checkers to locate several errors.  Ed Keiser found problems when
+cpp was used on machines with different int and pointer sizes.
+Dave Conroy helped with the initial debugging, while Arthur Olsen
+and George Rosenberg found (and solved) several problems in the
+first USENET release.
+
+Martin Minow
+decvax!minow
+
diff --git a/dbx/Makefile b/dbx/Makefile
new file mode 100644
index 0000000..36b07ef
--- /dev/null
+++ b/dbx/Makefile
@@ -0,0 +1,182 @@
+#	@(#)Makefile	4.6 (Berkeley) 7/15/83
+#
+# make file for debugger "dbx"
+#
+# The file "defs.h" is included by all.
+#
+# N.B.:
+#    My version of cerror automatically catches certain errors
+# such as out of memory, I/O error.  If you re-make this with
+# the standard cerror, the program could fault unexpectedly.
+#
+
+.SUFFIXES:
+.SUFFIXES: .h .c .s .o
+
+AOUT	= tdbx
+DESTDIR =
+DEST	= ${DESTDIR}/usr/ucb/dbx
+
+LIBRARIES =
+
+CC	= cc
+CFLAGS	= # -g
+LDFLAGS	= -g
+
+OBJ = \
+    y.tab.o \
+    asm.o \
+    events.o \
+    c.o \
+    cerror.o \
+    check.o \
+    coredump.o \
+    debug.o \
+    eval.o \
+    fortran.o \
+    keywords.o \
+    languages.o \
+    library.o \
+    lists.o \
+    machine.o \
+    main.o \
+    mappings.o \
+    names.o \
+    object.o \
+    operators.o \
+    pascal.o \
+    printsym.o \
+    process.o \
+    runtime.o \
+    scanner.o \
+    source.o \
+    symbols.o \
+    tree.o \
+    ops.o
+
+HDR = \
+    asm.h \
+    events.h \
+    c.h \
+    check.h \
+    coredump.h \
+    eval.h \
+    fortran.h \
+    keywords.h \
+    languages.h \
+    lists.h \
+    machine.h \
+    main.h \
+    mappings.h \
+    names.h \
+    object.h \
+    operators.h \
+    pascal.h \
+    printsym.h \
+    process.h \
+    runtime.h \
+    source.h \
+    scanner.h \
+    symbols.h \
+    tree.h \
+    ops.h
+
+SRC = \
+    defs.h \
+    commands.y \
+    asm.c \
+    events.c \
+    c.c \
+    cerror.s \
+    check.c \
+    coredump.c \
+    debug.c \
+    eval.c \
+    fortran.c \
+    keywords.c \
+    languages.c \
+    library.c \
+    lists.c \
+    machine.c \
+    main.c \
+    mappings.c \
+    names.c \
+    object.c \
+    operators.c \
+    pascal.c \
+    printsym.c \
+    process.c \
+    runtime.c \
+    scanner.c \
+    source.c \
+    symbols.c \
+    tree.c \
+    ops.c
+
+.c.o:
+	@echo "compiling $*.c"
+	@${CC} ${CFLAGS} -c $*.c
+
+.s.o:
+	@echo "assembling $*.s"
+	@${CC}  -c $*.s
+
+.c.h:
+	./makedefs -f $*.c $*.h
+
+${AOUT}: makedefs mkdate ${HDR} ${OBJ}
+	@rm -f date.c
+	@./mkdate > date.c
+	@echo "linking"
+	@${CC} ${LDFLAGS} date.c ${OBJ} ${LIBRARIES} -o ${AOUT}
+
+profile: ${HDR} ${OBJ}
+	@rm -f date.c
+	@./mkdate > date.c
+	@echo "linking with -p"
+	@${CC} ${LDFLAGS} -p date.c ${OBJ} ${LIBRARIES} -o ${AOUT}
+
+y.tab.c: commands.y
+	yacc -d commands.y
+
+makedefs: makedefs.c library.o cerror.o
+	${CC} makedefs.c library.o cerror.o -o makedefs
+
+mkdate: mkdate.c
+	${CC} mkdate.c -o mkdate
+
+print:
+	@echo "don't print it, it's too long"
+
+#
+# Don't worry about the removal of header files, they're created from
+# the source files.
+#
+
+clean:
+	rm -f ${HDR} ${OBJ} y.tab.c y.tab.h \
+	    ${AOUT} mkdate mkdate.o makedefs makedefs.o date.c core
+
+install:
+	install ${AOUT} ${DEST}
+
+#
+# Create a tar file called "tape" containing relevant files.
+#
+
+tape:
+	tar cfv tape Makefile READ_ME TO_DO ${SRC} makedefs.c mkdate.c
+
+#
+# Header dependencies are purposely incomplete since header files
+# are "written" every time the accompanying source file changes even if
+# the resulting contents of the header don't change.  The alternative is
+# to force a "makedefs" to be invoked for every header file each time dbx
+# is made.
+#
+# Also, there should be a dependency of scanner.o and keywords.o on y.tab.h
+# but misfortunately silly make does a "makedefs y.tab.c y.tab.h" which
+# destroys y.tab.h.
+#
+
+symbols.o tree.o check.o eval.o events.o: operators.h
diff --git a/dbx/READ_ME b/dbx/READ_ME
new file mode 100644
index 0000000..812ee71
--- /dev/null
+++ b/dbx/READ_ME
@@ -0,0 +1,15 @@
+This is a new debugger for 4.2BSD.  It is intended to be able to handle
+different languages, but currently only understands C and Fortran.
+
+Interface files (.h) are automatically generated from implementation files (.c)
+so they (the .h files) should not be modified.
+
+Many problems have yet to be fixed.
+
+	Mark Linton
+	Computer Science Division
+	Univ. of Calif. at Berkeley
+	Berkeley, CA 94720
+
+	ARPANET: linton@berkeley
+	UUCP:    ucbvax!linton
diff --git a/dbx/TO_DO b/dbx/TO_DO
new file mode 100644
index 0000000..9619a2a
--- /dev/null
+++ b/dbx/TO_DO
@@ -0,0 +1,14 @@
+Things to do include:
+    signal handlers
+
+    C floats
+    parameter passing
+    tracing register variables
+    variable numbers of parameters
+    fix call command
+
+    overloading
+    Pascal
+    screen-oriented front end
+    cleaner and more powerful event specification syntax
+    eliminate redundant header file information
diff --git a/dbx/asm.c b/dbx/asm.c
new file mode 100644
index 0000000..f41d987
--- /dev/null
+++ b/dbx/asm.c
@@ -0,0 +1,99 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)asm.c 1.2 12/15/82";
+
+/*
+ * Assembly language dependent symbol routines.
+ */
+
+#include "defs.h"
+#include "symbols.h"
+#include "asm.h"
+#include "languages.h"
+#include "tree.h"
+#include "eval.h"
+#include "operators.h"
+#include "mappings.h"
+#include "process.h"
+#include "runtime.h"
+#include "machine.h"
+
+#define isdouble(range) ( \
+    range->symvalue.rangev.upper == 0 and range->symvalue.rangev.lower > 0 \
+)
+
+/*
+ * Initialize assembly language information.
+ */
+
+public asm_init()
+{
+    Language lang;
+
+    lang = language_define("assembler", ".s");
+    language_setop(lang, L_PRINTDECL, asm_printdecl);
+    language_setop(lang, L_PRINTVAL, asm_printval);
+    language_setop(lang, L_TYPEMATCH, asm_typematch);
+}
+
+/*
+ * Test if two types are compatible.
+ */
+
+public Boolean asm_typematch(type1, type2)
+Symbol type1, type2;
+{
+    Boolean b;
+
+    b = false;
+    return b;
+}
+
+public asm_printdecl(s)
+Symbol s;
+{
+    switch (s->class) {
+	case VAR:
+	case REF:
+	    printf("&%s = 0x%x", symname(s), s->symvalue.offset);
+	    break;
+
+	case PROC:
+	case FUNC:
+	    printf("%s (0x%x):", symname(s), codeloc(s));
+	    break;
+
+	default:
+	    error("class %s in c_printdecl", classname(s));
+    }
+    putchar('\n');
+}
+
+/*
+ * Print out the value on the top of the expression stack
+ * in the format for the type of the given symbol.
+ */
+
+public asm_printval(s)
+register Symbol s;
+{
+    register Symbol t;
+    register Integer len;
+
+    switch (s->class) {
+	case ARRAY:
+	    t = rtype(s->type);
+	    if (t->class == RANGE and istypename(t->type, "$char")) {
+		len = size(s);
+		sp -= len;
+		printf("\"%.*s\"", len, sp);
+	    } else {
+		printarray(s);
+	    }
+	    break;
+
+	default:
+	    printf("0x%x", pop(Integer));
+	    break;
+    }
+}
diff --git a/dbx/asm.h b/dbx/asm.h
new file mode 100644
index 0000000..3c1e32b
--- /dev/null
+++ b/dbx/asm.h
@@ -0,0 +1,7 @@
+#ifndef asm_h
+#define asm_h
+asm_init(/*  */);
+Boolean asm_typematch(/* type1, type2 */);
+asm_printdecl(/* s */);
+asm_printval(/* s */);
+#endif
diff --git a/dbx/c.c b/dbx/c.c
new file mode 100644
index 0000000..36bf6c5
--- /dev/null
+++ b/dbx/c.c
@@ -0,0 +1,749 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)c.c 1.7 8/16/83";
+
+/*
+ * C-dependent symbol routines.
+ */
+
+#include "defs.h"
+#include "symbols.h"
+#include "printsym.h"
+#include "languages.h"
+#include "c.h"
+#include "tree.h"
+#include "eval.h"
+#include "operators.h"
+#include "mappings.h"
+#include "process.h"
+#include "runtime.h"
+#include "machine.h"
+
+#ifndef public
+# include "tree.h"
+#endif
+
+#define isdouble(range) ( \
+    range->symvalue.rangev.upper == 0 and range->symvalue.rangev.lower > 0 \
+)
+
+#define isrange(t, name) (t->class == RANGE and istypename(t->type, name))
+
+/*
+ * Initialize C language information.
+ */
+
+public c_init()
+{
+    Language lang;
+
+    lang = language_define("c", ".c");
+    language_setop(lang, L_PRINTDECL, c_printdecl);
+    language_setop(lang, L_PRINTVAL, c_printval);
+    language_setop(lang, L_TYPEMATCH, c_typematch);
+    language_setop(lang, L_BUILDAREF, c_buildaref);
+    language_setop(lang, L_EVALAREF, c_evalaref);
+}
+
+/*
+ * Test if two types are compatible.
+ */
+
+public Boolean c_typematch(type1, type2)
+Symbol type1, type2;
+{
+    Boolean b;
+    register Symbol t1, t2, tmp;
+
+    t1 = type1;
+    t2 = type2;
+    if (t1 == t2) {
+	b = true;
+    } else {
+	t1 = rtype(t1);
+	t2 = rtype(t2);
+	if (t1->type == t_char or t1->type == t_int or t1->type == t_real) {
+	    tmp = t1;
+	    t1 = t2;
+	    t2 = tmp;
+	}
+	b = (Boolean) (
+	    (
+		isrange(t1, "int") and
+		(t2->type == t_int or t2->type == t_char)
+	    ) or (
+		isrange(t1, "char") and
+		(t2->type == t_char or t2->type == t_int)
+	    ) or (
+		t1->class == RANGE and isdouble(t1) and t2->type == t_real
+	    ) or (
+		t1->type == t2->type and (
+		    (t1->class == t2->class) or
+		    (t1->class == SCAL and t2->class == CONST) or
+		    (t1->class == CONST and t2->class == SCAL)
+		)
+	    )
+	);
+    }
+    return b;
+}
+
+/*
+ * Decide if a field is a bit field.
+ */
+
+private Boolean isbitfield(s)
+register Symbol s;
+{
+    Boolean b;
+    register Integer off, len;
+    register Symbol t;
+
+    off = s->symvalue.field.offset;
+    len = s->symvalue.field.length;
+    if ((off mod BITSPERBYTE) != 0 or (len mod BITSPERBYTE) != 0) {
+	b = true;
+    } else {
+	t = rtype(s->type);
+	b = (Boolean)
+	    (t->class == SCAL and len != (sizeof(int)*BITSPERBYTE) or
+	    len != (size(t)*BITSPERBYTE)
+	);
+    }
+    return b;
+}
+
+/*
+ * Print out the declaration of a C variable.
+ */
+
+public c_printdecl(s)
+Symbol s;
+{
+    printdecl(s, 0);
+}
+
+private printdecl(s, indent)
+register Symbol s;
+Integer indent;
+{
+    register Symbol t;
+    Boolean semicolon, newline;
+
+    semicolon = true;
+    newline = true;
+    if (indent > 0) {
+	printf("%*c", indent, ' ');
+    }
+    if (s->class == TYPE) {
+	printf("typedef ");
+    }
+    switch (s->class) {
+	case CONST:
+	    if (s->type->class == SCAL) {
+		printf("(enumeration constant, ord %ld)",
+		    s->symvalue.iconval);
+	    } else {
+		printf("const %s = ", symname(s));
+		printval(s);
+	    }
+	    break;
+
+	case TYPE:
+	case VAR:
+	    if (s->class != TYPE) {
+		if (s->level == 2) {
+		    printf("static ");
+		} else if (s->level < 0) {
+		    printf("register ");
+		}
+	    }
+	    if (s->type->class == ARRAY) {
+		printtype(s->type, s->type->type, indent);
+		t = rtype(s->type->chain);
+		assert(t->class == RANGE);
+		printf(" %s[%d]", symname(s), t->symvalue.rangev.upper + 1);
+	    } else {
+		printtype(s, s->type, indent);
+		if (s->type->class != PTR) {
+		    printf(" ");
+		}
+		printf("%s", symname(s));
+	    }
+	    break;
+
+	case FIELD:
+	    if (s->type->class == ARRAY) {
+		printtype(s->type, s->type->type, indent);
+		t = rtype(s->type->chain);
+		assert(t->class == RANGE);
+		printf(" %s[%d]", symname(s), t->symvalue.rangev.upper + 1);
+	    } else {
+		printtype(s, s->type, indent);
+		if (s->type->class != PTR) {
+		    printf(" ");
+		}
+		printf("%s", symname(s));
+	    }
+	    if (isbitfield(s)) {
+		printf(" : %d", s->symvalue.field.length);
+	    }
+	    break;
+
+	case TAG:
+	    if (s->type == nil) {
+		findtype(s);
+		if (s->type == nil) {
+		    error("unexpected missing type information");
+		}
+	    }
+	    printtype(s, s->type, indent);
+	    break;
+
+	case RANGE:
+	case ARRAY:
+	case RECORD:
+	case VARNT:
+	case PTR:
+	    semicolon = false;
+	    printtype(s, s, indent);
+	    break;
+
+	case PROC:
+	    semicolon = false;
+	    printf("%s", symname(s));
+	    c_listparams(s);
+	    newline = false;
+	    break;
+
+	case FUNC:
+	    semicolon = false;
+	    if (not istypename(s->type, "void")) {
+		printtype(s, s->type, indent);
+		printf(" ");
+	    }
+	    printf("%s", symname(s));
+	    c_listparams(s);
+	    newline = false;
+	    break;
+
+	case MODULE:
+	    semicolon = false;
+	    printf("source file \"%s.c\"", symname(s));
+	    break;
+
+	case PROG:
+	    semicolon = false;
+	    printf("executable file \"%s\"", symname(s));
+	    break;
+
+	default:
+	    error("class %s in c_printdecl", classname(s));
+    }
+    if (semicolon) {
+	putchar(';');
+    }
+    if (newline) {
+	putchar('\n');
+    }
+}
+
+/*
+ * Recursive whiz-bang procedure to print the type portion
+ * of a declaration.
+ *
+ * The symbol associated with the type is passed to allow
+ * searching for type names without getting "type blah = blah".
+ */
+
+private printtype(s, t, indent)
+Symbol s;
+Symbol t;
+Integer indent;
+{
+    register Symbol i;
+    long r0, r1;
+    register String p;
+
+    checkref(s);
+    checkref(t);
+    switch (t->class) {
+	case VAR:
+	case CONST:
+	case PROC:
+	    panic("printtype: class %s", classname(t));
+	    break;
+
+	case ARRAY:
+	    printf("array[");
+	    i = t->chain;
+	    if (i != nil) {
+		for (;;) {
+		    printtype(i, i, indent);
+		    i = i->chain;
+		    if (i == nil) {
+			break;
+		    }
+		    printf(", ");
+		}
+	    }
+	    printf("] of ");
+	    printtype(t, t->type, indent);
+	    break;
+
+	case RECORD:
+	case VARNT:
+	    printf("%s ", c_classname(t));
+	    if (s->name != nil and s->class == TAG) {
+		p = symname(s);
+		if (p[0] == '$' and p[1] == '$') {
+		    printf("%s ", &p[2]);
+		} else {
+		    printf("%s ", p);
+		}
+	    }
+	    printf("{\n", t->class == RECORD ? "struct" : "union");
+	    for (i = t->chain; i != nil; i = i->chain) {
+		assert(i->class == FIELD);
+		printdecl(i, indent+4);
+	    }
+	    if (indent > 0) {
+		printf("%*c", indent, ' ');
+	    }
+	    printf("}");
+	    break;
+
+	case RANGE:
+	    r0 = t->symvalue.rangev.lower;
+	    r1 = t->symvalue.rangev.upper;
+	    if (istypename(t->type, "char")) {
+		if (r0 < 0x20 or r0 > 0x7e) {
+		    printf("%ld..", r0);
+		} else {
+		    printf("'%c'..", (char) r0);
+		}
+		if (r1 < 0x20 or r1 > 0x7e) {
+		    printf("\\%lo", r1);
+		} else {
+		    printf("'%c'", (char) r1);
+		}
+	    } else if (r0 > 0 and r1 == 0) {
+		printf("%ld byte real", r0);
+	    } else if (r0 >= 0) {
+		printf("%lu..%lu", r0, r1);
+	    } else {
+		printf("%ld..%ld", r0, r1);
+	    }
+	    break;
+
+	case PTR:
+	    printtype(t, t->type, indent);
+	    if (t->type->class != PTR) {
+		printf(" ");
+	    }
+	    printf("*");
+	    break;
+
+	case FUNC:
+	    printtype(t, t->type, indent);
+	    printf("()");
+	    break;
+
+	case TYPE:
+	    if (t->name != nil) {
+		printf("%s", symname(t));
+	    } else {
+		printtype(t, t->type, indent);
+	    }
+	    break;
+
+	case TYPEREF:
+	    printf("@%s", symname(t));
+	    break;
+
+	case SCAL:
+	    printf("enum ");
+	    if (s->name != nil and s->class == TAG) {
+		printf("%s ", symname(s));
+	    }
+	    printf("{ ");
+	    i = t->chain;
+	    if (i != nil) {
+		for (;;) {
+		    printf("%s", symname(i));
+		    i = i->chain;
+		if (i == nil) break;
+		    printf(", ");
+		}
+	    }
+	    printf(" }");
+	    break;
+
+	case TAG:
+	    if (t->type == nil) {
+		printf("unresolved tag %s", symname(t));
+	    } else {
+		i = rtype(t->type);
+		printf("%s %s", c_classname(i), symname(t));
+	    }
+	    break;
+
+	default:
+	    printf("(class %d)", t->class);
+	    break;
+    }
+}
+
+/*
+ * List the parameters of a procedure or function.
+ * No attempt is made to combine like types.
+ */
+
+public c_listparams(s)
+Symbol s;
+{
+    register Symbol t;
+
+    putchar('(');
+    for (t = s->chain; t != nil; t = t->chain) {
+	printf("%s", symname(t));
+	if (t->chain != nil) {
+	    printf(", ");
+	}
+    }
+    putchar(')');
+    if (s->chain != nil) {
+	printf("\n");
+	for (t = s->chain; t != nil; t = t->chain) {
+	    if (t->class != VAR) {
+		panic("unexpected class %d for parameter", t->class);
+	    }
+	    printdecl(t, 0);
+	}
+    } else {
+	putchar('\n');
+    }
+}
+
+/*
+ * Print out the value on the top of the expression stack
+ * in the format for the type of the given symbol.
+ */
+
+public c_printval(s)
+Symbol s;
+{
+    register Symbol t;
+    register Address a;
+    register int i, len;
+
+    switch (s->class) {
+	case CONST:
+	case TYPE:
+	case VAR:
+	case REF:
+	case FVAR:
+	case TAG:
+	    c_printval(s->type);
+	    break;
+
+	case FIELD:
+	    if (isbitfield(s)) {
+		len = s->symvalue.field.length;
+		if (len <= BITSPERBYTE) {
+		    i = pop(char);
+		} else if (len <= sizeof(short)*BITSPERBYTE) {
+		    i = pop(short);
+		} else {
+		    i = pop(long);
+		}
+		i >>= (s->symvalue.field.offset mod BITSPERBYTE);
+		i &= ((1 << len) - 1);
+		t = rtype(s->type);
+		if (t->class == SCAL) {
+		    printenum(i, t);
+		} else {
+		    printrange(i, t);
+		}
+	    } else {
+		c_printval(s->type);
+	    }
+	    break;
+
+	case ARRAY:
+	    t = rtype(s->type);
+	    if (t->class == RANGE and istypename(t->type, "char")) {
+		len = size(s);
+		sp -= len;
+		printf("\"%.*s\"", len, sp);
+	    } else {
+		printarray(s);
+	    }
+	    break;
+
+	case RECORD:
+	    c_printstruct(s);
+	    break;
+
+	case RANGE:
+	    if (istypename(s->type, "boolean")) {
+		printrange(popsmall(s), s);
+	    } else if (istypename(s->type, "char")) {
+		printrange(pop(char), s);
+	    } else if (isdouble(s)) {
+		switch (s->symvalue.rangev.lower) {
+		    case sizeof(float):
+			prtreal(pop(float));
+			break;
+
+		    case sizeof(double):
+			prtreal(pop(double));
+			break;
+
+		    default:
+			panic("bad real size %d", t->symvalue.rangev.lower);
+			break;
+		}
+	    } else {
+		printrange(popsmall(s), s);
+	    }
+	    break;
+
+	case PTR:
+	    t = rtype(s->type);
+	    a = pop(Address);
+	    if (a == 0) {
+		printf("(nil)");
+	    } else if (t->class == RANGE and istypename(t->type, "char")) {
+		printstring(a);
+	    } else {
+		printf("0x%x", a);
+	    }
+	    break;
+
+	case SCAL:
+	    i = pop(Integer);
+	    printenum(i, s);
+	    break;
+
+	default:
+	    if (ord(s->class) > ord(TYPEREF)) {
+		panic("printval: bad class %d", ord(s->class));
+	    }
+	    sp -= size(s);
+	    printf("<%s>", c_classname(s));
+	    break;
+    }
+}
+
+/*
+ * Print out a C structure.
+ */
+
+private c_printstruct(s)
+Symbol s;
+{
+    register Symbol f;
+    register Stack *savesp;
+    register Integer n, off, len;
+
+    sp -= size(s);
+    savesp = sp;
+    printf("(");
+    f = s->chain;
+    for (;;) {
+	off = f->symvalue.field.offset;
+	len = f->symvalue.field.length;
+	n = (off + len + 7) div BITSPERBYTE;
+	sp += n;
+	printf("%s = ", symname(f));
+	c_printval(f);
+	sp = savesp;
+	f = f->chain;
+    if (f == nil) break;
+	printf(", ");
+    }
+    printf(")");
+}
+
+/*
+ * Print out a range type (integer, char, or boolean).
+ */
+
+private printrange(i, t)
+Integer i;
+register Symbol t;
+{
+    if (istypename(t->type, "boolean")) {
+	printf(((Boolean) i) == true ? "true" : "false");
+    } else if (istypename(t->type, "char")) {
+	putchar('\'');
+	printchar(i);
+	putchar('\'');
+    } else if (t->symvalue.rangev.lower >= 0) {
+	printf("%lu", i);
+    } else {
+	printf("%ld", i);
+    }
+}
+
+/*
+ * Print out a null-terminated string (pointer to char)
+ * starting at the given address.
+ */
+
+private printstring(addr)
+Address addr;
+{
+    register Address a;
+    register Integer i, len;
+    register Boolean endofstring;
+    union {
+	char ch[sizeof(Word)];
+	int word;
+    } u;
+
+    putchar('"');
+    a = addr;
+    endofstring = false;
+    while (not endofstring) {
+	dread(&u, a, sizeof(u));
+	i = 0;
+	do {
+	    if (u.ch[i] == '\0') {
+		endofstring = true;
+	    } else {
+		printchar(u.ch[i]);
+	    }
+	    ++i;
+	} while (i < sizeof(Word) and not endofstring);
+	a += sizeof(Word);
+    }
+    putchar('"');
+}
+
+/*
+ * Print out an enumerated value by finding the corresponding
+ * name in the enumeration list.
+ */
+
+private printenum(i, t)
+Integer i;
+Symbol t;
+{
+    register Symbol e;
+
+    e = t->chain;
+    while (e != nil and e->symvalue.iconval != i) {
+	e = e->chain;
+    }
+    if (e != nil) {
+	printf("%s", symname(e));
+    } else {
+	printf("%d", i);
+    }
+}
+
+/*
+ * Return the C name for the particular class of a symbol.
+ */
+
+public String c_classname(s)
+Symbol s;
+{
+    String str;
+
+    switch (s->class) {
+	case RECORD:
+	    str = "struct";
+	    break;
+
+	case VARNT:
+	    str = "union";
+	    break;
+
+	case SCAL:
+	    str = "enum";
+	    break;
+
+	default:
+	    str = classname(s);
+    }
+    return str;
+}
+public Node c_buildaref(a, slist)
+Node a, slist;
+{
+    register Symbol t;
+    register Node p;
+    Symbol etype, atype, eltype;
+    Node esub, r;
+
+    r = a;
+    t = rtype(a->nodetype);
+    eltype = t->type;
+    if (t->class == PTR) {
+	p = slist->value.arg[0];
+	if (not compatible(p->nodetype, t_int)) {
+	    beginerrmsg();
+	    fprintf(stderr, "bad type for subscript of ");
+	    prtree(stderr, a);
+	    enderrmsg();
+	}
+	r = build(O_MUL, p, build(O_LCON, (long) size(eltype)));
+	r = build(O_ADD, build(O_RVAL, a), r);
+	r->nodetype = eltype;
+    } else if (t->class != ARRAY) {
+	beginerrmsg();
+	prtree(stderr, a);
+	fprintf(stderr, " is not an array");
+	enderrmsg();
+    } else {
+	p = slist;
+	t = t->chain;
+	for (; p != nil and t != nil; p = p->value.arg[1], t = t->chain) {
+	    esub = p->value.arg[0];
+	    etype = rtype(esub->nodetype);
+	    atype = rtype(t);
+	    if (not compatible(atype, etype)) {
+		beginerrmsg();
+		fprintf(stderr, "subscript ");
+		prtree(stderr, esub);
+		fprintf(stderr, " is the wrong type");
+		enderrmsg();
+	    }
+	    r = build(O_INDEX, r, esub);
+	    r->nodetype = eltype;
+	}
+	if (p != nil or t != nil) {
+	    beginerrmsg();
+	    if (p != nil) {
+		fprintf(stderr, "too many subscripts for ");
+	    } else {
+		fprintf(stderr, "not enough subscripts for ");
+	    }
+	    prtree(stderr, a);
+	    enderrmsg();
+	}
+    }
+    return r;
+}
+
+/*
+ * Evaluate a subscript index.
+ */
+
+public int c_evalaref(s, i)
+Symbol s;
+long i;
+{
+    long lb, ub;
+
+    s = rtype(s)->chain;
+    lb = s->symvalue.rangev.lower;
+    ub = s->symvalue.rangev.upper;
+    if (i < lb or i > ub) {
+	error("subscript out of range");
+    }
+    return (i - lb);
+}
diff --git a/dbx/c.h b/dbx/c.h
new file mode 100644
index 0000000..3901de1
--- /dev/null
+++ b/dbx/c.h
@@ -0,0 +1,12 @@
+#ifndef c_h
+#define c_h
+# include "tree.h"
+c_init(/*  */);
+Boolean c_typematch(/* type1, type2 */);
+c_printdecl(/* s */);
+c_listparams(/* s */);
+c_printval(/* s */);
+String c_classname(/* s */);
+Node c_buildaref(/* a, slist */);
+int c_evalaref(/* s, i */);
+#endif
diff --git a/dbx/cerror.s b/dbx/cerror.s
new file mode 100644
index 0000000..27390d1
--- /dev/null
+++ b/dbx/cerror.s
@@ -0,0 +1,26 @@
+# Copyright (c) 1982 Regents of the University of California
+#
+# static char sccsid[] = "@(#)cerror.s 1.3 9/2/82";
+#
+# modified version of cerror
+#
+# The idea is that every time an error occurs in a system call
+# I want a special function "syserr" called.  This function will
+# either print a message and exit or do nothing depending on
+# defaults and use of "onsyserr".
+#
+
+.globl	cerror
+.comm	_errno,4
+
+cerror:
+	movl	r0,_errno
+	calls	$0,_syserr	# new code
+	mnegl	$1,r0
+	ret
+
+.globl	__mycerror		# clumsy way to get this loaded
+
+__mycerror:
+	.word	0
+	ret
diff --git a/dbx/check.c b/dbx/check.c
new file mode 100644
index 0000000..a4c5f65
--- /dev/null
+++ b/dbx/check.c
@@ -0,0 +1,184 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)check.c 1.5 8/10/83";
+
+/*
+ * Check a tree for semantic correctness.
+ */
+
+#include "defs.h"
+#include "tree.h"
+#include "operators.h"
+#include "events.h"
+#include "symbols.h"
+#include "scanner.h"
+#include "source.h"
+#include "object.h"
+#include "mappings.h"
+#include "process.h"
+
+#ifndef public
+#endif
+
+/*
+ * Check that the nodes in a tree have the correct arguments
+ * in order to be evaluated.  Basically the error checking here
+ * frees the evaluation routines from worrying about anything
+ * except dynamic errors, e.g. subscript out of range.
+ */
+
+public check(p)
+register Node p;
+{
+    Address addr;
+    Symbol f;
+
+    checkref(p);
+    switch (p->op) {
+	case O_LIST:
+	    if (p->value.arg[0]->op == O_SYM) {
+		f = p->value.arg[0]->value.sym;
+		if (not isblock(f) or ismodule(f)) {
+		    error("\"%s\" is not a procedure or function", symname(f));
+		}
+		addr = firstline(f);
+		if (addr == NOADDR) {
+		    error("\"%s\" is empty", symname(f));
+		}
+	    }
+	    break;
+
+	case O_TRACE:
+	case O_TRACEI:
+	    chktrace(p);
+	    break;
+
+	case O_STOP:
+	case O_STOPI:
+	    chkstop(p);
+	    break;
+
+	default:
+	    break;
+    }
+}
+
+/*
+ * Check arguments to a trace command.
+ */
+
+private chktrace(p)
+Node p;
+{
+    Node exp, place, cond;
+
+    exp = p->value.arg[0];
+    place = p->value.arg[1];
+    cond = p->value.arg[2];
+    if (exp == nil) {
+	chkblock(place);
+    } else if (exp->op == O_LCON or exp->op == O_QLINE) {
+	if (place != nil) {
+	    error("unexpected \"at\" or \"in\"");
+	}
+	if (p->op == O_TRACE) {
+	    chkline(exp);
+	} else {
+	    chkaddr(exp);
+	}
+    } else if (place != nil and (place->op == O_QLINE or place->op == O_LCON)) {
+	if (p->op == O_TRACE) {
+	    chkline(place);
+	} else {
+	    chkaddr(place);
+	}
+    } else {
+	if (exp->op != O_RVAL and exp->op != O_SYM and exp->op != O_CALL) {
+	    error("can't trace expressions");
+	}
+	chkblock(place);
+    }
+}
+
+/*
+ * Check arguments to a stop command.
+ */
+
+private chkstop(p)
+Node p;
+{
+    Node exp, place, cond;
+
+    exp = p->value.arg[0];
+    place = p->value.arg[1];
+    cond = p->value.arg[2];
+    if (exp != nil) {
+	if (exp->op != O_RVAL and exp->op != O_SYM and exp->op != O_LCON) {
+	    beginerrmsg();
+	    fprintf(stderr, "expected variable, found ");
+	    prtree(stderr, exp);
+	    enderrmsg();
+	}
+	chkblock(place);
+    } else if (place->op == O_SYM) {
+	chkblock(place);
+    } else {
+	if (p->op == O_STOP) {
+	    chkline(place);
+	} else {
+	    chkaddr(place);
+	}
+    }
+}
+
+/*
+ * Check to see that the given node specifies some subprogram.
+ * Nil is ok since that means the entire program.
+ */
+
+private chkblock(b)
+Node b;
+{
+    if (b != nil) {
+	if (b->op != O_SYM) {
+	    beginerrmsg();
+	    fprintf(stderr, "expected subprogram, found ");
+	    prtree(stderr, b);
+	    enderrmsg();
+	} else if (not isblock(b->value.sym) or ismodule(b->value.sym)) {
+	    error("\"%s\" is not a subprogram", symname(b->value.sym));
+	}
+    }
+}
+
+/*
+ * Check to make sure a node corresponds to a source line.
+ */
+
+private chkline(p)
+Node p;
+{
+    if (p == nil) {
+	error("missing line");
+    } else if (p->op != O_QLINE and p->op != O_LCON) {
+	error("expected source line number, found \"%t\"", p);
+    }
+}
+
+/*
+ * Check to make sure a node corresponds to an address.
+ */
+
+private chkaddr(p)
+Node p;
+{
+    if (p == nil) {
+	error("missing address");
+    } else if (p->op != O_LCON and p->op != O_QLINE) {
+	beginerrmsg();
+	fprintf(stderr, "expected address, found \"");
+	prtree(stderr, p);
+	fprintf(stderr, "\"");
+	enderrmsg();
+    }
+}
diff --git a/dbx/check.h b/dbx/check.h
new file mode 100644
index 0000000..b8284f8
--- /dev/null
+++ b/dbx/check.h
@@ -0,0 +1,4 @@
+#ifndef check_h
+#define check_h
+check(/* p */);
+#endif
diff --git a/dbx/commands.y b/dbx/commands.y
new file mode 100644
index 0000000..f50c4ba
--- /dev/null
+++ b/dbx/commands.y
@@ -0,0 +1,883 @@
+%{
+
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)commands.y 1.9 8/17/83";
+
+/*
+ * Yacc grammar for debugger commands.
+ */
+
+#include "defs.h"
+#include "symbols.h"
+#include "operators.h"
+#include "tree.h"
+#include "process.h"
+#include "source.h"
+#include "scanner.h"
+#include "names.h"
+#include "lists.h"
+
+private String curformat = "X";
+
+%}
+
+%term
+    ALIAS AND ASSIGN AT CALL CATCH CONT DEBUG DELETE DIV DUMP
+    EDIT FILE FUNC GRIPE HELP IF IGNORE IN LIST MOD NEXT NEXTI NIL NOT OR
+    PRINT PSYM QUIT RUN SH SKIP SOURCE STATUS STEP STEPI
+    STOP STOPI TRACE TRACEI
+    USE WHATIS WHEN WHERE WHEREIS WHICH
+
+%term INT REAL NAME STRING
+%term LFORMER RFORMER ABSTRACTION ARROW
+
+%right INT
+%binary REDIRECT
+%binary '<' '=' '>' '!' IN
+%left '+' '-' OR
+%left UNARYSIGN
+%left '*' '/' DIV MOD AND
+%left NOT '(' '[' '.' '^' ARROW
+%left '\\'
+
+%union {
+    Name y_name;
+    Symbol y_sym;
+    Node y_node;
+    Integer y_int;
+    Operator y_op;
+    long y_long;
+    double y_real;
+    String y_string;
+    Boolean y_bool;
+    Cmdlist y_cmdlist;
+    List y_list;
+};
+
+%type <y_op>	    trace stop
+%type <y_long>	    INT count
+%type <y_real>	    REAL
+%type <y_string>    STRING redirectout filename opt_filename mode
+%type <y_name>	    ALIAS AND ASSIGN AT CALL CATCH CONT DEBUG DELETE DIV DUMP
+%type <y_name>	    EDIT FILE FUNC GRIPE HELP IF IGNORE IN LIST MOD
+%type <y_name>	    NEXT NEXTI NIL NOT OR
+%type <y_name>	    PRINT PSYM QUIT RUN SH SKIP SOURCE STATUS STEP STEPI
+%type <y_name>	    STOP STOPI TRACE TRACEI
+%type <y_name>	    USE WHATIS WHEN WHERE WHEREIS WHICH
+%type <y_name>	    name NAME keyword
+%type <y_node>      symbol
+%type <y_node>	    command rcommand cmd step what where examine
+%type <y_node>	    event opt_exp_list opt_cond
+%type <y_node>	    exp_list exp term boolean_exp constant address
+%type <y_node>	    alias_command list_command line_number
+%type <y_cmdlist>   actions
+%type <y_list>      sourcepath
+
+%%
+
+input:
+    input command_nl
+|
+    /* empty */
+;
+command_nl:
+    command_line '\n'
+|
+    command_line ';'
+|
+    '\n'
+;
+
+command_line:
+    command
+{
+	if ($1 != nil) {
+            if(debug_flag[2]) {dumptree(stderr,$1); fflush (stderr);}
+	    eval($1);
+	}
+}
+|
+    rcommand redirectout
+{
+	if ($1 != nil) {
+	    if ($2 != nil) {
+		setout($2);
+                if(debug_flag[2]) {dumptree(stderr,$1); fflush (stderr);}
+		eval($1);
+		unsetout();
+	    } else {
+                if(debug_flag[2]) {dumptree(stderr,$1); fflush (stderr);}
+		eval($1);
+	    }
+	}
+}
+;
+redirectout:
+    '>' shellmode NAME
+{
+	$$ = ident($3);
+}
+|
+    /* empty */
+{
+	$$ = nil;
+}
+;
+
+/*
+ * Non-redirectable commands.
+ */
+command:
+    alias_command
+{
+	$$ = $1;
+}
+|
+    ASSIGN term '=' exp
+{
+	$$ = build(O_ASSIGN, $2, $4);
+}
+|
+    CATCH INT
+{
+	$$ = build(O_CATCH, $2);
+}
+|
+    CONT
+{
+	$$ = build(O_CONT, (long) DEFSIG);
+}
+|
+    CONT INT
+{
+	$$ = build(O_CONT, $2);
+}
+|
+    DELETE INT
+{
+	$$ = build(O_DELETE, $2);
+}
+|
+    EDIT shellmode opt_filename
+{
+	$$ = build(O_EDIT, $3);
+}
+|
+    FILE shellmode opt_filename
+{
+	$$ = build(O_CHFILE, $3);
+}
+|
+    FUNC
+{
+	$$ = build(O_FUNC, nil);
+}
+|
+    FUNC symbol
+{
+	$$ = build(O_FUNC, $2);
+}
+|
+    GRIPE
+{
+	$$ = build(O_GRIPE);
+}
+|
+    HELP
+{
+	$$ = build(O_HELP);
+}
+|
+    IGNORE INT
+{
+	$$ = build(O_IGNORE, $2);
+}
+|
+    list_command
+{
+	$$ = $1;
+}
+|
+    PSYM term
+{
+	$$ = build(O_PSYM, $2);
+}
+|
+    QUIT
+{
+	if (not popinput()) {
+	    quit(0);
+	} else {
+	    $$ = nil;
+	}
+}
+|
+    runcommand
+{
+	run();
+	/* NOTREACHED */
+}
+|
+    SH
+{
+	shellline();
+	$$ = nil;
+}
+|
+    SOURCE shellmode filename
+{
+	$$ = build(O_SOURCE, $3);
+}
+|
+    step
+{
+	$$ = $1;
+}
+|
+    stop where opt_cond
+{
+	$$ = build($1, nil, $2, $3);
+}
+|
+    stop what opt_cond
+{
+	$$ = build($1, $2, nil, $3);
+}
+|
+    stop IF boolean_exp
+{
+	$$ = build($1, nil, nil, $3);
+}
+|
+    trace what where opt_cond
+{
+	$$ = build($1, $2, $3, $4);
+}
+|
+    trace where opt_cond
+{
+	$$ = build($1, nil, $2, $3);
+}
+|
+    trace what opt_cond
+{
+	$$ = build($1, $2, nil, $3);
+}
+|
+    trace opt_cond
+{
+	$$ = build($1, nil, nil, $2);
+}
+|
+    WHATIS term
+{
+	$$ = build(O_WHATIS, $2);
+}
+|
+    WHEN event '{' actions '}'
+{
+	$$ = build(O_ADDEVENT, $2, $4);
+}
+|
+    WHEREIS symbol
+{
+	$$ = build(O_WHEREIS, $2);
+}
+|
+    WHICH symbol
+{
+	$$ = build(O_WHICH, $2);
+}
+|
+    USE shellmode sourcepath
+{
+	String dir;
+
+	$$ = nil;
+	if (list_size($3) == 0) {
+	    foreach (String, dir, sourcepath)
+		printf("%s ", dir);
+	    endfor
+	    printf("\n");
+	} else {
+	    foreach (String, dir, sourcepath)
+		list_delete(list_curitem(sourcepath), sourcepath);
+	    endfor
+	    sourcepath = $3;
+	}
+}
+;
+runcommand:
+    run { arginit(); } arglist
+|
+    run
+;
+run:
+    RUN shellmode
+{
+	fflush(stdout);
+}
+;
+arglist:
+    arglist arg
+|
+    arg
+;
+arg:
+    NAME
+{
+	newarg(ident($1));
+}
+|
+    '<' NAME
+{
+	inarg(ident($2));
+}
+|
+    '>' NAME
+{
+	outarg(ident($2));
+}
+;
+step:
+    STEP
+{
+	$$ = build(O_STEP, true, false);
+}
+|
+    STEPI
+{
+	$$ = build(O_STEP, false, false);
+}
+|
+    NEXT
+{
+	$$ = build(O_STEP, true, true);
+}
+|
+    NEXTI
+{
+	$$ = build(O_STEP, false, true);
+}
+;
+shellmode:
+    /* empty */
+{
+	beginshellmode();
+}
+;
+sourcepath:
+    sourcepath NAME
+{
+	$$ = $1;
+	list_append(list_item(ident($2)), nil, $$);
+}
+|
+    /* empty */
+{
+	$$ = list_alloc();
+}
+;
+event:
+    where
+|
+    exp
+;
+actions:
+    actions cmd ';'
+{
+	$$ = $1;
+	cmdlist_append($2, $$);
+}
+|
+    cmd ';'
+{
+	$$ = list_alloc();
+	cmdlist_append($1, $$);
+}
+;
+cmd:
+    command
+|
+    rcommand
+;
+
+/*
+ * Redirectable commands.
+ */
+rcommand:
+    PRINT exp_list
+{
+	$$ = build(O_PRINT, $2);
+}
+|
+    WHERE
+{
+	$$ = build(O_WHERE);
+}
+|
+    examine
+{
+	$$ = $1;
+}
+|
+    CALL term
+{
+	$$ = $2;
+}
+|
+    DEBUG INT
+{
+ 	$$ = build(O_DEBUG, $2);
+}
+|
+    DUMP
+{
+	$$ = build(O_DUMP);
+}
+|
+    STATUS
+{
+	$$ = build(O_STATUS);
+}
+;
+alias_command:
+    ALIAS name name
+{
+	$$ = build(O_ALIAS, build(O_NAME, $2), build(O_NAME, $3));
+}
+|
+    ALIAS name
+{
+	$$ = build(O_ALIAS, build(O_NAME, $2), nil);
+}
+|
+    ALIAS
+{
+	$$ = build(O_ALIAS, nil, nil);
+}
+;
+trace:
+    TRACE
+{
+	$$ = O_TRACE;
+}
+|
+    TRACEI
+{
+	$$ = O_TRACEI;
+}
+;
+stop:
+    STOP
+{
+	$$ = O_STOP;
+}
+|
+    STOPI
+{
+	$$ = O_STOPI;
+}
+;
+what:
+    exp
+{
+	$$ = $1;
+}
+|
+    STRING ':' line_number
+{
+	$$ = build(O_QLINE, build(O_SCON, $1), $3);
+}
+;
+where:
+    IN term
+{
+	$$ = $2;
+}
+|
+    AT line_number
+{
+	$$ = build(O_QLINE, build(O_SCON, cursource), $2);
+}
+|
+    AT STRING ':' line_number
+{
+	$$ = build(O_QLINE, build(O_SCON, $2), $4);
+}
+;
+filename:
+    NAME
+{
+	$$ = ident($1);
+}
+;
+opt_filename:
+    /* empty */
+{
+	$$ = nil;
+}
+|
+    filename
+{
+	$$ = $1;
+}
+;
+opt_exp_list:
+    exp_list
+{
+	$$ = $1;
+}
+|
+    /* empty */
+{
+	$$ = nil;
+}
+;
+list_command:
+    LIST
+{
+	$$ = build(O_LIST,
+	    build(O_LCON, (long) cursrcline),
+	    build(O_LCON, (long) cursrcline + 9)
+	);
+}
+|
+    LIST line_number
+{
+	$$ = build(O_LIST, $2, $2);
+}
+|
+    LIST line_number ',' line_number
+{
+	$$ = build(O_LIST, $2, $4);
+}
+|
+    LIST symbol
+{
+	$$ = build(O_LIST, $2);
+}
+;
+line_number:
+    INT
+{
+	$$ = build(O_LCON, $1);
+}
+|
+    '$'
+{
+	$$ = build(O_LCON, (long) LASTLINE);
+}
+;
+examine:
+    address '/' count mode
+{
+	$$ = build(O_EXAMINE, $4, $1, nil, $3);
+}
+|
+    address ',' address '/' mode
+{
+	$$ = build(O_EXAMINE, $5, $1, $3, 0);
+}
+|
+    '/' count mode
+{
+	$$ = build(O_EXAMINE, $3, build(O_LCON, (long) prtaddr), nil, $2);
+}
+|
+    address '=' mode
+{
+	$$ = build(O_EXAMINE, $3, $1, nil, 0);
+}
+;
+address:
+    INT
+{
+	$$ = build(O_LCON, $1);
+}
+|
+    '&' term
+{
+	$$ = amper($2);
+}
+|
+    address '+' address
+{
+	$$ = build(O_ADD, $1, $3);
+}
+|
+    address '-' address
+{
+	$$ = build(O_SUB, $1, $3);
+}
+|
+    address '*' address
+{
+	$$ = build(O_MUL, $1, $3);
+}
+|
+    '*' address %prec UNARYSIGN
+{
+	$$ = build(O_INDIR, $2);
+}
+|
+    '(' exp ')'
+{
+	$$ = $2;
+}
+;
+count:
+    /* empty */
+{
+	$$ = 1;
+}
+|
+    INT
+{
+	$$ = $1;
+}
+;
+mode:
+    name
+{
+	$$ = ident($1);
+	curformat = $$;
+}
+|
+    /* empty */
+{
+	$$ = curformat;
+}
+;
+opt_cond:
+    /* empty */
+{
+	$$ = nil;
+}
+|
+    IF boolean_exp
+{
+	$$ = $2;
+}
+;
+exp_list:
+    exp
+{
+	$$ = build(O_COMMA, $1, nil);
+}
+|
+    exp ',' exp_list
+{
+	$$ = build(O_COMMA, $1, $3);
+}
+;
+exp:
+    term
+{
+	$$ = build(O_RVAL, $1);
+}
+|
+    constant
+{
+	$$ = $1;
+}
+|
+    exp '\\' symbol
+{
+	$$ = build(O_TYPERENAME, $1, $3);
+}
+|
+    '+' exp %prec UNARYSIGN
+{
+	$$ = $2;
+}
+|
+    '-' exp %prec UNARYSIGN
+{
+	$$ = build(O_NEG, $2);
+}
+|
+    '&' exp %prec UNARYSIGN
+{
+	$$ = amper($2);
+}
+|
+    exp '+' exp
+{
+	$$ = build(O_ADD, $1, $3);
+}
+|
+    exp '-' exp
+{
+	$$ = build(O_SUB, $1, $3);
+}
+|
+    exp '*' exp
+{
+	$$ = build(O_MUL, $1, $3);
+}
+|
+    exp '/' exp
+{
+	$$ = build(O_DIVF, $1, $3);
+}
+|
+    exp DIV exp
+{
+	$$ = build(O_DIV, $1, $3);
+}
+|
+    exp MOD exp
+{
+	$$ = build(O_MOD, $1, $3);
+}
+|
+    exp AND exp
+{
+	$$ = build(O_AND, $1, $3);
+}
+|
+    exp OR exp
+{
+	$$ = build(O_OR, $1, $3);
+}
+|
+    exp '<' exp
+{
+	$$ = build(O_LT, $1, $3);
+}
+|
+    exp '<' '=' exp
+{
+	$$ = build(O_LE, $1, $4);
+}
+|
+    exp '>' exp
+{
+	$$ = build(O_GT, $1, $3);
+}
+|
+    exp '>' '=' exp
+{
+	$$ = build(O_GE, $1, $4);
+}
+|
+    exp '=' exp
+{
+	$$ = build(O_EQ, $1, $3);
+}
+|
+    exp '=' '=' exp
+{
+	$$ = build(O_EQ, $1, $4);
+}
+|
+    exp '<' '>' exp
+{
+	$$ = build(O_NE, $1, $4);
+}
+|
+    exp '!' '=' exp
+{
+	$$ = build(O_NE, $1, $4);
+}
+|
+    '(' exp ')'
+{
+	$$ = $2;
+}
+;
+term:
+    symbol
+{
+	$$ = $1;
+}
+|
+    term '[' exp_list ']'
+{
+	$$ = subscript($1, $3);
+}
+|
+    term '.' name
+{
+	$$ = dot($1, $3);
+}
+|
+    term ARROW name
+{
+	$$ = dot($1, $3);
+}
+|
+    '*' term %prec UNARYSIGN
+{
+	$$ = build(O_INDIR, $2);
+}
+|
+    '*' '(' exp ')' %prec UNARYSIGN
+{
+	$$ = build(O_INDIR, $3);
+}
+|
+    term '^' %prec UNARYSIGN
+{
+	$$ = build(O_INDIR, $1);
+}
+|
+    '#' term %prec UNARYSIGN
+{
+	$$ = concrete($2);
+}
+|
+    term '(' opt_exp_list ')'
+{
+	$$ = build(O_CALL, $1, $3);
+}
+;
+boolean_exp:
+    exp
+{
+	chkboolean($1);
+	$$ = $1;
+}
+;
+constant:
+    INT
+{
+	$$ = build(O_LCON, $1);
+}
+|
+    REAL
+{
+	$$ = build(O_FCON, $1);
+}
+|
+    STRING
+{
+	$$ = build(O_SCON, $1);
+}
+;
+symbol:
+    name
+{
+	$$ = build(O_SYM, which($1));
+}
+;
+name:
+    NAME
+{
+	$$ = $1;
+}
+|
+    keyword
+{
+	$$ = $1;
+}
+keyword:
+    ALIAS | AND | ASSIGN | AT | CALL | CATCH | CONT | DEBUG | DELETE | DIV | 
+    DUMP | EDIT | FILE | FUNC | GRIPE | HELP | IGNORE | IN | LIST | MOD |
+    NEXT | NEXTI | NIL | NOT | OR | PRINT | PSYM | QUIT | RUN |
+    SH | SKIP | SOURCE | STATUS | STEP | STEPI |
+    STOP | STOPI | TRACE | TRACEI |
+    USE | WHATIS | WHEN | WHERE | WHEREIS | WHICH
+;
diff --git a/dbx/coredump.c b/dbx/coredump.c
new file mode 100644
index 0000000..1df64c6
--- /dev/null
+++ b/dbx/coredump.c
@@ -0,0 +1,156 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)coredump.c 1.4 1/25/83";
+
+/*
+ * Deal with the core dump anachronism.
+ *
+ * If I understood this code, I'd try to make it readable.
+ */
+
+#include "defs.h"
+#include "coredump.h"
+#include "machine.h"
+#include "object.h"
+#include "main.h"
+#include <sys/param.h>
+#include <sys/dir.h>
+#include <machine/psl.h>
+#include <machine/pte.h>
+#include <sys/user.h>
+#include <sys/vm.h>
+#include <machine/reg.h>
+#include <a.out.h>
+
+#ifndef public
+#define coredump_readin(m, r, s) coredump_xreadin(&(m), r, &(s))
+
+#include "machine.h"
+#endif
+
+#define MAXSTKADDR (0x80000000 - ctob(UPAGES))	/* highest stack address */
+
+typedef struct {
+    Address begin;
+    Address end;
+    Address seekaddr;
+} Map;
+
+private Map datamap, stkmap;
+private File objfile;
+private struct exec hdr;
+
+/*
+ * Read the user area information from the core dump.
+ */
+
+public coredump_xreadin(mask, reg, signo)
+int *mask;
+Word reg[];
+int *signo;
+{
+    register struct user *up;
+    register Word *savreg;
+    union {
+	struct user u;
+	char dummy[ctob(UPAGES)];
+    } ustruct;
+
+    objfile = fopen(objname, "r");
+    if (objfile == nil) {
+	fatal("can't read \"%s\"", objname);
+    }
+    get(objfile, hdr);
+    up = &(ustruct.u);
+    fread(up, ctob(UPAGES), 1, corefile);
+    savreg = (Word *) &(ustruct.dummy[ctob(UPAGES)]);
+    *mask = savreg[PS];
+    reg[0] = savreg[R0];
+    reg[1] = savreg[R1];
+    reg[2] = savreg[R2];
+    reg[3] = savreg[R3];
+    reg[4] = savreg[R4];
+    reg[5] = savreg[R5];
+    reg[6] = savreg[R6];
+    reg[7] = savreg[R7];
+    reg[8] = savreg[R8];
+    reg[9] = savreg[R9];
+    reg[10] = savreg[R10];
+    reg[11] = savreg[R11];
+    reg[ARGP] = savreg[AP];
+    reg[FRP] = savreg[FP];
+    reg[STKP] = savreg[SP];
+    reg[PROGCTR] = savreg[PC];
+    *signo = up->u_arg[0];
+    datamap.seekaddr = ctob(UPAGES);
+    stkmap.begin = MAXSTKADDR - ctob(up->u_ssize);
+    stkmap.end = MAXSTKADDR;
+    stkmap.seekaddr = datamap.seekaddr + ctob(up->u_dsize);
+    switch (hdr.a_magic) {
+	case OMAGIC:
+	    datamap.begin = 0;
+	    datamap.end = ctob(up->u_tsize) + ctob(up->u_dsize);
+	    break;
+
+	case NMAGIC:
+	case ZMAGIC:
+	    datamap.begin = (Address) ptob(btop(ctob(up->u_tsize) - 1) + 1);
+	    datamap.end = datamap.begin + ctob(up->u_dsize);
+	    break;
+
+	default:
+	    fatal("bad magic number 0x%x", hdr.a_magic);
+    }
+    /*
+     * Core dump not from this object file?
+     */
+    if (hdr.a_magic != 0 and up->u_exdata.ux_mag  != 0 and
+      hdr.a_magic != up->u_exdata.ux_mag) {
+	warning("core dump ignored");
+	coredump = false;
+	fclose(corefile);
+	fclose(objfile);
+	start(nil, nil, nil);
+    }
+}
+
+public coredump_close()
+{
+    fclose(objfile);
+}
+
+public coredump_readtext(buff, addr, nbytes)
+char *buff;
+Address addr;
+int nbytes;
+{
+    if (hdr.a_magic == OMAGIC) {
+	coredump_readdata(buff, addr, nbytes);
+    } else {
+	fseek(objfile, N_TXTOFF(hdr) + addr, 0);
+	fread(buff, nbytes, sizeof(Byte), objfile);
+    }
+}
+
+public coredump_readdata(buff, addr, nbytes)
+char *buff;
+Address addr;
+int nbytes;
+{
+    if (addr < datamap.begin) {
+	if (addr < hdr.a_text && hdr.a_magic != OMAGIC) {
+	    fseek(objfile, N_TXTOFF(hdr) + addr, 0);
+	    fread(buff, nbytes, sizeof(Byte), objfile);
+	}
+	else
+	    error("data address 0x%x too low (lb = 0x%x)", addr, datamap.begin);
+    } else if (addr > stkmap.end) {
+	error("data address 0x%x too high (ub = 0x%x)", addr, stkmap.end);
+    } else if (addr < stkmap.begin) {
+	fseek(corefile, datamap.seekaddr + addr - datamap.begin, 0);
+	fread(buff, nbytes, sizeof(Byte), corefile);
+    } else {
+	fseek(corefile, stkmap.seekaddr + addr - stkmap.begin, 0);
+	fread(buff, nbytes, sizeof(Byte), corefile);
+    }
+}
diff --git a/dbx/coredump.h b/dbx/coredump.h
new file mode 100644
index 0000000..22553e5
--- /dev/null
+++ b/dbx/coredump.h
@@ -0,0 +1,10 @@
+#ifndef coredump_h
+#define coredump_h
+#define coredump_readin(m, r, s) coredump_xreadin(&(m), r, &(s))
+
+#include "machine.h"
+coredump_xreadin(/* mask, reg, signo */);
+coredump_close(/*  */);
+coredump_readtext(/* buff, addr, nbytes */);
+coredump_readdata(/* buff, addr, nbytes */);
+#endif
diff --git a/dbx/date.c b/dbx/date.c
new file mode 100644
index 0000000..3700b82
--- /dev/null
+++ b/dbx/date.c
@@ -0,0 +1 @@
+char *date = "3/15/85 19:15 (mit-prep)";
diff --git a/dbx/debug.c b/dbx/debug.c
new file mode 100644
index 0000000..95eebca
--- /dev/null
+++ b/dbx/debug.c
@@ -0,0 +1,233 @@
+
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)debug.c	1.3	5/18/83";
+
+/*
+ *  Debug routines
+ */
+
+#include "defs.h"
+#include "tree.h"
+#include "operators.h"
+#include "eval.h"
+#include "events.h"
+#include "symbols.h"
+#include "scanner.h"
+#include "source.h"
+#include "object.h"
+#include "mappings.h"
+#include "process.h"
+#include "machine.h"
+#include <signal.h>
+
+
+public int debug_flag[20];
+
+public debug(p)
+Node p;
+{
+   int code;
+   code = p->value.lcon;
+
+   if ( (code >= 0) and (code < 10) ) {
+   	switch(code)  {
+	case 2:   if(debug_flag[2])  debug_flag[2]=0;
+		  else debug_flag[2] =1;
+                  printf(" flag 2 is %d \n",debug_flag[2]);
+	          break;
+
+	case 3:   if(debug_flag[3])  debug_flag[3]=0;
+		  else debug_flag[3] =1;
+                  printf(" flag 3 is %d \n",debug_flag[3]);
+	          break;
+
+	case 4:   if(debug_flag[4])  debug_flag[4]=0;
+		  else debug_flag[4] =1;
+                  printf(" flag 4 is %d \n",debug_flag[4]);
+	          break;
+
+	case 5:   if(debug_flag[5])  debug_flag[5]=0;
+		  else debug_flag[5] =1;
+                  printf(" flag 5 is %d \n",debug_flag[5]);
+	          break;
+
+	case 6:   dumpfunctab();
+	          break;
+
+	default:  printf(" unknown debug code %ld \n",p->value.lcon);
+                  break;
+        }
+   }
+   else if (debug_flag[3]) symbol_dump(code);
+   else if (debug_flag[4]) psym(code);
+}
+
+public char *showoperator(op)
+Operator op;
+{
+static char *operator_str[] = {
+"O_NOP", "O_NAME", "O_SYM", "O_LCON", "O_FCON", "O_SCON", "O_RVAL", "O_INDEX",
+"O_INDIR", "O_DOT", "O_COMMA", "O_ITOF", "O_ADD", "O_ADDF", "O_SUB", "O_SUBF",
+"O_NEG", "O_NEGF", "O_MUL", "O_MULF", "O_DIVF", "O_DIV", "O_MOD", "O_AND",
+"O_OR", "O_LT", "O_LTF", "O_LE", "O_LEF", "O_GT", "O_GTF", "O_GE", "O_GEF",
+"O_EQ", "O_EQF", "O_NE", "O_NEF", "O_ALIAS", "O_ASSIGN", "O_CALL", "O_CATCH",
+"O_CHFILE", "O_CONT", "O_DEBUG", "O_DELETE", "O_DUMP", "O_EDIT", "O_FUNC",
+"O_GRIPE", "O_HELP", "O_IGNORE", "O_LIST", "O_PRINT", "O_PSYM", "O_RUN",
+"O_SKIP", "O_SOURCE", "O_STATUS", "O_STEP", "O_STOP", "O_STOPI", "O_TRACE",
+"O_TRACEI", "O_WHATIS", "O_WHERE", "O_WHEREIS", "O_WHICH", "O_EXAMINE",
+"O_ADDEVENT", "O_ENDX", "O_IF", "O_ONCE", "O_PRINTCALL", "O_PRINTIFCHANGED",
+"O_PRINTRTN", "O_PRINTSRCPOS", "O_PROCRTN", "O_QLINE", "O_STOPIFCHANGED",
+"O_STOPX", "O_TRACEON", "O_TRACEOFF", "O_TYPERENAME", "O_LASTOP" };
+return( operator_str[ord(op)] );
+}
+
+/*
+ * Dump a tree recursively
+ */
+
+public dumptree(f, p)
+File f;
+register Node p;
+{
+    register Node q;
+    Operator op;
+    static recurse  =0;
+    ++recurse;
+
+    if (p != nil) {
+	op = p->op;
+	if (ord(op) > ord(O_LASTOP)) {
+	    panic("bad op %d in dumptree", p->op);
+	}
+        { int n_args;
+	  fprintf(f, "\n level %d op %s node %ld ",recurse,showoperator(op), p);
+          for(n_args=0;n_args < nargs(op); n_args++) 
+            fprintf(f," arg%d %ld ",n_args,p->value.arg[n_args]);
+          fprintf(f,"\n");
+        }
+        if(p->nodetype) {fprintf(f,"nodetype: "); psym(p->nodetype);}
+	switch (op) {
+	    case O_NAME:
+		fprintf(f, "%s", ident(p->value.name));
+		break;
+
+	    case O_SYM:
+		printname(f, p->value.sym);
+		break;
+
+	    case O_QLINE:
+		if (nlhdr.nfiles > 1) {
+		    dumptree(f, p->value.arg[0]);
+		    fprintf(f, ":");
+		}
+		dumptree(f, p->value.arg[1]);
+		break;
+
+	    case O_LCON:
+		if (compatible(p->nodetype, t_char)) {
+		    fprintf(f, "'%c'", p->value.lcon);
+		} else {
+		    fprintf(f, "%d", p->value.lcon);
+		}
+		break;
+
+	    case O_FCON:
+		fprintf(f, "%g", p->value.fcon);
+		break;
+
+	    case O_SCON:
+		fprintf(f, "\"%s\"", p->value.scon);
+		break;
+
+	    case O_INDEX:
+		dumptree(f, p->value.arg[0]);
+		fprintf(f, "[");
+		dumptree(f, p->value.arg[1]);
+		fprintf(f, "]");
+		break;
+
+	    case O_COMMA:
+		dumptree(f, p->value.arg[0]);
+		if (p->value.arg[1] != nil) {
+		    fprintf(f, ", ");
+		    dumptree(f, p->value.arg[1]);
+		}
+		break;
+
+	    case O_RVAL:
+		if (p->value.arg[0]->op == O_SYM) {
+		    printname(f, p->value.arg[0]->value.sym);
+		} else {
+		    dumptree(f, p->value.arg[0]);
+		}
+		break;
+
+	    case O_ITOF:
+		dumptree(f, p->value.arg[0]);
+		break;
+
+	    case O_CALL:
+		dumptree(f, p->value.arg[0]);
+		if (p->value.arg[1]!= nil) {
+		    fprintf(f, "(");
+		    dumptree(f, p->value.arg[1]);
+		    fprintf(f, ")");
+		}
+		break;
+
+	    case O_INDIR:
+		q = p->value.arg[0];
+		if (isvarparam(q->nodetype)) {
+		    dumptree(f, q);
+		} else {
+		    if (q->op == O_SYM or q->op == O_LCON or q->op == O_DOT) {
+			dumptree(f, q);
+			fprintf(f, "^");
+		    } else {
+			fprintf(f, "*(");
+			dumptree(f, q);
+			fprintf(f, ")");
+		    }
+		}
+		break;
+
+	    case O_DOT:
+		q = p->value.arg[0];
+		if (q->op == O_INDIR) {
+		    dumptree(f, q->value.arg[0]);
+		} else {
+		    dumptree(f, q);
+		}
+		fprintf(f, ".%s", symname(p->value.arg[1]->value.sym));
+		break;
+
+	    default:
+		switch (degree(op)) {
+		    case BINARY:
+			dumptree(f, p->value.arg[0]);
+			fprintf(f, "%s", opinfo[ord(op)].opstring);
+			dumptree(f, p->value.arg[1]);
+			break;
+
+		    case UNARY:
+			fprintf(f, "%s", opinfo[ord(op)].opstring);
+			dumptree(f, p->value.arg[0]);
+			break;
+
+		    default:
+                        if(degree(op) < ord(O_LASTOP) )
+                        {      int i;
+                               if( nargs(op)  != 0) 
+                                 for(i=0;i<nargs(op);i++) 
+                                  dumptree(f, p->value.arg[i]);
+			} 
+			else
+                          error("internal error: bad op %d in dumptree", op);
+		}
+		break;
+	}
+    }
+   recurse--;
+   fflush(f);
+}
diff --git a/dbx/defs.h b/dbx/defs.h
new file mode 100644
index 0000000..aad149d
--- /dev/null
+++ b/dbx/defs.h
@@ -0,0 +1,70 @@
+/*	defs.h	1.1	83/08/13	*/
+
+/*
+ * Public definitions, common to all.
+ */
+
+#include <stdio.h>
+
+#define new(type)           ((type) malloc(sizeof(struct type)))
+#define newarr(type, n)     ((type *) malloc((unsigned) (n) * sizeof(type)))
+#define dispose(ptr)        { free((char *) ptr); ptr = 0; }
+
+#define public
+#define private static
+
+#define ord(enumcon) ((unsigned int) enumcon)
+#define nil 0
+#define and &&
+#define or ||
+#define not !
+#define div /
+#define mod %
+#define max(a, b)    ((a) > (b) ? (a) : (b))
+#define min(a, b)    ((a) < (b) ? (a) : (b))
+
+#define assert(b) { \
+    if (not(b)) { \
+	panic("assertion failed at line %d in file %s", __LINE__, __FILE__); \
+    } \
+}
+
+#define badcaseval(v) { \
+    panic("unexpected value %d at line %d in file %s", v, __LINE__, __FILE__); \
+}
+
+#define checkref(p) { \
+    if (p == nil) { \
+	panic("reference through nil pointer at line %d in file %s", \
+	    __LINE__, __FILE__); \
+    } \
+}
+
+typedef int Integer;
+typedef char Char;
+typedef double Real;
+typedef enum { false, true } Boolean;
+typedef char *String;
+
+#define strdup(s)       strcpy(malloc((unsigned) strlen(s) + 1), s)
+#define streq(s1, s2)   (strcmp(s1, s2) == 0)
+
+typedef FILE *File;
+typedef int Fileid;
+typedef String Filename;
+
+#define get(f, var) fread((char *) &(var), sizeof(var), 1, f)
+#define put(f, var) fwrite((char *) &(var), sizeof(var), 1, f)
+
+#undef FILE
+
+extern long atol();
+extern double atof();
+extern char *malloc();
+extern String strcpy(), index(), rindex();
+extern int strlen();
+
+extern String cmdname;
+extern String errfilename;
+extern short errlineno;
+extern int debug_flag[];
diff --git a/dbx/eval.c b/dbx/eval.c
new file mode 100644
index 0000000..f22e976
--- /dev/null
+++ b/dbx/eval.c
@@ -0,0 +1,1180 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)eval.c 1.10 8/17/83";
+
+/*
+ * Tree evaluation.
+ */
+
+#include "defs.h"
+#include "tree.h"
+#include "operators.h"
+#include "eval.h"
+#include "events.h"
+#include "symbols.h"
+#include "scanner.h"
+#include "source.h"
+#include "object.h"
+#include "mappings.h"
+#include "process.h"
+#include "machine.h"
+#include <signal.h>
+
+#ifndef public
+
+#include "machine.h"
+
+#define STACKSIZE 20000
+
+typedef Char Stack;
+
+#define push(type, value) { \
+    ((type *) (sp += sizeof(type)))[-1] = (value); \
+}
+
+#define pop(type) ( \
+    (*((type *) (sp -= sizeof(type)))) \
+)
+
+#define alignstack() { \
+    sp = (Stack *) (( ((int) sp) + sizeof(int) - 1)&~(sizeof(int) - 1)); \
+}
+
+#endif
+
+public Stack stack[STACKSIZE];
+public Stack *sp = &stack[0];
+public Boolean useInstLoc = false;
+
+#define chksp() \
+{ \
+    if (sp < &stack[0]) { \
+	panic("stack underflow"); \
+    } \
+}
+
+#define poparg(n, r, fr) { \
+    eval(p->value.arg[n]); \
+    if (isreal(p->op)) { \
+	fr = pop(double); \
+    } else if (isint(p->op)) { \
+	r = popsmall(p->value.arg[n]->nodetype); \
+    } \
+}
+
+#define Boolrep char	/* underlying representation type for booleans */
+
+/*
+ * Evaluate a parse tree leaving the value on the top of the stack.
+ */
+
+public eval(p)
+register Node p;
+{
+    long r0, r1;
+    double fr0, fr1;
+    Address addr;
+    long i, n;
+    int len;
+    Symbol s, f;
+    Node n1, n2;
+    Boolean b;
+    File file;
+
+    checkref(p);
+    if (debug_flag[2]) {
+	fprintf(stderr," evaluating %s \n",showoperator(p->op));
+    }
+    switch (degree(p->op)) {
+	case BINARY:
+	    poparg(1, r1, fr1);
+	    poparg(0, r0, fr0);
+	    break;
+
+	case UNARY:
+	    poparg(0, r0, fr0);
+	    break;
+
+	default:
+	    /* do nothing */;
+    }
+    switch (p->op) {
+	case O_SYM:
+	    s = p->value.sym;
+	    if (s == retaddrsym) {
+		push(long, return_addr());
+	    } else {
+		if (isvariable(s)) {
+		    if (s != program and not isactive(container(s))) {
+			error("\"%s\" is not active", symname(s));
+		    }
+		    push(long, address(s, nil));
+		} else if (isblock(s)) {
+		    push(Symbol, s);
+		} else {
+		    error("can't evaluate a %s", classname(s));
+		}
+	    }
+	    break;
+
+	case O_LCON:
+	    r0 = p->value.lcon;
+	    pushsmall(p->nodetype, r0);
+	    break;
+
+	case O_FCON:
+	    push(double, p->value.fcon);
+	    break;
+
+	case O_SCON:
+	    len = size(p->nodetype);
+	    mov(p->value.scon, sp, len);
+	    sp += len;
+	    break;
+
+	case O_INDEX:
+	    n = pop(long);
+	    i = evalindex(p->value.arg[0]->nodetype,
+		popsmall(p->value.arg[1]->nodetype));
+	    push(long, n + i*size(p->nodetype));
+	    break;
+
+	case O_DOT:
+	    s = p->value.arg[1]->value.sym;
+	    n = lval(p->value.arg[0]);
+	    push(long, n + (s->symvalue.field.offset div 8));
+	    break;
+
+	/*
+	 * Get the value of the expression addressed by the top of the stack.
+	 * Push the result back on the stack.
+	 */
+
+	case O_INDIR:
+	case O_RVAL:
+	    addr = pop(long);
+	    if (addr == 0) {
+		error("reference through nil pointer");
+	    }
+	    if (p->op == O_INDIR) {
+		len = sizeof(long);
+	    } else {
+		len = size(p->nodetype);
+	    }
+	    rpush(addr, len);
+	addr = pop(long);
+        push(long, addr);
+	    break;
+
+	/*
+	 * Effectively, we want to pop n bytes off for the evaluated subtree
+	 * and push len bytes on for the new type of the same tree.
+	 */
+	case O_TYPERENAME:
+	    n = size(p->value.arg[0]->nodetype);
+	    len = size(p->nodetype);
+	    sp = sp - n + len;
+	    break;
+
+	case O_COMMA:
+	    break;
+
+	case O_ITOF:
+	    push(double, (double) r0);
+	    break;
+
+	case O_ADD:
+	    push(long, r0+r1);
+	    break;
+
+	case O_ADDF:
+	    push(double, fr0+fr1);
+	    break;
+
+	case O_SUB:
+	    push(long, r0-r1);
+	    break;
+
+	case O_SUBF:
+	    push(double, fr0-fr1);
+	    break;
+
+	case O_NEG:
+	    push(long, -r0);
+	    break;
+
+	case O_NEGF:
+	    push(double, -fr0);
+	    break;
+
+	case O_MUL:
+	    push(long, r0*r1);
+	    break;
+
+	case O_MULF:
+	    push(double, fr0*fr1);
+	    break;
+
+	case O_DIVF:
+	    if (fr1 == 0) {
+		error("error: division by 0");
+	    }
+	    push(double, fr0 / fr1);
+	    break;
+
+	case O_DIV:
+	    if (r1 == 0) {
+		error("error: div by 0");
+	    }
+	    push(long, r0 div r1);
+	    break;
+
+	case O_MOD:
+	    if (r1 == 0) {
+		error("error: mod by 0");
+	    }
+	    push(long, r0 mod r1);
+	    break;
+
+	case O_LT:
+	    push(Boolrep, r0 < r1);
+	    break;
+
+	case O_LTF:
+	    push(Boolrep, fr0 < fr1);
+	    break;
+
+	case O_LE:
+	    push(Boolrep, r0 <= r1);
+	    break;
+
+	case O_LEF:
+	    push(Boolrep, fr0 <= fr1);
+	    break;
+
+	case O_GT:
+	    push(Boolrep, r0 > r1);
+	    break;
+
+	case O_GTF:
+	    push(Boolrep, fr0 > fr1);
+	    break;
+
+	case O_EQ:
+	    push(Boolrep, r0 == r1);
+	    break;
+
+	case O_EQF:
+	    push(Boolrep, fr0 == fr1);
+	    break;
+
+	case O_NE:
+	    push(Boolrep, r0 != r1);
+	    break;
+
+	case O_NEF:
+	    push(Boolrep, fr0 != fr1);
+	    break;
+
+	case O_AND:
+	    push(Boolrep, r0 and r1);
+	    break;
+
+	case O_OR:
+	    push(Boolrep, r0 or r1);
+	    break;
+
+	case O_ASSIGN:
+	    assign(p->value.arg[0], p->value.arg[1]);
+	    break;
+
+	case O_CHFILE:
+	    if (p->value.scon == nil) {
+		printf("%s\n", cursource);
+	    } else {
+		file = opensource(p->value.scon);
+		if (file == nil) {
+		    error("can't read \"%s\"", p->value.scon);
+		} else {
+		    fclose(file);
+		    setsource(p->value.scon);
+		}
+	    }
+	    break;
+
+	case O_CONT:
+	    cont(p->value.lcon);
+	    printnews();
+	    break;
+
+	case O_LIST:
+	    if (p->value.arg[0]->op == O_SYM) {
+		f = p->value.arg[0]->value.sym;
+		addr = firstline(f);
+		if (addr == NOADDR) {
+		    error("no source lines for \"%s\"", symname(f));
+		}
+		setsource(srcfilename(addr));
+		r0 = srcline(addr) - 5;
+		r1 = r0 + 10;
+		if (r0 < 1) {
+		    r0 = 1;
+		}
+	    } else {
+		eval(p->value.arg[0]);
+		r0 = pop(long);
+		eval(p->value.arg[1]);
+		r1 = pop(long);
+	    }
+	    printlines((Lineno) r0, (Lineno) r1);
+	    break;
+
+	case O_FUNC:
+	    if (p->value.arg[0] == nil) {
+		printname(stdout, curfunc);
+		putchar('\n');
+	    } else {
+		s = p->value.arg[0]->value.sym;
+		find(f, s->name) where
+		    f->class == FUNC or f->class == PROC
+		endfind(f);
+		if (f == nil) {
+		    error("%s is not a procedure or function", symname(s));
+		}
+		curfunc = f;
+		addr = codeloc(curfunc);
+		if (addr != NOADDR) {
+		    setsource(srcfilename(addr));
+		    cursrcline = srcline(addr) - 5;
+		    if (cursrcline < 1) {
+			cursrcline = 1;
+		    }
+		}
+	    }
+	    break;
+
+	case O_EXAMINE:
+	    eval(p->value.examine.beginaddr);
+	    r0 = pop(long);
+	    if (p->value.examine.endaddr == nil) {
+		n = p->value.examine.count;
+		if (n == 0) {
+		    printvalue(r0, p->value.examine.mode);
+		} else if (streq(p->value.examine.mode, "i")) {
+		    printninst(n, (Address) r0);
+		} else {
+		    printndata(n, (Address) r0, p->value.examine.mode);
+		}
+	    } else {
+		eval(p->value.examine.endaddr);
+		r1 = pop(long);
+		if (streq(p->value.examine.mode, "i")) {
+		    printinst((Address)r0, (Address)r1);
+		} else {
+		    printdata((Address)r0, (Address)r1, p->value.examine.mode);
+		}
+	    }
+	    break;
+
+	case O_PRINT:
+	    for (n1 = p->value.arg[0]; n1 != nil; n1 = n1->value.arg[1]) {
+		eval(n1->value.arg[0]);
+		printval(n1->value.arg[0]->nodetype);
+		putchar(' ');
+	    }
+	    putchar('\n');
+	    break;
+
+	case O_PSYM:
+	    if (p->value.arg[0]->op == O_SYM) {
+		psym(p->value.arg[0]->value.sym);
+	    } else {
+		psym(p->value.arg[0]->nodetype);
+	    }
+	    break;
+
+	case O_QLINE:
+	    eval(p->value.arg[1]);
+	    break;
+
+	case O_STEP:
+	    b = inst_tracing;
+	    inst_tracing = (Boolean) (not p->value.step.source);
+	    if (p->value.step.skipcalls) {
+		next();
+	    } else {
+		stepc();
+	    }
+	    inst_tracing = b;
+	    useInstLoc = (Boolean) (not p->value.step.source);
+	    printnews();
+	    break;
+
+	case O_WHATIS:
+	    if (p->value.arg[0]->op == O_SYM) {
+		printdecl(p->value.arg[0]->value.sym);
+	    } else {
+		printdecl(p->value.arg[0]->nodetype);
+	    }
+	    break;
+
+	case O_WHERE:
+	    wherecmd();
+	    break;
+
+	case O_WHEREIS:
+	    if (p->value.arg[0]->op == O_SYM) {
+		printwhereis(stdout,p->value.arg[0]->value.sym);
+	    } else {
+		printwhereis(stdout,p->value.arg[0]->nodetype);
+	    }
+	    break;
+
+	case O_WHICH:
+	    if (p->value.arg[0]->op == O_SYM) {
+		printwhich(stdout,p->value.arg[0]->value.sym);
+	    } else {
+		printwhich(stdout,p->value.arg[0]->nodetype);
+	    }
+	    putchar('\n');
+	    break;
+
+	case O_ALIAS:
+	    n1 = p->value.arg[0];
+	    n2 = p->value.arg[1];
+	    if (n1 == nil) {
+		print_alias(nil);
+	    } else if (n2 == nil) {
+		print_alias(n1->value.name);
+	    } else {
+		enter_alias(n1->value.name, n2->value.name);
+	    }
+	    break;
+
+	case O_CALL:
+	    callproc(p->value.arg[0], p->value.arg[1]);
+	    break;
+
+	case O_CATCH:
+	    psigtrace(process, p->value.lcon, true);
+	    break;
+
+	case O_EDIT:
+	    edit(p->value.scon);
+	    break;
+
+        case O_DEBUG:
+            debug(p);
+	    break;
+
+	case O_DUMP:
+	    dump();
+	    break;
+
+	case O_GRIPE:
+	    gripe();
+	    break;
+
+	case O_HELP:
+	    help();
+	    break;
+
+	case O_IGNORE:
+	    psigtrace(process, p->value.lcon, false);
+	    break;
+
+	case O_RUN:
+	    run();
+	    break;
+
+	case O_SOURCE:
+	    setinput(p->value.scon);
+	    break;
+
+	case O_STATUS:
+	    status();
+	    break;
+
+	case O_TRACE:
+	case O_TRACEI:
+	    trace(p);
+	    break;
+
+	case O_STOP:
+	case O_STOPI:
+	    stop(p);
+	    break;
+
+	case O_ADDEVENT:
+	    addevent(p->value.event.cond, p->value.event.actions);
+	    break;
+
+	case O_DELETE:
+	    delevent((unsigned int) p->value.lcon);
+	    break;
+
+	case O_ENDX:
+	    endprogram();
+	    break;
+
+	case O_IF:
+	    if (cond(p->value.event.cond)) {
+		evalcmdlist(p->value.event.actions);
+	    }
+	    break;
+
+	case O_ONCE:
+	    event_once(p->value.event.cond, p->value.event.actions);
+	    break;
+
+	case O_PRINTCALL:
+	    printcall(p->value.sym, whatblock(return_addr()));
+	    break;
+
+	case O_PRINTIFCHANGED:
+	    printifchanged(p->value.arg[0]);
+	    break;
+
+	case O_PRINTRTN:
+	    printrtn(p->value.sym);
+	    break;
+
+	case O_PRINTSRCPOS:
+	    getsrcpos();
+	    if (p->value.arg[0] == nil) {
+		printsrcpos();
+		putchar('\n');
+		printlines(curline, curline);
+	    } else if (p->value.arg[0]->op == O_QLINE) {
+		if (p->value.arg[0]->value.arg[1]->value.lcon == 0) {
+		    printf("tracei: ");
+		    printinst(pc, pc);
+		} else {
+		    printf("trace:  ");
+		    printlines(curline, curline);
+		}
+	    } else {
+		printsrcpos();
+		printf(": ");
+		eval(p->value.arg[0]);
+		prtree(stdout, p->value.arg[0]);
+		printf(" = ");
+		printval(p->value.arg[0]->nodetype);
+		putchar('\n');
+	    }
+	    break;
+
+	case O_PROCRTN:
+	    procreturn(p->value.sym);
+	    break;
+
+	case O_STOPIFCHANGED:
+	    stopifchanged(p->value.arg[0]);
+	    break;
+
+	case O_STOPX:
+	    isstopped = true;
+	    break;
+
+	case O_TRACEON:
+	    traceon(p->value.trace.inst, p->value.trace.event,
+		p->value.trace.actions);
+	    break;
+
+	case O_TRACEOFF:
+	    traceoff(p->value.lcon);
+	    break;
+
+	default:
+	    panic("eval: bad op %d", p->op);
+    }
+ if(debug_flag[2]) { 
+	fprintf(stderr," evaluated %s \n",showoperator(p->op));
+ }
+           
+}
+
+/*
+ * Evaluate a list of commands.
+ */
+
+public evalcmdlist(cl)
+Cmdlist cl;
+{
+    Command c;
+
+    foreach (Command, c, cl)
+	evalcmd(c);
+    endfor
+}
+
+/*
+ * Push "len" bytes onto the expression stack from address "addr"
+ * in the process.  If there isn't room on the stack, print an error message.
+ */
+
+public rpush(addr, len)
+Address addr;
+int len;
+{
+    if (not canpush(len)) {
+	error("expression too large to evaluate");
+    } else {
+	chksp();
+	dread(sp, addr, len);
+	sp += len;
+    }
+}
+
+/*
+ * Check if the stack has n bytes available.
+ */
+
+public Boolean canpush(n)
+Integer n;
+{
+    return (Boolean) (sp + n < &stack[STACKSIZE]);
+}
+
+/*
+ * Push a small scalar of the given type onto the stack.
+ */
+
+public pushsmall(t, v)
+Symbol t;
+long v;
+{
+    register Integer s;
+
+    s = size(t);
+    switch (s) {
+	case sizeof(char):
+	    push(char, v);
+	    break;
+
+	case sizeof(short):
+	    push(short, v);
+	    break;
+
+	case sizeof(long):
+	    push(long, v);
+	    break;
+
+	default:
+	    panic("bad size %d in popsmall", s);
+    }
+}
+
+/*
+ * Pop an item of the given type which is assumed to be no larger
+ * than a long and return it expanded into a long.
+ */
+
+public long popsmall(t)
+Symbol t;
+{
+    long r;
+
+    switch (size(t)) {
+	case sizeof(char):
+	    r = (long) pop(char);
+	    break;
+
+	case sizeof(short):
+	    r = (long) pop(short);
+	    break;
+
+	case sizeof(long):
+	    r = pop(long);
+	    break;
+
+	default:
+	    panic("popsmall: size is %d", size(t));
+    }
+    return r;
+}
+
+/*
+ * Evaluate a conditional expression.
+ */
+
+public Boolean cond(p)
+Node p;
+{
+    register Boolean b;
+
+    if (p == nil) {
+	b = true;
+    } else {
+	eval(p);
+	b = (Boolean) pop(Boolrep);
+    }
+    return b;
+}
+
+/*
+ * Return the address corresponding to a given tree.
+ */
+
+public Address lval(p)
+Node p;
+{
+    if (p->op == O_RVAL) {
+	eval(p->value.arg[0]);
+    } else {
+	eval(p);
+    }
+    return (Address) (pop(long));
+}
+
+/*
+ * Process a trace command, translating into the appropriate events
+ * and associated actions.
+ */
+
+public trace(p)
+Node p;
+{
+    Node exp, place, cond;
+    Node left;
+
+    exp = p->value.arg[0];
+    place = p->value.arg[1];
+    cond = p->value.arg[2];
+    if (exp == nil) {
+	traceall(p->op, place, cond);
+    } else if (exp->op == O_QLINE or exp->op == O_LCON) {
+	traceinst(p->op, exp, cond);
+    } else if (place != nil and place->op == O_QLINE) {
+	traceat(p->op, exp, place, cond);
+    } else {
+	left = exp;
+	if (left->op == O_RVAL or left->op == O_CALL) {
+	    left = left->value.arg[0];
+	}
+	if (left->op == O_SYM and isblock(left->value.sym)) {
+	    traceproc(p->op, left->value.sym, place, cond);
+	} else {
+	    tracedata(p->op, exp, place, cond);
+	}
+    }
+}
+
+/*
+ * Set a breakpoint that will turn on tracing.
+ */
+
+private traceall(op, place, cond)
+Operator op;
+Node place;
+Node cond;
+{
+    Symbol s;
+    Node event;
+    Command action;
+
+    if (place == nil) {
+	s = program;
+    } else {
+	s = place->value.sym;
+    }
+    event = build(O_EQ, build(O_SYM, procsym), build(O_SYM, s));
+    action = build(O_PRINTSRCPOS,
+	build(O_QLINE, nil, build(O_LCON, (op == O_TRACE) ? 1 : 0)));
+    if (cond != nil) {
+	action = build(O_IF, cond, buildcmdlist(action));
+    }
+    action = build(O_TRACEON, (op == O_TRACEI), buildcmdlist(action));
+    action->value.trace.event = addevent(event, buildcmdlist(action));
+    if (isstdin()) {
+	printevent(action->value.trace.event);
+    }
+}
+
+/*
+ * Set up the appropriate breakpoint for tracing an instruction.
+ */
+
+private traceinst(op, exp, cond)
+Operator op;
+Node exp;
+Node cond;
+{
+    Node event, wh;
+    Command action;
+    Event e;
+
+    if (exp->op == O_LCON) {
+	wh = build(O_QLINE, build(O_SCON, cursource), exp);
+    } else {
+	wh = exp;
+    }
+    if (op == O_TRACEI) {
+	event = build(O_EQ, build(O_SYM, pcsym), wh);
+    } else {
+	event = build(O_EQ, build(O_SYM, linesym), wh);
+    }
+    action = build(O_PRINTSRCPOS, wh);
+    if (cond) {
+	action = build(O_IF, cond, buildcmdlist(action));
+    }
+    e = addevent(event, buildcmdlist(action));
+    if (isstdin()) {
+	printevent(e);
+    }
+}
+
+/*
+ * Set a breakpoint to print an expression at a given line or address.
+ */
+
+private traceat(op, exp, place, cond)
+Operator op;
+Node exp;
+Node place;
+Node cond;
+{
+    Node event;
+    Command action;
+    Event e;
+
+    if (op == O_TRACEI) {
+	event = build(O_EQ, build(O_SYM, pcsym), place);
+    } else {
+	event = build(O_EQ, build(O_SYM, linesym), place);
+    }
+    action = build(O_PRINTSRCPOS, exp);
+    if (cond != nil) {
+	action = build(O_IF, cond, buildcmdlist(action));
+    }
+    e = addevent(event, buildcmdlist(action));
+    if (isstdin()) {
+	printevent(e);
+    }
+}
+
+/*
+ * Construct event for tracing a procedure.
+ *
+ * What we want here is
+ *
+ * 	when $proc = p do
+ *	    if <condition> then
+ *	        printcall;
+ *	        once $pc = $retaddr do
+ *	            printrtn;
+ *	        end;
+ *	    end if;
+ *	end;
+ *
+ * Note that "once" is like "when" except that the event
+ * deletes itself as part of its associated action.
+ */
+
+private traceproc(op, p, place, cond)
+Operator op;
+Symbol p;
+Node place;
+Node cond;
+{
+    Node event;
+    Command action;
+    Cmdlist actionlist;
+    Event e;
+
+    action = build(O_PRINTCALL, p);
+    actionlist = list_alloc();
+    cmdlist_append(action, actionlist);
+    event = build(O_EQ, build(O_SYM, pcsym), build(O_SYM, retaddrsym));
+    action = build(O_ONCE, event, buildcmdlist(build(O_PRINTRTN, p)));
+    cmdlist_append(action, actionlist);
+    if (cond != nil) {
+	actionlist = buildcmdlist(build(O_IF, cond, actionlist));
+    }
+    event = build(O_EQ, build(O_SYM, procsym), build(O_SYM, p));
+    e = addevent(event, actionlist);
+    if (isstdin()) {
+	printevent(e);
+    }
+}
+
+/*
+ * Set up breakpoint for tracing data.
+ */
+
+private tracedata(op, exp, place, cond)
+Operator op;
+Node exp;
+Node place;
+Node cond;
+{
+    Symbol p;
+    Node event;
+    Command action;
+
+    p = (place == nil) ? tcontainer(exp) : place->value.sym;
+    if (p == nil) {
+	p = program;
+    }
+    action = build(O_PRINTIFCHANGED, exp);
+    if (cond != nil) {
+	action = build(O_IF, cond, buildcmdlist(action));
+    }
+    action = build(O_TRACEON, (op == O_TRACEI), buildcmdlist(action));
+    event = build(O_EQ, build(O_SYM, procsym), build(O_SYM, p));
+    action->value.trace.event = addevent(event, buildcmdlist(action));
+    if (isstdin()) {
+	printevent(action->value.trace.event);
+    }
+}
+
+/*
+ * Setting and unsetting of stops.
+ */
+
+public stop(p)
+Node p;
+{
+    Node exp, place, cond, t;
+    Symbol s;
+    Command action;
+    Event e;
+
+    exp = p->value.arg[0];
+    place = p->value.arg[1];
+    cond = p->value.arg[2];
+    if (exp != nil) {
+	stopvar(p->op, exp, place, cond);
+    } else {
+	action = build(O_STOPX);
+	if (cond != nil) {
+	    action = build(O_IF, cond, buildcmdlist(action));
+	}
+	if (place != nil and place->op == O_SYM) {
+	    s = place->value.sym;
+	    t = build(O_EQ, build(O_SYM, procsym), build(O_SYM, s));
+	    if (cond != nil) {
+		action = build(O_TRACEON, (p->op == O_STOPI),
+		    buildcmdlist(action));
+		e = addevent(t, buildcmdlist(action));
+		action->value.trace.event = e;
+	    } else {
+		e = addevent(t, buildcmdlist(action));
+	    }
+	    if (isstdin()) {
+		printevent(e);
+	    }
+	} else {
+	    stopinst(p->op, place, cond, action);
+	}
+    }
+}
+
+private stopinst(op, place, cond, action)
+Operator op;
+Node place;
+Node cond;
+Command action;
+{
+    Node event;
+    Event e;
+
+    if (op == O_STOP) {
+	event = build(O_EQ, build(O_SYM, linesym), place);
+    } else {
+	event = build(O_EQ, build(O_SYM, pcsym), place);
+    }
+    e = addevent(event, buildcmdlist(action));
+    if (isstdin()) {
+	printevent(e);
+    }
+}
+
+/*
+ * Implement stopping on assignment to a variable by adding it to
+ * the variable list.
+ */
+
+private stopvar(op, exp, place, cond)
+Operator op;
+Node exp;
+Node place;
+Node cond;
+{
+    Symbol p;
+    Node event;
+    Command action;
+
+    if (place == nil) {
+	if (exp->op == O_LCON) {
+	    p = program;
+	} else {
+	    p = tcontainer(exp);
+	    if (p == nil) {
+		p = program;
+	    }
+	}
+    } else {
+	p = place->value.sym;
+    }
+    action = build(O_STOPIFCHANGED, exp);
+    if (cond != nil) {
+	action = build(O_IF, cond, buildcmdlist(action));
+    }
+    action = build(O_TRACEON, (op == O_STOPI), buildcmdlist(action));
+    event = build(O_EQ, build(O_SYM, procsym), build(O_SYM, p));
+    action->value.trace.event = addevent(event, buildcmdlist(action));
+    if (isstdin()) {
+	printevent(action->value.trace.event);
+    }
+}
+
+/*
+ * Assign the value of an expression to a variable (or term).
+ */
+
+public assign(var, exp)
+Node var;
+Node exp;
+{
+    Address addr;
+    int varsize;
+    char cvalue;
+    short svalue;
+    long lvalue;
+
+    if (not compatible(var->nodetype, exp->nodetype)) {
+	error("incompatible types");
+    }
+    addr = lval(var);
+    eval(exp);
+    varsize = size(var->nodetype);
+    if (varsize < sizeof(long)) {
+	lvalue = pop(long);
+	switch (varsize) {
+	    case sizeof(char):
+		cvalue = lvalue;
+		dwrite(&cvalue, addr, varsize);
+		break;
+
+	    case sizeof(short):
+		svalue = lvalue;
+		dwrite(&svalue, addr, varsize);
+		break;
+
+	    default:
+		panic("bad size %d", varsize);
+	}
+    } else {
+	sp -= varsize;
+	dwrite(sp, addr, varsize);
+    }
+}
+
+/*
+ * Send some nasty mail to the current support person.
+ */
+
+public gripe()
+{
+    typedef Operation();
+    Operation *old;
+    int pid, status;
+
+    char *maintainer = "linton@berkeley";
+
+    puts("Type control-D to end your message.  Be sure to include");
+    puts("your name and the name of the file you are debugging.");
+    putchar('\n');
+    old = signal(SIGINT, SIG_DFL);
+    pid = back("Mail", stdin, stdout, "-s", "dbx gripe", maintainer, nil);
+    signal(SIGINT, SIG_IGN);
+    pwait(pid, &status);
+    signal(SIGINT, old);
+    if (status == 0) {
+	puts("Thank you.");
+    } else {
+	puts("\nMail not sent.");
+    }
+}
+
+/*
+ * Give the user some help.
+ */
+
+public help()
+{
+    puts("run                    - begin execution of the program");
+    puts("cont                   - continue execution");
+    puts("step                   - single step one line");
+    puts("next                   - step to next line (skip over calls)");
+    puts("trace <line#>          - trace execution of the line");
+    puts("trace <proc>           - trace calls to the procedure");
+    puts("trace <var>            - trace changes to the variable");
+    puts("trace <exp> at <line#> - print <exp> when <line> is reached");
+    puts("stop at <line>         - suspend execution at the line");
+    puts("stop in <proc>         - suspend execution when <proc> is called");
+    puts("status                 - print trace/stop's in effect");
+    puts("delete <number>        - remove trace or stop of given number");
+    puts("call <proc>            - call the procedure");
+    puts("where                  - print currently active procedures");
+    puts("print <exp>            - print the value of the expression");
+    puts("whatis <name>          - print the declaration of the name");
+    puts("list <line>, <line>    - list source lines");
+    puts("edit <proc>            - edit file containing <proc>");
+    puts("gripe                  - send mail to the person in charge of dbx");
+    puts("quit                   - exit dbx");
+}
+
+/*
+ * Divert output to the given file name.
+ * Cannot redirect to an existing file.
+ */
+
+private int so_fd;
+private Boolean notstdout;
+
+public setout(filename)
+String filename;
+{
+    File f;
+
+    f = fopen(filename, "r");
+    if (f != nil) {
+	fclose(f);
+	error("%s: file already exists", filename);
+    } else {
+	so_fd = dup(1);
+	close(1);
+	if (creat(filename, 0666) == nil) {
+	    unsetout();
+	    error("can't create %s", filename);
+	}
+	notstdout = true;
+    }
+}
+
+/*
+ * Revert output to standard output.
+ */
+
+public unsetout()
+{
+    fflush(stdout);
+    close(1);
+    if (dup(so_fd) != 1) {
+	panic("standard out dup failed");
+    }
+    close(so_fd);
+    notstdout = false;
+}
+
+/*
+ * Determine is standard output is currently being redirected
+ * to a file (as far as we know).
+ */
+
+public Boolean isredirected()
+{
+    return notstdout;
+}
diff --git a/dbx/eval.h b/dbx/eval.h
new file mode 100644
index 0000000..dda4946
--- /dev/null
+++ b/dbx/eval.h
@@ -0,0 +1,41 @@
+#ifndef eval_h
+#define eval_h
+
+#include "machine.h"
+
+#define STACKSIZE 20000
+
+typedef Char Stack;
+
+#define push(type, value) { \
+    ((type *) (sp += sizeof(type)))[-1] = (value); \
+}
+
+#define pop(type) ( \
+    (*((type *) (sp -= sizeof(type)))) \
+)
+
+#define alignstack() { \
+    sp = (Stack *) (( ((int) sp) + sizeof(int) - 1)&~(sizeof(int) - 1)); \
+}
+
+Stack stack[STACKSIZE];
+Stack *sp ;
+Boolean useInstLoc ;
+eval(/* p */);
+evalcmdlist(/* cl */);
+rpush(/* addr, len */);
+Boolean canpush(/* n */);
+pushsmall(/* t, v */);
+long popsmall(/* t */);
+Boolean cond(/* p */);
+Address lval(/* p */);
+trace(/* p */);
+stop(/* p */);
+assign(/* var, exp */);
+gripe(/*  */);
+help(/*  */);
+setout(/* filename */);
+unsetout(/*  */);
+Boolean isredirected(/*  */);
+#endif
diff --git a/dbx/events.c b/dbx/events.c
new file mode 100644
index 0000000..a49c8e9
--- /dev/null
+++ b/dbx/events.c
@@ -0,0 +1,828 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)events.c 1.3 4/8/83";
+
+/*
+ * Event/breakpoint managment.
+ */
+
+#include "defs.h"
+#include "events.h"
+#include "main.h"
+#include "symbols.h"
+#include "tree.h"
+#include "eval.h"
+#include "source.h"
+#include "mappings.h"
+#include "process.h"
+#include "machine.h"
+#include "lists.h"
+
+#ifndef public
+typedef struct Event *Event;
+typedef struct Breakpoint *Breakpoint;
+
+Boolean inst_tracing;
+Boolean single_stepping;
+Boolean isstopped;
+
+#include "symbols.h"
+
+Symbol linesym;
+Symbol procsym;
+Symbol pcsym;
+Symbol retaddrsym;
+
+#define addevent(cond, cmdlist) event_alloc(false, cond, cmdlist)
+#define event_once(cond, cmdlist) event_alloc(true, cond, cmdlist)
+
+#endif
+
+struct Event {
+    unsigned int id;
+    Boolean temporary;
+    Node condition;
+    Cmdlist actions;
+};
+
+struct Breakpoint {
+    Event event;
+    Address bpaddr;	
+    Lineno bpline;
+    Cmdlist actions;
+};
+
+typedef List Eventlist;
+typedef List Bplist;
+
+#define eventlist_append(event, el) list_append(list_item(event), nil, el)
+#define bplist_append(bp, bl) list_append(list_item(bp), nil, bl)
+
+private Eventlist eventlist;		/* list of active events */
+private Bplist bplist;			/* list of active breakpoints */
+private Integer eventid;		/* id number of next allocated event */
+private Integer trid;			/* id number of next allocated trace */
+
+typedef struct Trcmd {
+    Integer trid;
+    Event event;
+    Cmdlist cmdlist;
+} *Trcmd;
+
+private List eachline;		/* commands to execute after each line */
+private List eachinst;		/* commands to execute after each instruction */
+
+private Breakpoint bp_alloc();
+
+/*
+ * Initialize breakpoint information.
+ */
+
+private Symbol builtinsym(str, class, type)
+String str;
+Symclass class;
+Symbol type;
+{
+    Symbol s;
+
+    s = insert(identname(str, true));
+    s->language = findlanguage(".s");
+    s->class = class;
+    s->type = type;
+    return s;
+}
+
+public bpinit()
+{
+    linesym = builtinsym("$line", VAR, t_int);
+    procsym = builtinsym("$proc", PROC, nil);
+    pcsym = lookup(identname("$pc", true));
+    if (pcsym == nil) {
+	panic("can't find $pc");
+    }
+    retaddrsym = builtinsym("$retaddr", VAR, t_int);
+    eventlist = list_alloc();
+    bplist = list_alloc();
+    eachline = list_alloc();
+    eachinst = list_alloc();
+}
+
+/*
+ * Trap an event and do the associated commands when it occurs.
+ */
+
+public Event event_alloc(istmp, econd, cmdlist)
+Boolean istmp;
+Node econd;
+Cmdlist cmdlist;
+{
+    register Event e;
+
+    e = new(Event);
+    ++eventid;
+    e->id = eventid;
+    e->temporary = istmp;
+    e->condition = econd;
+    e->actions = cmdlist;
+    eventlist_append(e, eventlist);
+    translate(e);
+    return e;
+}
+
+/*
+ * Delete the event with the given id.
+ */
+
+public delevent(id)
+unsigned int id;
+{
+    Event e;
+    Breakpoint bp;
+    Trcmd t;
+
+    foreach (Event, e, eventlist)
+	if (e->id == id) {
+	    list_delete(list_curitem(eventlist), eventlist);
+	    foreach (Breakpoint, bp, bplist)
+		if (bp->event == e) {
+		    list_delete(list_curitem(bplist), bplist);
+		}
+	    endfor
+	    break;
+	}
+    endfor
+    foreach (Trcmd, t, eachline)
+	if (t->event->id == id) {
+	    printrmtr(t);
+	    list_delete(list_curitem(eachline), eachline);
+	}
+    endfor
+    foreach (Trcmd, t, eachinst)
+	if (t->event->id == id) {
+	    printrmtr(t);
+	    list_delete(list_curitem(eachinst), eachinst);
+	}
+    endfor
+    if (list_size(eachinst) == 0) {
+	inst_tracing = false;
+	if (list_size(eachline) == 0) {
+	    single_stepping = false;
+	}
+    }
+}
+
+/*
+ * Translate an event into the appropriate breakpoints and actions.
+ * While we're at it, turn on the breakpoints if the condition is true.
+ */
+
+private translate(e)
+Event e;
+{
+    Breakpoint bp;
+    Symbol s;
+    Node place;
+    Lineno line;
+    Address addr;
+
+    checkref(e->condition);
+    switch (e->condition->op) {
+	case O_EQ:
+	    if (e->condition->value.arg[0]->op == O_SYM) {
+		s = e->condition->value.arg[0]->value.sym;
+		place = e->condition->value.arg[1];
+		if (s == linesym) {
+		    if (place->op == O_QLINE) {
+			line = place->value.arg[1]->value.lcon;
+			addr = objaddr(line,
+			    place->value.arg[0]->value.scon);
+		    } else {
+			eval(place);
+			line = pop(long);
+			addr = objaddr(line, cursource);
+		    }
+		    if (addr == NOADDR) {
+			delevent(e->id);
+			beginerrmsg();
+			fprintf(stderr, "no executable code at line ");
+			prtree(stderr, place);
+			enderrmsg();
+		    }
+		    bp = bp_alloc(e, addr, line, e->actions);
+		} else if (s == procsym) {
+		    eval(place);
+		    s = pop(Symbol);
+		    bp = bp_alloc(e, codeloc(s), 0, e->actions);
+		    if (isactive(s) and pc != codeloc(program)) {
+			evalcmdlist(e->actions);
+		    }
+		} else if (s == pcsym) {
+		    eval(place);
+		    bp = bp_alloc(e, pop(Address), 0, e->actions);
+		} else {
+		    condbp(e);
+		}
+	    } else {
+		condbp(e);
+	    }
+	    break;
+
+	/*
+	 * These should be handled specially.
+	 * But for now I'm ignoring the problem.
+	 */
+	case O_AND:
+	case O_OR:
+	default:
+	    condbp(e);
+	    break;
+    }
+}
+
+/*
+ * Create a breakpoint for a condition that cannot be pinpointed
+ * to happening at a particular address, but one for which we
+ * must single step and check the condition after each statement.
+ */
+
+private condbp(e)
+Event e;
+{
+    Symbol p;
+    Breakpoint bp;
+    Cmdlist actions;
+
+    p = tcontainer(e->condition);
+    if (p == nil) {
+	p = program;
+    }
+    actions = buildcmdlist(build(O_IF, e->condition, e->actions));
+    actions = buildcmdlist(build(O_TRACEON, false, actions));
+    bp = bp_alloc(e, codeloc(p), 0, actions);
+}
+
+/*
+ * Determine the deepest nested subprogram that still contains
+ * all elements in the given expression.
+ */
+
+public Symbol tcontainer(exp)
+Node exp;
+{
+    Integer i;
+    Symbol s, t, u, v;
+
+    checkref(exp);
+    s = nil;
+    if (exp->op == O_SYM) {
+	s = container(exp->value.sym);
+    } else if (not isleaf(exp->op)) {
+	for (i = 0; i < nargs(exp->op); i++) {
+	    t = tcontainer(exp->value.arg[i]);
+	    if (t != nil) {
+		if (s == nil) {
+		    s = t;
+		} else {
+		    u = s;
+		    v = t;
+		    while (u != v and u != nil) {
+			u = container(u);
+			v = container(v);
+		    }
+		    if (u == nil) {
+			panic("bad ancestry for \"%s\"", symname(s));
+		    } else {
+			s = u;
+		    }
+		}
+	    }
+	}
+    }
+    return s;
+}
+
+/*
+ * Determine if the given function can be executed at full speed.
+ * This can only be done if there are no breakpoints within the function.
+ */
+
+public Boolean canskip(f)
+Symbol f;
+{
+    Breakpoint p;
+    Boolean ok;
+
+    ok = true;
+    foreach (Breakpoint, p, bplist)
+	if (whatblock(p->bpaddr) == f) {
+	    ok = false;
+	    break;
+	}
+    endfor
+    return ok;
+}
+
+/*
+ * Print out what's currently being traced by looking at
+ * the currently active events.
+ *
+ * Some convolution here to translate internal representation
+ * of events back into something more palatable.
+ */
+
+public status()
+{
+    Event e;
+
+    foreach (Event, e, eventlist)
+	if (not e->temporary) {
+	    printevent(e);
+	}
+    endfor
+}
+
+public printevent(e)
+Event e;
+{
+    Command cmd;
+
+    if (not isredirected()) {
+	printf("(%d) ", e->id);
+    }
+    cmd = list_element(Command, list_head(e->actions));
+    if (cmd->op == O_PRINTCALL) {
+	printf("trace ");
+	printname(stdout, cmd->value.sym);
+    } else {
+	if (list_size(e->actions) > 1) {
+	    printf("{ ");
+	}
+	foreach (Command, cmd, e->actions)
+	    printcmd(stdout, cmd);
+	    if (not list_islast()) {
+		printf("; ");
+	    }
+	endfor
+	if (list_size(e->actions) > 1) {
+	    printf(" }");
+	}
+	printcond(e->condition);
+    }
+    printf("\n");
+}
+
+/*
+ * Print out a condition.
+ */
+
+private printcond(cond)
+Node cond;
+{
+    Symbol s;
+    Node place;
+
+    if (cond->op == O_EQ and cond->value.arg[0]->op == O_SYM) {
+	s = cond->value.arg[0]->value.sym;
+	place = cond->value.arg[1];
+	if (s == procsym) {
+	    if (place->value.sym != program) {
+		printf(" in ");
+		printname(stdout, place->value.sym);
+	    }
+	} else if (s == linesym) {
+	    printf(" at ");
+	    prtree(stdout, place);
+	} else if (s == pcsym or s == retaddrsym) {
+	    printf("i at ");
+	    prtree(stdout, place);
+	} else {
+	    printf(" when ");
+	    prtree(stdout, cond);
+	}
+    } else {
+	printf(" when ");
+	prtree(stdout, cond);
+    }
+}
+
+/*
+ * Add a breakpoint to the list and return it.
+ */
+
+private Breakpoint bp_alloc(e, addr, line, actions)
+Event e;
+Address addr;
+Lineno line;
+Cmdlist actions;
+{
+    register Breakpoint p;
+
+    p = new(Breakpoint);
+    p->event = e;
+    p->bpaddr = addr;
+    p->bpline = line;
+    p->actions = actions;
+    if (tracebpts) {
+	printf("new bp at 0x%x\n", addr);
+	fflush(stdout);
+    }
+    bplist_append(p, bplist);
+    return p;
+}
+
+/*
+ * Free all storage in the event and breakpoint tables.
+ */
+
+public bpfree()
+{
+    register Event e;
+
+    fixbps();
+    foreach (Event, e, eventlist)
+	delevent(e->id);
+	list_delete(list_curitem(eventlist), eventlist);
+    endfor
+}
+
+/*
+ * Determine if the program stopped at a known breakpoint
+ * and if so do the associated commands.
+ */
+
+public Boolean bpact()
+{
+    register Breakpoint p;
+    Boolean found;
+
+    found = false;
+    foreach (Breakpoint, p, bplist)
+	if (p->bpaddr == pc) {
+	    if (tracebpts) {
+		printf("breakpoint found at location 0x%x\n", pc);
+	    }
+	    found = true;
+	    if (p->event->temporary) {
+		delevent(p->event->id);
+	    }
+	    evalcmdlist(p->actions);
+	}
+    endfor
+    if (isstopped) {
+	printstatus();
+    }
+    fflush(stdout);
+    return found;
+}
+
+/*
+ * Begin single stepping and executing the given commands after each step.
+ * If the first argument is true step by instructions, otherwise
+ * step by source lines.
+ *
+ * We automatically set a breakpoint at the end of the current procedure
+ * to turn off the given tracing.
+ */
+
+public traceon(inst, event, cmdlist)
+Boolean inst;
+Event event;
+Cmdlist cmdlist;
+{
+    register Trcmd trcmd;
+    Breakpoint bp;
+    Node until;
+    Cmdlist actions;
+    Address ret;
+
+    trcmd = new(Trcmd);
+    ++trid;
+    trcmd->trid = trid;
+    trcmd->event = event;
+    trcmd->cmdlist = cmdlist;
+    single_stepping = true;
+    if (inst) {
+	inst_tracing = true;
+	list_append(list_item(trcmd), nil, eachinst);
+    } else {
+	list_append(list_item(trcmd), nil, eachline);
+    }
+    ret = return_addr();
+    if (ret != 0) {
+	until = build(O_EQ, build(O_SYM, pcsym), build(O_LCON, ret));
+	actions = buildcmdlist(build(O_TRACEOFF, trcmd->trid));
+	event_once(until, actions);
+    }
+    if (tracebpts) {
+	printf("adding trace %d for event %d\n", trcmd->trid, event->id);
+    }
+}
+
+/*
+ * Turn off some kind of tracing.
+ * Strictly an internal command, this cannot be invoked by the user.
+ */
+
+public traceoff(id)
+Integer id;
+{
+    register Trcmd t;
+    register Boolean found;
+
+    found = false;
+    foreach (Trcmd, t, eachline)
+	if (t->trid == id) {
+	    printrmtr(t);
+	    list_delete(list_curitem(eachline), eachline);
+	    found = true;
+	    break;
+	}
+    endfor
+    if (not found) {
+	foreach (Trcmd, t, eachinst)
+	    if (t->event->id == id) {
+		printrmtr(t);
+		list_delete(list_curitem(eachinst), eachinst);
+		found = true;
+		break;
+	    }
+	endfor
+	if (not found) {
+	    panic("missing trid %d", id);
+	}
+    }
+    if (list_size(eachinst) == 0) {
+	inst_tracing = false;
+	if (list_size(eachline) == 0) {
+	    single_stepping = false;
+	}
+    }
+}
+
+/*
+ * If breakpoints are being traced, note that a Trcmd is being deleted.
+ */
+
+private printrmtr(t)
+Trcmd t;
+{
+    if (tracebpts) {
+	printf("removing trace %d", t->trid);
+	if (t->event != nil) {
+	    printf(" for event %d", t->event->id);
+	}
+	printf("\n");
+    }
+}
+
+/*
+ * Print out news during single step tracing.
+ */
+
+public printnews()
+{
+    register Trcmd t;
+
+    foreach (Trcmd, t, eachline)
+	evalcmdlist(t->cmdlist);
+    endfor
+    foreach (Trcmd, t, eachinst)
+	evalcmdlist(t->cmdlist);
+    endfor
+    bpact();
+}
+
+/*
+ * A procedure call/return has occurred while single-stepping,
+ * note it if we're tracing lines.
+ */
+
+private Boolean chklist();
+
+public callnews(iscall)
+Boolean iscall;
+{
+    if (not chklist(eachline, iscall)) {
+	chklist(eachinst, iscall);
+    }
+}
+
+private Boolean chklist(list, iscall)
+List list;
+Boolean iscall;
+{
+    register Trcmd t;
+    register Command cmd;
+
+    curfunc = whatblock(pc);
+    foreach (Trcmd, t, list)
+	foreach (Command, cmd, t->cmdlist)
+	    if (cmd->op == O_PRINTSRCPOS and
+	      (cmd->value.arg[0] == nil or cmd->value.arg[0]->op == O_QLINE)) {
+		if (iscall) {
+		    printentry(curfunc);
+		} else {
+		    printexit(curfunc);
+		}
+		return true;
+	    }
+	endfor
+    endfor
+    return false;
+}
+
+/*
+ * When tracing variables we keep a copy of their most recent value
+ * and compare it to the current one each time a breakpoint occurs.
+ * MAXTRSIZE is the maximum size variable we allow.
+ */
+
+#define MAXTRSIZE 512
+
+/*
+ * List of variables being watched.
+ */
+
+typedef struct Trinfo *Trinfo;
+
+struct Trinfo {
+    Node variable;
+    Address traddr;
+    Symbol trblock;
+    char *trvalue;
+};
+
+private List trinfolist;
+
+/*
+ * Find the trace information record associated with the given record.
+ * If there isn't one then create it and add it to the list.
+ */
+
+private Trinfo findtrinfo(p)
+Node p;
+{
+    register Trinfo tp;
+    Boolean isnew;
+
+    isnew = true;
+    if (trinfolist == nil) {
+	trinfolist = list_alloc();
+    } else {
+	foreach (Trinfo, tp, trinfolist)
+	    if (tp->variable == p) {
+		isnew = false;
+		break;
+	    }
+	endfor
+    }
+    if (isnew) {
+	if (tracebpts) {
+	    printf("adding trinfo for \"");
+	    prtree(stdout, p);
+	    printf("\"\n");
+	}
+	tp = new(Trinfo);
+	tp->variable = p;
+	tp->traddr = lval(p);
+	tp->trvalue = nil;
+	list_append(list_item(tp), nil, trinfolist);
+    }
+    return tp;
+}
+
+/*
+ * Print out the value of a variable if it has changed since the
+ * last time we checked.
+ */
+
+public printifchanged(p)
+Node p;
+{
+    register Trinfo tp;
+    register int n;
+    char buff[MAXTRSIZE];
+    static Lineno prevline;
+
+    tp = findtrinfo(p);
+    n = size(p->nodetype);
+    dread(buff, tp->traddr, n);
+    if (tp->trvalue == nil) {
+	tp->trvalue = newarr(char, n);
+	mov(buff, tp->trvalue, n);
+	mov(buff, sp, n);
+	sp += n;
+	printf("initially (at line %d):\t", curline);
+	prtree(stdout, p);
+	printf(" = ");
+	printval(p->nodetype);
+	putchar('\n');
+    } else if (cmp(tp->trvalue, buff, n) != 0) {
+	mov(buff, tp->trvalue, n);
+	mov(buff, sp, n);
+	sp += n;
+	printf("after line %d:\t", prevline);
+	prtree(stdout, p);
+	printf(" = ");
+	printval(p->nodetype);
+	putchar('\n');
+    }
+    prevline = curline;
+}
+
+/*
+ * Stop if the value of the given expression has changed.
+ */
+
+public stopifchanged(p)
+Node p;
+{
+    register Trinfo tp;
+    register int n;
+    char buff[MAXTRSIZE];
+    static Lineno prevline;
+
+    tp = findtrinfo(p);
+    n = size(p->nodetype);
+    dread(buff, tp->traddr, n);
+    if (tp->trvalue == nil) {
+	tp->trvalue = newarr(char, n);
+	mov(buff, tp->trvalue, n);
+	isstopped = true;
+    } else if (cmp(tp->trvalue, buff, n) != 0) {
+	mov(buff, tp->trvalue, n);
+	isstopped = true;
+    }
+    prevline = curline;
+}
+
+/*
+ * Free the tracing table.
+ */
+
+public trfree()
+{
+    register Trinfo tp;
+
+    foreach (Trinfo, tp, trinfolist)
+	dispose(tp->trvalue);
+	dispose(tp);
+	list_delete(list_curitem(trinfolist), trinfolist);
+    endfor
+}
+
+/*
+ * Fix up breakpoint information before continuing execution.
+ *
+ * It's necessary to destroy events and breakpoints that were created
+ * temporarily and still exist because the program terminated abnormally.
+ */
+
+public fixbps()
+{
+    register Event e;
+    register Trcmd t;
+
+    single_stepping = false;
+    inst_tracing = false;
+    trfree();
+    foreach (Event, e, eventlist)
+	if (e->temporary) {
+	    delevent(e->id);
+	}
+    endfor
+    foreach (Trcmd, t, eachline)
+	printrmtr(t);
+	list_delete(list_curitem(eachline), eachline);
+    endfor
+    foreach (Trcmd, t, eachinst)
+	printrmtr(t);
+	list_delete(list_curitem(eachinst), eachinst);
+    endfor
+}
+
+/*
+ * Set all breakpoints in object code.
+ */
+
+public setallbps()
+{
+    register Breakpoint p;
+
+    foreach (Breakpoint, p, bplist)
+	setbp(p->bpaddr);
+    endfor
+}
+
+/*
+ * Undo damage done by "setallbps".
+ */
+
+public unsetallbps()
+{
+    register Breakpoint p;
+
+    foreach (Breakpoint, p, bplist)
+	unsetbp(p->bpaddr);
+    endfor
+}
diff --git a/dbx/events.h b/dbx/events.h
new file mode 100644
index 0000000..5226ef6
--- /dev/null
+++ b/dbx/events.h
@@ -0,0 +1,39 @@
+#ifndef events_h
+#define events_h
+typedef struct Event *Event;
+typedef struct Breakpoint *Breakpoint;
+
+Boolean inst_tracing;
+Boolean single_stepping;
+Boolean isstopped;
+
+#include "symbols.h"
+
+Symbol linesym;
+Symbol procsym;
+Symbol pcsym;
+Symbol retaddrsym;
+
+#define addevent(cond, cmdlist) event_alloc(false, cond, cmdlist)
+#define event_once(cond, cmdlist) event_alloc(true, cond, cmdlist)
+
+bpinit(/*  */);
+Event event_alloc(/* istmp, econd, cmdlist */);
+delevent(/* id */);
+Symbol tcontainer(/* exp */);
+Boolean canskip(/* f */);
+status(/*  */);
+printevent(/* e */);
+bpfree(/*  */);
+Boolean bpact(/*  */);
+traceon(/* inst, event, cmdlist */);
+traceoff(/* id */);
+printnews(/*  */);
+callnews(/* iscall */);
+printifchanged(/* p */);
+stopifchanged(/* p */);
+trfree(/*  */);
+fixbps(/*  */);
+setallbps(/*  */);
+unsetallbps(/*  */);
+#endif
diff --git a/dbx/fortran.c b/dbx/fortran.c
new file mode 100644
index 0000000..20f7e2c
--- /dev/null
+++ b/dbx/fortran.c
@@ -0,0 +1,587 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)fortran.c	1.4	8/16/83";
+
+/*
+ * FORTRAN dependent symbol routines.
+ */
+
+#include "defs.h"
+#include "symbols.h"
+#include "printsym.h"
+#include "languages.h"
+#include "fortran.h"
+#include "tree.h"
+#include "eval.h"
+#include "operators.h"
+#include "mappings.h"
+#include "process.h"
+#include "runtime.h"
+#include "machine.h"
+
+#define isfloat(range) ( \
+    range->symvalue.rangev.upper == 0 and range->symvalue.rangev.lower > 0 \
+)
+
+#define isrange(t, name) (t->class == RANGE and istypename(t->type, name))
+
+#define MAXDIM  20
+/*
+ * Initialize FORTRAN language information.
+ */
+
+public fortran_init()
+{
+    Language lang;
+
+    lang = language_define("fortran", ".f");
+    language_setop(lang, L_PRINTDECL, fortran_printdecl);
+    language_setop(lang, L_PRINTVAL, fortran_printval);
+    language_setop(lang, L_TYPEMATCH, fortran_typematch);
+    language_setop(lang, L_BUILDAREF, fortran_buildaref);
+    language_setop(lang, L_EVALAREF, fortran_evalaref);
+}
+
+/*
+ * Test if two types are compatible.
+ *
+ * Integers and reals are not compatible since they cannot always be mixed.
+ */
+
+public Boolean fortran_typematch(type1, type2)
+Symbol type1, type2;
+{
+
+/* only does integer for now; may need to add others
+*/
+
+    Boolean b;
+    register Symbol t1, t2, tmp;
+
+    t1 = rtype(type1);
+    t2 = rtype(type2);
+    if(t1 == nil or t1->type == nil or t2 == nil or t2->type == nil ) b = false;
+    else { b = (Boolean)   (
+            (t1 == t2)  or 
+	    (t1->type == t_int and (istypename(t2->type, "integer") or
+                                    istypename(t2->type, "integer*2"))  ) or
+	    (t2->type == t_int and (istypename(t1->type, "integer") or
+                                    istypename(t1->type, "integer*2"))  ) 
+                    );
+         }
+    /*OUT fprintf(stderr," %d compat %s %s \n", b,
+      (t1 == nil or t1->type == nil ) ? "nil" : symname(t1->type),
+      (t2 == nil or t2->type == nil ) ? "nil" : symname(t2->type)  );*/
+    return b;
+}
+
+private String typename(s)
+Symbol s;
+{
+int ub;
+static char buf[20];
+char *pbuf;
+Symbol st,sc;
+
+     if(s->type->class == TYPE) return(symname(s->type));
+
+     for(st = s->type; st->type->class != TYPE; st = st->type);
+
+     pbuf=buf;
+
+     if(istypename(st->type,"char"))  { 
+	  sprintf(pbuf,"character*");
+          pbuf += strlen(pbuf);
+	  sc = st->chain;
+          if(sc->symvalue.rangev.uppertype == R_ARG or
+             sc->symvalue.rangev.uppertype == R_TEMP) {
+	      if( ! getbound(s,sc->symvalue.rangev.upper, 
+                    sc->symvalue.rangev.uppertype, &ub) )
+		sprintf(pbuf,"(*)");
+	      else 
+		sprintf(pbuf,"%d",ub);
+          }
+ 	  else sprintf(pbuf,"%d",sc->symvalue.rangev.upper);
+     }
+     else {
+          sprintf(pbuf,"%s ",symname(st->type));
+     }
+     return(buf);
+}
+
+private Symbol mksubs(pbuf,st)
+Symbol st;
+char  **pbuf;
+{   
+   int lb, ub;
+   Symbol r, eltype;
+
+   if(st->class != ARRAY or (istypename(st->type, "char")) ) return;
+   else {
+          mksubs(pbuf,st->type);
+          assert( (r = st->chain)->class == RANGE);
+
+          if(r->symvalue.rangev.lowertype == R_ARG or
+             r->symvalue.rangev.lowertype == R_TEMP) {
+	      if( ! getbound(st,r->symvalue.rangev.lower, 
+                    r->symvalue.rangev.lowertype, &lb) )
+		sprintf(*pbuf,"?:");
+	      else 
+		sprintf(*pbuf,"%d:",lb);
+	  }
+          else {
+		lb = r->symvalue.rangev.lower;
+		sprintf(*pbuf,"%d:",lb);
+		}
+    	  *pbuf += strlen(*pbuf);
+
+          if(r->symvalue.rangev.uppertype == R_ARG or
+             r->symvalue.rangev.uppertype == R_TEMP) {
+	      if( ! getbound(st,r->symvalue.rangev.upper, 
+                    r->symvalue.rangev.uppertype, &ub) )
+		sprintf(*pbuf,"?,");
+	      else 
+		sprintf(*pbuf,"%d,",ub);
+	  }
+          else {
+		ub = r->symvalue.rangev.upper;
+		sprintf(*pbuf,"%d,",ub);
+		}
+    	  *pbuf += strlen(*pbuf);
+
+       }
+}
+
+/*
+ * Print out the declaration of a FORTRAN variable.
+ */
+
+public fortran_printdecl(s)
+Symbol s;
+{
+
+
+Symbol eltype;
+
+    switch (s->class) {
+	case CONST:
+	    printf("parameter %s = ", symname(s));
+            printval(s);
+	    break;
+
+        case REF:
+            printf(" (dummy argument) ");
+	    /* fall through */
+	case VAR:
+	    if (s->type->class == ARRAY and
+	        (not istypename(s->type->type, "char"))
+	    ) {
+		char bounds[130], *p1, **p;
+
+		p1 = bounds;
+                p = &p1;
+                mksubs(p, s->type);
+                *p -= 1; 
+                **p = '\0';   /* get rid of trailing ',' */
+		printf(" %s %s[%s] ", typename(s), symname(s), bounds);
+	    } else {
+		printf("%s %s", typename(s), symname(s));
+	    }
+	    break;
+
+	case FUNC:
+	    if (not istypename(s->type, "void")) {
+                printf(" %s function ", typename(s) );
+	    } else {
+		printf(" subroutine");
+	    }
+	    printf(" %s ", symname(s));
+	    fortran_listparams(s);
+	    break;
+
+	case MODULE:
+	    printf("source file \"%s.f\"", symname(s));
+	    break;
+
+	case PROG:
+	    printf("executable file \"%s\"", symname(s));
+	    break;
+
+	default:
+	    error("class %s in fortran_printdecl", classname(s));
+    }
+    putchar('\n');
+}
+
+/*
+ * List the parameters of a procedure or function.
+ * No attempt is made to combine like types.
+ */
+
+public fortran_listparams(s)
+Symbol s;
+{
+    register Symbol t;
+
+    putchar('(');
+    for (t = s->chain; t != nil; t = t->chain) {
+	printf("%s", symname(t));
+	if (t->chain != nil) {
+	    printf(", ");
+	}
+    }
+    putchar(')');
+    if (s->chain != nil) {
+	printf("\n");
+	for (t = s->chain; t != nil; t = t->chain) {
+	    if (t->class != REF) {
+		panic("unexpected class %d for parameter", t->class);
+	    }
+	    printdecl(t, 0);
+	}
+    } else {
+	putchar('\n');
+    }
+}
+
+/*
+ * Print out the value on the top of the expression stack
+ * in the format for the type of the given symbol.
+ */
+
+public fortran_printval(s)
+Symbol s;
+{
+    register Symbol t;
+    register Address a;
+    register int i, len;
+
+    /* printf("fortran_printval with class %s \n",classname(s)); OUT*/
+    switch (s->class) {
+	case CONST:
+	case TYPE:
+	case VAR:
+	case REF:
+	case FVAR:
+	case TAG:
+	    fortran_printval(s->type);
+	    break;
+
+	case ARRAY:
+	    t = rtype(s->type);
+	    if (t->class == RANGE and istypename(t->type, "char")) {
+		len = size(s);
+		sp -= len;
+		printf("\"%.*s\"", len, sp);
+	    } else {
+		fortran_printarray(s);
+	    }
+	    break;
+
+	case RANGE:
+	     if (isfloat(s)) {
+		switch (s->symvalue.rangev.lower) {
+		    case sizeof(float):
+			prtreal(pop(float));
+			break;
+
+		    case sizeof(double):
+			if(istypename(s->type,"complex")) {
+			   printf("(");
+			prtreal(pop(float));
+			   printf(",");
+			prtreal(pop(float));
+			   printf(")");
+			}
+			else prtreal(pop(double));
+			break;
+
+		    default:
+			panic("bad size \"%d\" for real",
+                                  t->symvalue.rangev.lower);
+			break;
+		}
+	    } else {
+		printint(popsmall(s), s);
+	    }
+	    break;
+
+	default:
+	    if (ord(s->class) > ord(TYPEREF)) {
+		panic("printval: bad class %d", ord(s->class));
+	    }
+	    error("don't know how to print a %s", fortran_classname(s));
+	    /* NOTREACHED */
+    }
+}
+
+/*
+ * Print out an int 
+ */
+
+private printint(i, t)
+Integer i;
+register Symbol t;
+{
+    if (istypename(t->type, "logical")) {
+	printf(((Boolean) i) == true ? "true" : "false");
+    }
+    else if ( (t->type == t_int) or istypename(t->type, "integer") or
+                  istypename(t->type,"integer*2") ) {
+	printf("%ld", i);
+    } else {
+      error("unkown type in fortran printint");
+    }
+}
+
+/*
+ * Print out a null-terminated string (pointer to char)
+ * starting at the given address.
+ */
+
+private printstring(addr)
+Address addr;
+{
+    register Address a;
+    register Integer i, len;
+    register Boolean endofstring;
+    union {
+	char ch[sizeof(Word)];
+	int word;
+    } u;
+
+    putchar('"');
+    a = addr;
+    endofstring = false;
+    while (not endofstring) {
+	dread(&u, a, sizeof(u));
+	i = 0;
+	do {
+	    if (u.ch[i] == '\0') {
+		endofstring = true;
+	    } else {
+		printchar(u.ch[i]);
+	    }
+	    ++i;
+	} while (i < sizeof(Word) and not endofstring);
+	a += sizeof(Word);
+    }
+    putchar('"');
+}
+/*
+ * Return the FORTRAN name for the particular class of a symbol.
+ */
+
+public String fortran_classname(s)
+Symbol s;
+{
+    String str;
+
+    switch (s->class) {
+	case REF:
+	    str = "dummy argument";
+	    break;
+
+	case CONST:
+	    str = "parameter";
+	    break;
+
+	default:
+	    str = classname(s);
+    }
+    return str;
+}
+
+/* reverses the indices from the expr_list; should be folded into buildaref
+ * and done as one recursive routine
+ */
+Node private rev_index(here,n)
+register Node here,n;
+{
+ 
+  register Node i;
+
+  if( here == nil  or  here == n) i=nil;
+  else if( here->value.arg[1] == n) i = here;
+  else i=rev_index(here->value.arg[1],n);
+  return i;
+}
+
+public Node fortran_buildaref(a, slist)
+Node a, slist;
+{
+    register Symbol as;      /* array of array of .. cursor */
+    register Node en;        /* Expr list cursor */
+    Symbol etype;            /* Type of subscript expr */
+    Node esub, tree;         /* Subscript expression ptr and tree to be built*/
+
+    tree=a;
+
+    as = rtype(tree->nodetype);     /* node->sym.type->array*/
+    if ( not (
+               (tree->nodetype->class == VAR or tree->nodetype->class == REF)
+                and as->class == ARRAY
+             ) ) {
+	beginerrmsg();
+	prtree(stderr, a);
+	fprintf(stderr, " is not an array");
+	/*fprintf(stderr, " a-> %x as %x ", tree->nodetype, as ); OUT*/
+	enderrmsg();
+    } else {
+	for (en = rev_index(slist,nil); en != nil and as->class == ARRAY;
+                     en = rev_index(slist,en), as = as->type) {
+	    esub = en->value.arg[0];
+	    etype = rtype(esub->nodetype);
+            assert(as->chain->class == RANGE);
+	    if ( not compatible( t_int, etype) ) {
+		beginerrmsg();
+		fprintf(stderr, "subscript ");
+		prtree(stderr, esub);
+		fprintf(stderr, " is type %s ",symname(etype->type) );
+		enderrmsg();
+	    }
+	    tree = build(O_INDEX, tree, esub);
+	    tree->nodetype = as->type;
+	}
+	if (en != nil or
+             (as->class == ARRAY && (not istypename(as->type,"char"))) ) {
+	    beginerrmsg();
+	    if (en != nil) {
+		fprintf(stderr, "too many subscripts for ");
+	    } else {
+		fprintf(stderr, "not enough subscripts for ");
+	    }
+	    prtree(stderr, tree);
+	    enderrmsg();
+	}
+    }
+    return tree;
+}
+
+/*
+ * Evaluate a subscript index.
+ */
+
+public int fortran_evalaref(s, i)
+Symbol s;
+long i;
+{
+    Symbol r;
+    long lb, ub;
+
+    r = rtype(s)->chain;
+    if(r->symvalue.rangev.lowertype == R_ARG or
+       r->symvalue.rangev.lowertype == R_TEMP  ) {
+	if(! getbound(s,r->symvalue.rangev.lower,
+		        r->symvalue.rangev.lowertype,&lb))
+          error("dynamic bounds not currently available");
+    }
+    else lb = r->symvalue.rangev.lower;
+
+    if(r->symvalue.rangev.uppertype == R_ARG or
+       r->symvalue.rangev.uppertype == R_TEMP  ) {
+	if(! getbound(s,r->symvalue.rangev.upper,
+		        r->symvalue.rangev.uppertype,&ub))
+          error("dynamic bounds not currently available");
+    }
+    else ub = r->symvalue.rangev.upper;
+
+    if (i < lb or i > ub) {
+	error("subscript out of range");
+    }
+    return (i - lb);
+}
+
+private fortran_printarray(a)
+Symbol a;
+{
+struct Bounds { int lb, val, ub} dim[MAXDIM];
+
+Symbol sc,st,eltype;
+char buf[50];
+char *subscr;
+int i,ndim,elsize;
+Stack *savesp;
+Boolean done;
+
+st = a;
+
+savesp = sp;
+sp -= size(a);
+ndim=0;
+
+for(;;){
+          sc = st->chain;
+          if(sc->symvalue.rangev.lowertype == R_ARG or
+             sc->symvalue.rangev.lowertype == R_TEMP) {
+	      if( ! getbound(a,sc->symvalue.rangev.lower, 
+                    sc->symvalue.rangev.lowertype, &dim[ndim].lb) )
+		error(" dynamic bounds not currently available");
+	  }
+	  else dim[ndim].lb = sc->symvalue.rangev.lower;
+
+          if(sc->symvalue.rangev.uppertype == R_ARG or
+             sc->symvalue.rangev.uppertype == R_TEMP) {
+	      if( ! getbound(a,sc->symvalue.rangev.upper, 
+                    sc->symvalue.rangev.uppertype, &dim[ndim].ub) )
+		error(" dynamic bounds not currently available");
+	  }
+	  else dim[ndim].ub = sc->symvalue.rangev.upper;
+
+          ndim ++;
+          if (st->type->class == ARRAY) st=st->type;
+	  else break;
+     }
+
+if(istypename(st->type,"char")) {
+		eltype = st;
+		ndim--;
+	}
+else eltype=st->type;
+elsize=size(eltype);
+sp += elsize;
+ /*printf("ndim %d elsize %lx in fortran_printarray\n",ndim,elsize);OUT*/
+
+ndim--;
+for (i=0;i<=ndim;i++){
+	  dim[i].val=dim[i].lb;
+	  /*OUT printf(" %d %d %d \n",i,dim[i].lb,dim[i].ub);
+	    fflush(stdout); OUT*/
+}
+
+
+for(;;) {
+	buf[0]=',';
+	subscr = buf+1;
+
+	for (i=ndim-1;i>=0;i--)  {
+
+		sprintf(subscr,"%d,",dim[i].val);
+        	subscr += strlen(subscr);
+	}
+        *--subscr = '\0';
+
+	for(i=dim[ndim].lb;i<=dim[ndim].ub;i++) {
+	      	printf("[%d%s]\t",i,buf);
+		printval(eltype);
+	      	printf("\n");
+		sp += 2*elsize;
+	}
+        dim[ndim].val=dim[ndim].ub;
+
+        i=ndim-1;
+        if (i<0) break;
+
+        done=false;
+        do {
+		dim[i].val++;
+		if(dim[i].val > dim[i].ub) { 
+			dim[i].val = dim[i].lb;
+			if(--i<0) done=true;
+		}
+		else done=true;
+         }
+	 while (not done);
+         if (i<0) break;
+     }
+}
diff --git a/dbx/fortran.h b/dbx/fortran.h
new file mode 100644
index 0000000..299feea
--- /dev/null
+++ b/dbx/fortran.h
@@ -0,0 +1,11 @@
+#ifndef fortran_h
+#define fortran_h
+fortran_init(/*  */);
+Boolean fortran_typematch(/* type1, type2 */);
+fortran_printdecl(/* s */);
+fortran_listparams(/* s */);
+fortran_printval(/* s */);
+String fortran_classname(/* s */);
+Node fortran_buildaref(/* a, slist */);
+int fortran_evalaref(/* s, i */);
+#endif
diff --git a/dbx/keywords.c b/dbx/keywords.c
new file mode 100644
index 0000000..2dd57d3
--- /dev/null
+++ b/dbx/keywords.c
@@ -0,0 +1,195 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)keywords.c 1.3 5/18/83";
+
+/*
+ * Keyword management.
+ */
+
+#include "defs.h"
+#include "keywords.h"
+#include "scanner.h"
+#include "names.h"
+#include "symbols.h"
+#include "tree.h"
+#include "y.tab.h"
+
+#ifndef public
+#include "scanner.h"
+#endif
+
+private String reserved[] ={
+    "alias", "and", "assign", "at", "call", "catch", "cont",
+    "debug", "delete", "div", "dump", "edit", "file", "func",
+    "gripe", "help", "if", "ignore", "in",
+    "list", "mod", "next", "nexti", "nil", "not", "or",
+    "print", "psym", "quit", "run",
+    "sh", "skip", "source", "status", "step", "stepi",
+    "stop", "stopi", "trace", "tracei",
+    "use", "whatis", "when", "where", "whereis", "which",
+    "INT", "REAL", "NAME", "STRING",
+    "LFORMER", "RFORMER", "#^", "->"
+};
+
+/*
+ * The keyword table is a traditional hash table with collisions
+ * resolved by chaining.
+ */
+
+#define HASHTABLESIZE 503
+
+typedef struct Keyword {
+    Name name;
+    Token toknum : 16;
+    Boolean isalias : 16;
+    struct Keyword *chain;
+} *Keyword;
+
+typedef unsigned int Hashvalue;
+
+private Keyword hashtab[HASHTABLESIZE];
+
+#define hash(n) ((((unsigned) n) >> 2) mod HASHTABLESIZE)
+
+/*
+ * Enter all the reserved words into the keyword table.
+ */
+
+public enterkeywords()
+{
+    register Integer i;
+
+    for (i = ALIAS; i <= WHICH; i++) {
+	keyword(reserved[ord(i) - ord(ALIAS)], i, false);
+    }
+    keyword("set", ASSIGN, false);
+}
+
+/*
+ * Deallocate the keyword table.
+ */
+
+public keywords_free()
+{
+    register Integer i;
+    register Keyword k, nextk;
+
+    for (i = 0; i < HASHTABLESIZE; i++) {
+	k = hashtab[i];
+	while (k != nil) {
+	    nextk = k->chain;
+	    dispose(k);
+	    k = nextk;
+	}
+	hashtab[i] = nil;
+    }
+}
+
+/*
+ * Enter a keyword into the name table.  It is assumed to not be there already.
+ * The string is assumed to be statically allocated.
+ */
+
+private keyword(s, t, isalias)
+String s;
+Token t;
+Boolean isalias;
+{
+    register Hashvalue h;
+    register Keyword k;
+    Name n;
+
+    n = identname(s, true);
+    h = hash(n);
+    k = new(Keyword);
+    k->name = n;
+    k->toknum = t;
+    k->isalias = isalias;
+    k->chain = hashtab[h];
+    hashtab[h] = k;
+}
+
+/*
+ * Return the string associated with a token corresponding to a keyword.
+ */
+
+public String keywdstring(t)
+Token t;
+{
+    return reserved[ord(t) - ord(ALIAS)];
+}
+
+/*
+ * Find a keyword in the keyword table.
+ * We assume that tokens cannot legitimately be nil (0).
+ */
+
+public Token findkeyword(n)
+Name n;
+{
+    register Hashvalue h;
+    register Keyword k;
+    Token t;
+
+    h = hash(n);
+    k = hashtab[h];
+    while (k != nil and k->name != n) {
+	k = k->chain;
+    }
+    if (k == nil) {
+	t = nil;
+    } else {
+	t = k->toknum;
+    }
+    return t;
+}
+
+/*
+ * Create an alias.
+ */
+
+public enter_alias(newcmd, oldcmd)
+Name newcmd;
+Name oldcmd;
+{
+    Token t;
+
+    t = findkeyword(oldcmd);
+    if (t == nil) {
+	error("\"%s\" is not a command", ident(oldcmd));
+    } else {
+	keyword(ident(newcmd), t, true);
+    }
+}
+
+/*
+ * Print out an alias.
+ */
+
+public print_alias(cmd)
+Name cmd;
+{
+    register Keyword k;
+    register Integer i;
+    Token t;
+
+    if (cmd == nil) {
+	for (i = 0; i < HASHTABLESIZE; i++) {
+	    for (k = hashtab[i]; k != nil; k = k->chain) {
+		if (k->isalias) {
+		    if (isredirected()) {
+			printf("alias ");
+		    }
+		    printf("%s\t%s\n", ident(k->name), keywdstring(k->toknum));
+		}
+	    }
+	}
+    } else {
+	t = findkeyword(cmd);
+	if (t == nil) {
+	    printf("\n");
+	} else {
+	    printf("%s\n", keywdstring(t));
+	}
+    }
+}
diff --git a/dbx/keywords.h b/dbx/keywords.h
new file mode 100644
index 0000000..60bc861
--- /dev/null
+++ b/dbx/keywords.h
@@ -0,0 +1,10 @@
+#ifndef keywords_h
+#define keywords_h
+#include "scanner.h"
+enterkeywords(/*  */);
+keywords_free(/*  */);
+String keywdstring(/* t */);
+Token findkeyword(/* n */);
+enter_alias(/* newcmd, oldcmd */);
+print_alias(/* cmd */);
+#endif
diff --git a/dbx/languages.c b/dbx/languages.c
new file mode 100644
index 0000000..0f730ba
--- /dev/null
+++ b/dbx/languages.c
@@ -0,0 +1,106 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)languages.c 1.3 5/18/83";
+
+/*
+ * Language management.
+ */
+
+#include "defs.h"
+#include "languages.h"
+#include "c.h"
+#include "pascal.h"
+#include "asm.h"
+
+#ifndef public
+typedef struct Language *Language;
+
+typedef enum {
+    L_PRINTDECL, L_PRINTVAL, L_TYPEMATCH, L_BUILDAREF, L_EVALAREF
+} LanguageOp;
+
+typedef LanguageOperation();
+#endif
+
+struct Language {
+    String name;
+    String suffix;
+    LanguageOperation *op[10];
+    Language next;
+};
+
+private Language head;
+
+/*
+ * Initialize language information.
+ *
+ * The last language initialized will be the default one
+ * for otherwise indistinguised symbols.
+ */
+
+public language_init()
+{
+    c_init();
+    fortran_init();
+    pascal_init();
+    asm_init();
+}
+
+public Language findlanguage(suffix)
+String suffix;
+{
+    Language lang;
+
+    lang = head;
+    if (suffix != nil) {
+	while (lang != nil and not streq(lang->suffix, suffix)) {
+	    lang = lang->next;
+	}
+	if (lang == nil) {
+	    lang = head;
+	}
+    }
+    return lang;
+}
+
+public String language_name(lang)
+Language lang;
+{
+    return (lang == nil) ? "(nil)" : lang->name;
+}
+
+public Language language_define(name, suffix)
+String name;
+String suffix;
+{
+    Language p;
+
+    p = new(Language);
+    p->name = name;
+    p->suffix = suffix;
+    p->next = head;
+    head = p;
+    return p;
+}
+
+public language_setop(lang, op, operation)
+Language lang;
+LanguageOp op;
+LanguageOperation *operation;
+{
+    checkref(lang);
+    assert(ord(op) <= ord(L_EVALAREF));
+    lang->op[ord(op)] = operation;
+}
+
+public LanguageOperation *language_op(lang, op)
+Language lang;
+LanguageOp op;
+{
+    LanguageOperation *o;
+
+    checkref(lang);
+    o = lang->op[ord(op)];
+    checkref(o);
+    return o;
+}
diff --git a/dbx/languages.h b/dbx/languages.h
new file mode 100644
index 0000000..a3be84c
--- /dev/null
+++ b/dbx/languages.h
@@ -0,0 +1,16 @@
+#ifndef languages_h
+#define languages_h
+typedef struct Language *Language;
+
+typedef enum {
+    L_PRINTDECL, L_PRINTVAL, L_TYPEMATCH, L_BUILDAREF, L_EVALAREF
+} LanguageOp;
+
+typedef LanguageOperation();
+language_init(/*  */);
+Language findlanguage(/* suffix */);
+String language_name(/* lang */);
+Language language_define(/* name, suffix */);
+language_setop(/* lang, op, operation */);
+LanguageOperation *language_op(/* lang, op */);
+#endif
diff --git a/dbx/library.c b/dbx/library.c
new file mode 100644
index 0000000..f28062b
--- /dev/null
+++ b/dbx/library.c
@@ -0,0 +1,690 @@
+#ifndef lint
+static char sccsid[] = "@(#)library.c	1.4 (Berkeley) 8/13/83";
+#endif
+
+/* Copyright (c) 1982 Regents of the University of California */
+
+/*
+ * General purpose routines.
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <signal.h>
+
+#define public
+#define private static
+#define and &&
+#define or ||
+#define not !
+#define ord(enumcon)	((int) enumcon)
+#define nil(type)	((type) 0)
+
+typedef enum { FALSE, TRUE } Boolean;
+typedef char *String;
+typedef FILE *File;
+typedef String Filename;
+
+#undef FILE
+
+/*
+ * Definitions of standard C library routines that aren't in the
+ * standard I/O library, but which are generally useful.
+ */
+
+extern long atol();		/* ascii to long */
+extern double atof();		/* ascii to floating point */
+extern char *mktemp();		/* make a temporary file name */
+
+String cmdname;			/* name of command for error messages */
+Filename errfilename;		/* current file associated with error */
+short errlineno;		/* line number associated with error */
+
+/*
+ * Definitions for doing memory allocation.
+ */
+
+extern char *malloc();
+
+#define alloc(n, type)	((type *) malloc((unsigned) (n) * sizeof(type)))
+#define dispose(p)	{ free((char *) p); p = 0; }
+
+/*
+ * Macros for doing freads + fwrites.
+ */
+
+#define get(fp, var)	fread((char *) &(var), sizeof(var), 1, fp)
+#define put(fp, var)	fwrite((char *) &(var), sizeof(var), 1, fp)
+
+/*
+ * String definitions.
+ */
+
+extern String strcpy(), index(), rindex();
+extern int strlen();
+
+#define strdup(s)		strcpy(malloc((unsigned) strlen(s) + 1), s)
+#define streq(s1, s2)	(strcmp(s1, s2) == 0)
+
+typedef int INTFUNC();
+
+typedef struct {
+    INTFUNC *func;
+} ERRINFO;
+
+#define ERR_IGNORE ((INTFUNC *) 0)
+#define ERR_CATCH  ((INTFUNC *) 1)
+
+/*
+ * Call a program.
+ *
+ * Four entries:
+ *
+ *	call, callv - call a program and wait for it, returning status
+ *	back, backv - call a program and don't wait, returning process id
+ *
+ * The command's standard input and output are passed as FILE's.
+ */
+
+
+#define MAXNARGS 100    /* unchecked upper limit on max num of arguments */
+#define BADEXEC 127	/* exec fails */
+
+#define ischild(pid)    ((pid) == 0)
+
+/* VARARGS3 */
+public int call(name, in, out, args)
+String name;
+File in;
+File out;
+String args;
+{
+    String *ap, *argp;
+    String argv[MAXNARGS];
+
+    argp = &argv[0];
+    *argp++ = name;
+    ap = &args;
+    while (*ap != nil(String)) {
+	*argp++ = *ap++;
+    }
+    *argp = nil(String);
+    return callv(name, in, out, argv);
+}
+
+/* VARARGS3 */
+public int back(name, in, out, args)
+String name;
+File in;
+File out;
+String args;
+{
+    String *ap, *argp;
+    String argv[MAXNARGS];
+
+    argp = &argv[0];
+    *argp++ = name;
+    ap = &args;
+    while (*ap != nil(String)) {
+	*argp++ = *ap++;
+    }
+    *argp = nil(String);
+    return backv(name, in, out, argv);
+}
+
+public int callv(name, in, out, argv)
+String name;
+File in;
+File out;
+String *argv;
+{
+    int pid, status;
+
+    pid = backv(name, in, out, argv);
+    pwait(pid, &status);
+    return status;
+}
+
+public int backv(name, in, out, argv)
+String name;
+File in;
+File out;
+String *argv;
+{
+    int pid;
+
+    fflush(stdout);
+    if (ischild(pid = fork())) {
+	fswap(0, fileno(in));
+	fswap(1, fileno(out));
+	onsyserr(EACCES, ERR_IGNORE);
+	execvp(name, argv);
+	_exit(BADEXEC);
+    }
+    return pid;
+}
+
+/*
+ * Swap file numbers so as to redirect standard input and output.
+ */
+
+private fswap(oldfd, newfd)
+int oldfd;
+int newfd;
+{
+    if (oldfd != newfd) {
+	close(oldfd);
+	dup(newfd);
+	close(newfd);
+    }
+}
+
+/*
+ * Invoke a shell on a command line.
+ */
+
+#define DEF_SHELL	"csh"
+
+public shell(s)
+String s;
+{
+    extern String getenv();
+    String sh;
+
+    if ((sh = getenv("SHELL")) == nil(String)) {
+	sh = DEF_SHELL;
+    }
+    if (s != nil(String) and *s != '\0') {
+	call(sh, stdin, stdout, "-c", s, 0);
+    } else {
+	call(sh, stdin, stdout, 0);
+    }
+}
+
+/*
+ * Wait for a process the right way.  We wait for a particular
+ * process and if any others come along in between, we remember them
+ * in case they are eventually waited for.
+ *
+ * This routine is not very efficient when the number of processes
+ * to be remembered is large.
+ *
+ * To deal with a kernel idiosyncrasy, we keep a list on the side
+ * of "traced" processes, and do not notice them when waiting for
+ * another process.
+ */
+
+typedef struct pidlist {
+    int pid;
+    int status;
+    struct pidlist *next;
+} Pidlist;
+
+private Pidlist *pidlist, *ptrclist, *pfind();
+
+public ptraced(pid)
+int pid;
+{
+    Pidlist *p;
+
+    p = alloc(1, Pidlist);
+    p->pid = pid;
+    p->next = ptrclist;
+    ptrclist = p;
+}
+
+public unptraced(pid)
+int pid;
+{
+    register Pidlist *p, *prev;
+
+    prev = nil(Pidlist *);
+    p = ptrclist;
+    while (p != nil(Pidlist *) and p->pid != pid) {
+	prev = p;
+	p = p->next;
+    }
+    if (p != nil(Pidlist *)) {
+	if (prev == nil(Pidlist *)) {
+	    ptrclist = p->next;
+	} else {
+	    prev->next = p->next;
+	}
+	dispose(p);
+    }
+}
+
+private Boolean isptraced(pid)
+int pid;
+{
+    register Pidlist *p;
+
+    p = ptrclist;
+    while (p != nil(Pidlist *) and p->pid != pid) {
+	p = p->next;
+    }
+    return (Boolean) (p != nil(Pidlist *));
+}
+
+public pwait(pid, statusp)
+int pid, *statusp;
+{
+    Pidlist *p;
+    int pnum, status;
+
+    p = pfind(pid);
+    if (p != nil(Pidlist *)) {
+	*statusp = p->status;
+	dispose(p);
+    } else {
+	pnum = wait(&status);
+	while (pnum != pid and pnum >= 0) {
+	    if (not isptraced(pnum)) {
+		p = alloc(1, Pidlist);
+		p->pid = pnum;
+		p->status = status;
+		p->next = pidlist;
+		pidlist = p;
+	    }
+	    pnum = wait(&status);
+	}
+	if (pnum < 0) {
+	    p = pfind(pid);
+	    if (p == nil(Pidlist *)) {
+		panic("pwait: pid %d not found", pid);
+	    }
+	    *statusp = p->status;
+	    dispose(p);
+	} else {
+	    *statusp = status;
+	}
+    }
+}
+
+/*
+ * Look for the given process id on the pidlist.
+ *
+ * Unlink it from list if found.
+ */
+
+private Pidlist *pfind(pid)
+int pid;
+{
+    register Pidlist *p, *prev;
+
+    prev = nil(Pidlist *);
+    for (p = pidlist; p != nil(Pidlist *); p = p->next) {
+	if (p->pid == pid) {
+	    break;
+	}
+	prev = p;
+    }
+    if (p != nil(Pidlist *)) {
+	if (prev == nil(Pidlist *)) {
+	    pidlist = p->next;
+	} else {
+	    prev->next = p->next;
+	}
+    }
+    return p;
+}
+
+/*
+ * System call error handler.
+ *
+ * The syserr routine is called when a system call is about to
+ * set the c-bit to report an error.  Certain errors are caught
+ * and cause the process to print a message and immediately exit.
+ */
+
+extern int sys_nerr;
+extern char *sys_errlist[];
+ 
+/*
+ * Before calling syserr, the integer errno is set to contain the
+ * number of the error.  The routine "_mycerror" is a dummy which
+ * is used to force the loader to get my version of cerror rather
+ * than the usual one.
+ */
+
+extern int errno;
+extern _mycerror();
+
+/*
+ * Default error handling.
+ */
+
+private ERRINFO errinfo[] ={
+/* no error */	ERR_IGNORE,
+/* EPERM */	ERR_IGNORE,
+/* ENOENT */	ERR_IGNORE,
+/* ESRCH */	ERR_IGNORE,
+/* EINTR */	ERR_CATCH,
+/* EIO */	ERR_CATCH,
+/* ENXIO */	ERR_CATCH,
+/* E2BIG */	ERR_CATCH,
+/* ENOEXEC */	ERR_CATCH,
+/* EBADF */	ERR_IGNORE,
+/* ECHILD */	ERR_CATCH,
+/* EAGAIN */	ERR_CATCH,
+/* ENOMEM */	ERR_CATCH,
+/* EACCES */	ERR_CATCH,
+/* EFAULT */	ERR_CATCH,
+/* ENOTBLK */	ERR_CATCH,
+/* EBUSY */	ERR_CATCH,
+/* EEXIST */	ERR_CATCH,
+/* EXDEV */	ERR_CATCH,
+/* ENODEV */	ERR_CATCH,
+/* ENOTDIR */	ERR_CATCH,
+/* EISDIR */	ERR_CATCH,
+/* EINVAL */	ERR_CATCH,
+/* ENFILE */	ERR_CATCH,
+/* EMFILE */	ERR_CATCH,
+/* ENOTTY */	ERR_IGNORE,
+/* ETXTBSY */	ERR_CATCH,
+/* EFBIG */	ERR_CATCH,
+/* ENOSPC */	ERR_CATCH,
+/* ESPIPE */	ERR_CATCH,
+/* EROFS */	ERR_CATCH,
+/* EMLINK */	ERR_CATCH,
+/* EPIPE */	ERR_CATCH,
+/* EDOM */	ERR_CATCH,
+/* ERANGE */	ERR_CATCH,
+/* EQUOT */	ERR_CATCH,
+};
+
+public syserr()
+{
+    ERRINFO *e;
+
+    e = &errinfo[errno];
+    if (e->func == ERR_CATCH) {
+	if (errno < sys_nerr) {
+	    fatal(sys_errlist[errno]);
+	} else {
+	    fatal("errno %d", errno);
+	}
+    } else if (e->func != ERR_IGNORE) {
+	(*e->func)();
+    }
+}
+
+/*
+ * Catcherrs only purpose is to get this module loaded and make
+ * sure my cerror is loaded (only applicable when this is in a library).
+ */
+
+public catcherrs()
+{
+    _mycerror();
+}
+
+/*
+ * Change the action on receipt of an error.
+ */
+
+public onsyserr(n, f)
+int n;
+INTFUNC *f;
+{
+    errinfo[n].func = f;
+}
+
+/*
+ * Print the message associated with the given signal.
+ * Like a "perror" for signals.
+ */
+
+public int sys_nsig = NSIG;
+public String sys_siglist[] = {
+    "no signal",
+    "hangup",
+    "interrupt",
+    "quit",
+    "illegal instruction",
+    "trace trap",
+    "IOT instruction",
+    "EMT instruction",
+    "floating point exception",
+    "kill",
+    "bus error",
+    "segmentation violation",
+    "bad argument to system call",
+    "broken pipe",
+    "alarm clock",
+    "soft kill",
+    "urgent I/O condition",
+    "stop signal not from tty",
+    "stop signal from tty",
+    "continue",
+    "child termination",
+    "stop (tty input)",
+    "stop (tty output)",
+    "possible input/output",
+    "exceeded CPU time limit",
+    "exceeded file size limit",
+    nil(String)
+};
+
+public psig(s)
+String s;
+{
+    String c;
+    int n;
+
+    c = "Unknown signal";
+    if (errno < sys_nsig) {
+	c = sys_errlist[errno];
+    }
+    n = strlen(s);
+    if (n > 0) {
+	write(2, s, n);
+	write(2, ": ", 2);
+    }
+    write(2, c, strlen(c));
+    write(2, "\n", 1);
+}
+
+/*
+ * Standard error handling routines.
+ */
+
+private short nerrs;
+private short nwarnings;
+
+/*
+ * Main driver of error message reporting.
+ */
+
+/* VARARGS2 */
+private errmsg(errname, shouldquit, s, a, b, c, d, e, f, g, h, i, j, k, l, m)
+String errname;
+Boolean shouldquit;
+String s;
+{
+    fflush(stdout);
+    if (shouldquit and cmdname != nil(String)) {
+	fprintf(stderr, "%s: ", cmdname);
+    }
+    if (errfilename != nil(Filename)) {
+	fprintf(stderr, "%s: ", errfilename);
+    }
+    if (errlineno > 0) {
+	fprintf(stderr, "%d: ", errlineno);
+    }
+    if (errname != nil(String)) {
+	fprintf(stderr, "%s: ", errname);
+    }
+    fprintf(stderr, s, a, b, c, d, e, f, g, h, i, j, k, l, m);
+    putc('\n', stderr);
+    if (shouldquit) {
+	quit(1);
+    }
+}
+
+/*
+ * For when printf isn't sufficient for printing the error message ...
+ */
+
+public beginerrmsg()
+{
+    fflush(stdout);
+    if (errfilename != nil(String)) {
+	fprintf(stderr, "%s: ", errfilename);
+    }
+    if (errlineno > 0) {
+	fprintf(stderr, "%d: ", errlineno);
+    }
+}
+
+public enderrmsg()
+{
+    putc('\n', stderr);
+    erecover();
+}
+
+/*
+ * The messages are listed in increasing order of seriousness.
+ *
+ * First are warnings.
+ */
+
+/* VARARGS1 */
+public warning(s, a, b, c, d, e, f, g, h, i, j, k, l, m)
+String s;
+{
+    nwarnings++;
+    errmsg("warning", FALSE, s, a, b, c, d, e, f, g, h, i, j, k, l, m);
+}
+
+/*
+ * Errors are a little worse, they mean something is wrong,
+ * but not so bad that processing can't continue.
+ *
+ * The routine "erecover" is called to recover from the error,
+ * a default routine is provided that does nothing.
+ */
+
+/* VARARGS1 */
+public error(s, a, b, c, d, e, f, g, h, i, j, k, l, m)
+String s;
+{
+    extern erecover();
+
+    nerrs++;
+    errmsg(nil(String), FALSE, s, a, b, c, d, e, f, g, h, i, j, k, l, m);
+    erecover();
+}
+
+/*
+ * Non-recoverable user error.
+ */
+
+/* VARARGS1 */
+public fatal(s, a, b, c, d, e, f, g, h, i, j, k, l, m)
+String s;
+{
+    errmsg("fatal error", TRUE, s, a, b, c, d, e, f, g, h, i, j, k, l, m);
+}
+
+/*
+ * Panics indicate an internal program error.
+ */
+
+/* VARARGS1 */
+public panic(s, a, b, c, d, e, f, g, h, i, j, k, l, m)
+String s;
+{
+    errmsg("internal error", TRUE, s, a, b, c, d, e, f, g, h, i, j, k, l, m);
+}
+
+short numerrors()
+{
+    short r;
+
+    r = nerrs;
+    nerrs = 0;
+    return r;
+}
+
+short numwarnings()
+{
+    short r;
+
+    r = nwarnings;
+    nwarnings = 0;
+    return r;
+}
+
+/*
+ * Recover from an error.
+ *
+ * This is the default routine which we aren't using since we have our own.
+ *
+public erecover()
+{
+}
+ *
+ */
+
+/*
+ * Default way to quit from a program is just to exit.
+ *
+public quit(r)
+int r;
+{
+    exit(r);
+}
+ *
+ */
+
+/*
+ * Compare n-byte areas pointed to by s1 and s2
+ * if n is 0 then compare up until one has a null byte.
+ */
+
+public int cmp(s1, s2, n)
+register char *s1, *s2;
+register unsigned int n;
+{
+    if (s1 == nil(char *) || s2 == nil(char *)) {
+	panic("cmp: nil pointer");
+    }
+    if (n == 0) {
+	while (*s1 == *s2++) {
+	    if (*s1++ == '\0') {
+		return(0);
+	    }
+	}
+	return(*s1 - *(s2-1));
+    } else {
+	for (; n != 0; n--) {
+	    if (*s1++ != *s2++) {
+		return(*(s1-1) - *(s2-1));
+	    }
+	}
+	return(0);
+    }
+}
+
+/*
+ * Move n bytes from src to dest.
+ * If n is 0 move until a null is found.
+ */
+
+public mov(src, dest, n)
+register char *src, *dest;
+register unsigned int n;
+{
+    if (src == nil(char *))
+	panic("mov: nil source");
+    if (dest == nil(char *))
+	panic("mov: nil destination");
+    if (n != 0) {
+	for (; n != 0; n--) {
+	    *dest++ = *src++;
+	}
+    } else {
+	while ((*dest++ = *src++) != '\0');
+    }
+}
diff --git a/dbx/lists.c b/dbx/lists.c
new file mode 100644
index 0000000..f6dc50e
--- /dev/null
+++ b/dbx/lists.c
@@ -0,0 +1,221 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)lists.c 1.2 12/15/82";
+
+/*
+ * General list definitions.
+ *
+ * The assumption is that the elements in a list are words,
+ * usually pointers to the actual information.
+ */
+
+#include "defs.h"
+#include "lists.h"
+
+#ifndef public
+
+typedef struct List *List;
+typedef struct ListItem *ListItem;
+typedef char *ListElement;
+
+#define list_item(element) generic_list_item((ListElement) (element))
+#define list_element(type, item) ((type) (item == nil ? nil : (item)->element))
+#define list_head(list) ((list == nil) ? nil : (list)->head)
+#define list_tail(list) ((list == nil) ? nil : (list)->tail)
+#define list_next(item) ((item == nil) ? nil : (item)->next)
+#define list_prev(item) ((item == nil) ? nil : (item)->prev)
+#define list_size(list) (((list) == nil) ? 0 : (list)->nitems)
+
+#define foreach(type, i, list) \
+{ \
+    register ListItem _item; \
+ \
+    _item = list_head(list); \
+    while (_item != nil) { \
+	i = list_element(type, _item); \
+	_item = list_next(_item);
+
+#define endfor \
+    } \
+}
+
+/*
+ * Iterate through two equal-sized lists.
+ */
+
+#define foreach2(type1, i, list1, type2, j, list2) \
+{ \
+    register ListItem _item1, _item2; \
+ \
+    _item1 = list_head(list1); \
+    _item2 = list_head(list2); \
+    while (_item1 != nil) { \
+	i = list_element(type1, _item1); \
+	j = list_element(type2, _item2); \
+	_item1 = list_next(_item1); \
+	_item2 = list_next(_item2);
+
+#define list_islast() (_item == nil)
+#define list_curitem(list) (_item == nil ? list_tail(list) : list_prev(_item))
+
+/*
+ * Representation should not be used outside except through macros.
+ */
+
+struct List {
+    Integer nitems;
+    ListItem head;
+    ListItem tail;
+};
+
+struct ListItem {
+    ListElement element;
+    ListItem next;
+    ListItem prev;
+};
+
+#endif
+
+/*
+ * Allocate and initialize a list.
+ */
+
+public List list_alloc()
+{
+    List list;
+
+    list = new(List);
+    list->nitems = 0;
+    list->head = nil;
+    list->tail = nil;
+    return list;
+}
+
+/*
+ * Create a list item from an object (represented as pointer or integer).
+ */
+
+public ListItem generic_list_item(element)
+ListElement element;
+{
+    ListItem i;
+
+    i = new(ListItem);
+    i->element = element;
+    i->next = nil;
+    i->prev = nil;
+    return i;
+}
+
+/*
+ * Insert an item before the item in a list.
+ */
+
+public list_insert(item, after, list)
+ListItem item;
+ListItem after;
+List list;
+{
+    ListItem a;
+
+    checkref(list);
+    list->nitems = list->nitems + 1;
+    if (list->head == nil) {
+	list->head = item;
+	list->tail = item;
+    } else {
+	if (after == nil) {
+	    a = list->head;
+	} else {
+	    a = after;
+	}
+	item->next = a;
+	item->prev = a->prev;
+	if (a->prev != nil) {
+	    a->prev->next = item;
+	} else {
+	    list->head = item;
+	}
+	a->prev = item;
+    }
+}
+
+/*
+ * Append an item after the given item in a list.
+ */
+
+public list_append(item, before, list)
+ListItem item;
+ListItem before;
+List list;
+{
+    ListItem b;
+
+    checkref(list);
+    list->nitems = list->nitems + 1;
+    if (list->head == nil) {
+	list->head = item;
+	list->tail = item;
+    } else {
+	if (before == nil) {
+	    b = list->tail;
+	} else {
+	    b = before;
+	}
+	item->next = b->next;
+	item->prev = b;
+	if (b->next != nil) {
+	    b->next->prev = item;
+	} else {
+	    list->tail = item;
+	}
+	b->next = item;
+    }
+}
+
+/*
+ * Delete an item from a list.
+ */
+
+public list_delete(item, list)
+ListItem item;
+List list;
+{
+    checkref(item);
+    checkref(list);
+    assert(list->nitems > 0);
+    if (item->next == nil) {
+	list->tail = item->prev;
+    } else {
+	item->next->prev = item->prev;
+    }
+    if (item->prev == nil) {
+	list->head = item->next;
+    } else {
+	item->prev->next = item->next;
+    }
+    list->nitems = list->nitems - 1;
+}
+
+/*
+ * Concatenate one list onto the end of another.
+ */
+
+public List list_concat(first, second)
+List first, second;
+{
+    List r;
+
+    if (first == nil) {
+	r = second;
+    } else if (second == nil) {
+	r = first;
+    } else {
+	second->head->prev = first->tail;
+	first->tail->next = second->head;
+	first->tail = second->tail;
+	first->nitems = first->nitems + second->nitems;
+	r = first;
+    }
+    return r;
+}
diff --git a/dbx/lists.h b/dbx/lists.h
new file mode 100644
index 0000000..35d94a4
--- /dev/null
+++ b/dbx/lists.h
@@ -0,0 +1,70 @@
+#ifndef lists_h
+#define lists_h
+
+typedef struct List *List;
+typedef struct ListItem *ListItem;
+typedef char *ListElement;
+
+#define list_item(element) generic_list_item((ListElement) (element))
+#define list_element(type, item) ((type) (item == nil ? nil : (item)->element))
+#define list_head(list) ((list == nil) ? nil : (list)->head)
+#define list_tail(list) ((list == nil) ? nil : (list)->tail)
+#define list_next(item) ((item == nil) ? nil : (item)->next)
+#define list_prev(item) ((item == nil) ? nil : (item)->prev)
+#define list_size(list) (((list) == nil) ? 0 : (list)->nitems)
+
+#define foreach(type, i, list) \
+{ \
+    register ListItem _item; \
+ \
+    _item = list_head(list); \
+    while (_item != nil) { \
+	i = list_element(type, _item); \
+	_item = list_next(_item);
+
+#define endfor \
+    } \
+}
+
+/*
+ * Iterate through two equal-sized lists.
+ */
+
+#define foreach2(type1, i, list1, type2, j, list2) \
+{ \
+    register ListItem _item1, _item2; \
+ \
+    _item1 = list_head(list1); \
+    _item2 = list_head(list2); \
+    while (_item1 != nil) { \
+	i = list_element(type1, _item1); \
+	j = list_element(type2, _item2); \
+	_item1 = list_next(_item1); \
+	_item2 = list_next(_item2);
+
+#define list_islast() (_item == nil)
+#define list_curitem(list) (_item == nil ? list_tail(list) : list_prev(_item))
+
+/*
+ * Representation should not be used outside except through macros.
+ */
+
+struct List {
+    Integer nitems;
+    ListItem head;
+    ListItem tail;
+};
+
+struct ListItem {
+    ListElement element;
+    ListItem next;
+    ListItem prev;
+};
+
+List list_alloc(/*  */);
+ListItem generic_list_item(/* element */);
+list_insert(/* item, after, list */);
+list_append(/* item, before, list */);
+list_delete(/* item, list */);
+List list_concat(/* first, second */);
+#endif
diff --git a/dbx/machine.c b/dbx/machine.c
new file mode 100644
index 0000000..0bdb157
--- /dev/null
+++ b/dbx/machine.c
@@ -0,0 +1,920 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)machine.c 1.9 8/5/83";
+
+/*
+ * Target machine dependent stuff.
+ */
+
+#include "defs.h"
+#include "machine.h"
+#include "process.h"
+#include "events.h"
+#include "main.h"
+#include "symbols.h"
+#include "source.h"
+#include "mappings.h"
+#include "object.h"
+#include "ops.h"
+#include <signal.h>
+
+#ifndef public
+typedef unsigned int Address;
+typedef unsigned char Byte;
+typedef unsigned int Word;
+
+#define NREG 16
+
+#define ARGP 12
+#define FRP 13
+#define STKP 14
+#define PROGCTR 15
+
+#define BITSPERBYTE 8
+#define BITSPERWORD (BITSPERBYTE * sizeof(Word))
+
+#define nargspassed(frame) argn(0, frame)
+
+#include "source.h"
+#include "symbols.h"
+
+Address pc;
+Address prtaddr;
+
+#endif
+
+private Address printop();
+
+/*
+ * Decode and print the instructions within the given address range.
+ */
+
+public printinst(lowaddr, highaddr)
+Address lowaddr;
+Address highaddr;
+{
+    register Address addr;
+
+    for (addr = lowaddr; addr <= highaddr; ) {
+	addr = printop(addr);
+    }
+    prtaddr = addr;
+}
+
+/*
+ * Another approach:  print n instructions starting at the given address.
+ */
+
+public printninst(count, addr)
+int count;
+Address addr;
+{
+    register Integer i;
+    register Address newaddr;
+
+    if (count <= 0) {
+	error("non-positive repetition count");
+    } else {
+	newaddr = addr;
+	for (i = 0; i < count; i++) {
+	    newaddr = printop(newaddr);
+	}
+	prtaddr = newaddr;
+    }
+}
+
+/*
+ * Hacked version of adb's VAX instruction decoder.
+ */
+
+private Address printop(addr)
+Address addr;
+{
+    Optab op;
+    VaxOpcode ins;
+    unsigned char mode;
+    int argtype, amode, argno, argval;
+    String reg;
+    Boolean indexf;
+    short offset;
+
+    argval = 0;
+    indexf = false;
+    printf("%08x  ", addr);
+    iread(&ins, addr, sizeof(ins));
+    addr += 1;
+    op = optab[ins];
+    printf("%s", op.iname);
+    for (argno = 0; argno < op.numargs; argno++) {
+	if (indexf == true) {
+	    indexf = false;
+	} else if (argno == 0) {
+	    printf("\t");
+	} else {
+	    printf(",");
+	}
+	argtype = op.argtype[argno];
+	if (is_branch_disp(argtype)) {
+	    mode = 0xAF + (typelen(argtype) << 5);
+	} else {
+	    iread(&mode, addr, sizeof(mode));
+	    addr += 1;
+	}
+	reg = regname[regnm(mode)];
+	amode = addrmode(mode);
+	switch (amode) {
+	    case LITSHORT:
+	    case LITUPTO31:
+	    case LITUPTO47:
+	    case LITUPTO63:
+		if (typelen(argtype) == TYPF || typelen(argtype) ==TYPD)
+		    printf("$%s", fltimm[mode]);
+		else
+		    printf("$%x", mode);
+		argval = mode;
+		break;
+
+	    case INDEX:
+		printf("[%s]", reg);
+		indexf = true;
+		argno--;
+		break;
+
+	    case REG:
+		printf("%s", reg);
+		break;
+
+	    case REGDEF:
+		printf("(%s)", reg);
+		break;
+
+	    case AUTODEC:
+		printf("-(%s)", reg);
+		break;
+
+	    case AUTOINC:
+		if (reg != regname[PROGCTR]) {
+		    printf("(%s)+", reg);
+		} else {
+		    printf("$");
+		    switch (typelen(argtype)) {
+			case TYPB:
+			    argval = printdisp(addr, 1, reg, amode);
+			    addr += 1;
+			    break;
+
+			case TYPW:
+			    argval = printdisp(addr, 2, reg, amode);
+			    addr += 2;
+			    break;
+
+			case TYPL:
+			    argval = printdisp(addr, 4, reg, amode);
+			    addr += 4;
+			    break;
+
+			case TYPF:
+			    iread(&argval, addr, sizeof(argval));
+			    printf("%06x", argval);
+			    addr += 4;
+			    break;
+
+			case TYPQ:
+			case TYPD:
+			    iread(&argval, addr, sizeof(argval));
+			    printf("%06x", argval);
+			    iread(&argval, addr+4, sizeof(argval));
+			    printf("%06x", argval);
+			    addr += 8;
+			    break;
+		    }
+		}
+		break;
+
+	    case AUTOINCDEF:
+		if (reg == regname[PROGCTR]) {
+		    printf("*$");
+		    argval = printdisp(addr, 4, reg, amode);
+		    addr += 4;
+		} else {
+		    printf("*(%s)+", reg);
+		}
+		break;
+
+	    case BYTEDISP:
+		argval = printdisp(addr, 1, reg, amode);
+		addr += 1;
+		break;
+
+	    case BYTEDISPDEF:
+		printf("*");
+		argval = printdisp(addr, 1, reg, amode);
+		addr += 1;
+		break;
+
+	    case WORDDISP:
+		argval = printdisp(addr, 2, reg, amode);
+		addr += 2;
+		break;
+
+	    case WORDDISPDEF:
+		printf("*");
+		argval = printdisp(addr, 2, reg, amode);
+		addr += 2;
+		break;
+
+	    case LONGDISP:
+		argval = printdisp(addr, 4, reg, amode);
+		addr += 4;
+		break;
+
+	    case LONGDISPDEF:
+		printf("*");
+		argval = printdisp(addr, 4, reg, amode);
+		addr += 4;
+		break;
+	}
+    }
+    if (ins == O_CASEB || ins == O_CASEW || ins == O_CASEL) {
+	for (argno = 0; argno <= argval; argno++) {
+	    iread(&offset, addr, sizeof(offset));
+	    printf("\n\t\t%d", offset);
+	    addr += 2;
+	}
+    }
+    printf("\n");
+    return addr;
+}
+
+/*
+ * Print the displacement of an instruction that uses displacement
+ * addressing.
+ */
+
+private int printdisp(addr, nbytes, reg, mode)
+Address addr;
+int nbytes;
+char *reg;
+int mode;
+{
+    char byte;
+    short hword;
+    int argval;
+    Symbol f;
+
+    switch (nbytes) {
+	case 1:
+	    iread(&byte, addr, sizeof(byte));
+	    argval = byte;
+	    break;
+
+	case 2:
+	    iread(&hword, addr, sizeof(hword));
+	    argval = hword;
+	    break;
+
+	case 4:
+	    iread(&argval, addr, sizeof(argval));
+	    break;
+    }
+    if (reg == regname[PROGCTR] && mode >= BYTEDISP) {
+	argval += addr + nbytes;
+    }
+    if (reg == regname[PROGCTR]) {
+	f = whatblock((Address) argval + 2);
+	if (codeloc(f) == argval + 2) {
+	    printf("%s", symname(f));
+	} else {
+	    printf("%x", argval);
+	}
+    } else {
+	printf("%d(%s)", argval, reg);
+    }
+    return argval;
+}
+
+/*
+ * Print the contents of the addresses within the given range
+ * according to the given format.
+ */
+
+typedef struct {
+    String name;
+    String printfstring;
+    int length;
+} Format;
+
+private Format fmt[] = {
+    { "d", " %d", sizeof(short) },
+    { "D", " %ld", sizeof(long) },
+    { "o", " %o", sizeof(short) },
+    { "O", " %lo", sizeof(long) },
+    { "x", " %04x", sizeof(short) },
+    { "X", " %08x", sizeof(long) },
+    { "b", " \\%o", sizeof(char) },
+    { "c", " '%c'", sizeof(char) },
+    { "s", "%c", sizeof(char) },
+    { "f", " %f", sizeof(float) },
+    { "g", " %g", sizeof(double) },
+    { nil, nil, 0 }
+};
+
+private Format *findformat(s)
+String s;
+{
+    register Format *f;
+
+    f = &fmt[0];
+    while (f->name != nil and not streq(f->name, s)) {
+	++f;
+    }
+    if (f->name == nil) {
+	error("bad print format \"%s\"", s);
+    }
+    return f;
+}
+
+public Address printdata(lowaddr, highaddr, format)
+Address lowaddr;
+Address highaddr;
+String format;
+{
+    register int n;
+    register Address addr;
+    register Format *f;
+    int value;
+
+    if (lowaddr > highaddr) {
+	error("first address larger than second");
+    }
+    f = findformat(format);
+    n = 0;
+    value = 0;
+    for (addr = lowaddr; addr <= highaddr; addr += f->length) {
+	if (n == 0) {
+	    printf("%08x: ", addr);
+	}
+	dread(&value, addr, f->length);
+	printf(f->printfstring, value);
+	++n;
+	if (n >= (16 div f->length)) {
+	    putchar('\n');
+	    n = 0;
+	}
+    }
+    if (n != 0) {
+	putchar('\n');
+    }
+    prtaddr = addr;
+    return addr;
+}
+
+/*
+ * The other approach is to print n items starting with a given address.
+ */
+
+public printndata(count, startaddr, format)
+int count;
+Address startaddr;
+String format;
+{
+    register int i, n;
+    register Address addr;
+    register Format *f;
+    register Boolean isstring;
+    char c;
+    union {
+	char charv;
+	short shortv;
+	int intv;
+	float floatv;
+	double doublev;
+    } value;
+
+    if (count <= 0) {
+	error("non-positive repetition count");
+    }
+    f = findformat(format);
+    isstring = (Boolean) streq(f->name, "s");
+    n = 0;
+    addr = startaddr;
+    value.intv = 0;
+    for (i = 0; i < count; i++) {
+	if (n == 0) {
+	    printf("%08x: ", addr);
+	}
+	if (isstring) {
+	    putchar('"');
+	    dread(&c, addr, sizeof(char));
+	    while (c != '\0') {
+		printchar(c);
+		++addr;
+		dread(&c, addr, sizeof(char));
+	    }
+	    putchar('"');
+	    putchar('\n');
+	    n = 0;
+	    addr += sizeof(String);
+	} else {
+	    dread(&value, addr, f->length);
+	    printf(f->printfstring, value);
+	    ++n;
+	    if (n >= (16 div f->length)) {
+		putchar('\n');
+		n = 0;
+	    }
+	    addr += f->length;
+	}
+    }
+    if (n != 0) {
+	putchar('\n');
+    }
+    prtaddr = addr;
+}
+
+/*
+ * Print out a value according to the given format.
+ */
+
+public printvalue(v, format)
+long v;
+String format;
+{
+    Format *f;
+    char *p, *q;
+
+    f = findformat(format);
+    if (streq(f->name, "s")) {
+	putchar('"');
+	p = (char *) &v;
+	q = p + sizeof(v);
+	while (p < q) {
+	    printchar(*p);
+	    ++p;
+	}
+	putchar('"');
+    } else {
+	printf(f->printfstring, v);
+    }
+    putchar('\n');
+}
+
+/*
+ * Print out an execution time error.
+ * Assumes the source position of the error has been calculated.
+ *
+ * Have to check if the -r option was specified; if so then
+ * the object file information hasn't been read in yet.
+ */
+
+public printerror()
+{
+    extern Integer sys_nsig;
+    extern String sys_siglist[];
+    Integer err;
+
+    if (isfinished(process)) {
+	printf("\"%s\" exits with code %d\n", objname, exitcode(process));
+	erecover();
+    }
+    if (runfirst) {
+	fprintf(stderr, "Entering debugger ...");
+	init();
+	fprintf(stderr, " type 'help' for help\n");
+    }
+    err = errnum(process);
+    if (err == SIGINT) {
+	printf("\n\ninterrupt ");
+	printloc();
+    } else if (err == SIGTRAP) {
+	printf("\nerror ");
+	printloc();
+    } else {
+	if (err < 0 or err > sys_nsig) {
+	    printf("\nsignal %d ", err);
+	} else {
+	    printf("\n%s ", sys_siglist[err]);
+	}
+	printloc();
+    }
+    putchar('\n');
+    if (curline > 0) {
+	printlines(curline, curline);
+    } else {
+	printinst(pc, pc);
+    }
+    erecover();
+}
+
+/*
+ * Note the termination of the program.  We do this so as to avoid
+ * having the process exit, which would make the values of variables
+ * inaccessible.  We do want to flush all output buffers here,
+ * otherwise it'll never get done.
+ */
+
+public endprogram()
+{
+    Integer exitcode;
+
+    stepto(nextaddr(pc, true));
+    printnews();
+    exitcode = argn(1, nil);
+    printf("\nexecution completed, exit code is %d\n", exitcode);
+    getsrcpos();
+    erecover();
+}
+
+/*
+ * Single step the machine a source line (or instruction if "inst_tracing"
+ * is true).  If "isnext" is true, skip over procedure calls.
+ */
+
+private Address getcall();
+
+public dostep(isnext)
+Boolean isnext;
+{
+    register Address addr;
+    register Lineno line;
+    String filename;
+
+    addr = nextaddr(pc, isnext);
+    if (not inst_tracing and nlhdr.nlines != 0) {
+	line = linelookup(addr);
+	while (line == 0) {
+	    addr = nextaddr(addr, isnext);
+	    line = linelookup(addr);
+	}
+	curline = line;
+    } else {
+	curline = 0;
+    }
+    stepto(addr);
+    filename = srcfilename(addr);
+    setsource(filename);
+}
+
+/*
+ * Compute the next address that will be executed from the given one.
+ * If "isnext" is true then consider a procedure call as straight line code.
+ *
+ * We must unfortunately do much of the same work that is necessary
+ * to print instructions.  In addition we have to deal with branches.
+ * Unconditional branches we just follow, for conditional branches
+ * we continue execution to the current location and then single step
+ * the machine.  We assume that the last argument in an instruction
+ * that branches is the branch address (or relative offset).
+ */
+
+public Address nextaddr(startaddr, isnext)
+Address startaddr;
+Boolean isnext;
+{
+    register Address addr;
+    Optab op;
+    VaxOpcode ins;
+    unsigned char mode;
+    int argtype, amode, argno, argval;
+    String r;
+    Boolean indexf;
+    enum { KNOWN, SEQUENTIAL, BRANCH } addrstatus;
+
+    argval = 0;
+    indexf = false;
+    addr = startaddr;
+    iread(&ins, addr, sizeof(ins));
+    switch (ins) {
+	case O_BRB:
+	case O_BRW:
+	case O_JMP:
+	    addrstatus = BRANCH;
+	    break;
+	    
+	case O_BSBB:
+	case O_BSBW:
+	case O_JSB:
+	case O_CALLG:
+	case O_CALLS:
+	    if (isnext) {
+		addrstatus = SEQUENTIAL;
+	    } else {
+		addrstatus = KNOWN;
+		stepto(addr);
+		pstep(process);
+		addr = reg(PROGCTR);
+		pc = addr;
+		curfunc = whatblock(pc);
+		if (not isbperr()) {
+		    printstatus();
+		    /* NOTREACHED */
+		}
+		bpact();
+		if (nosource(curfunc) and canskip(curfunc) and
+		  nlhdr.nlines != 0) {
+		    addrstatus = KNOWN;
+		    addr = return_addr();
+		    stepto(addr);
+		    bpact();
+		} else {
+		    callnews(/* iscall = */ true);
+		}
+	    }
+	    break;
+
+	case O_RSB:
+	case O_RET:
+	    addrstatus = KNOWN;
+	    callnews(/* iscall = */ false);
+	    addr = return_addr();
+	    stepto(addr);
+	    bpact();
+	    break;
+
+	case O_BNEQ: case O_BEQL: case O_BGTR:
+	case O_BLEQ: case O_BGEQ: case O_BLSS:
+	case O_BGTRU: case O_BLEQU: case O_BVC:
+	case O_BVS: case O_BCC: case O_BCS:
+	case O_CASEB: case O_CASEW: case O_CASEL:
+	case O_BBS: case O_BBC: case O_BBSS: case O_BBCS:
+	case O_BBSC: case O_BBCC: case O_BBSSI:
+	case O_BBCCI: case O_BLBS: case O_BLBC:
+	case O_ACBL: case O_AOBLSS: case O_AOBLEQ:
+	case O_SOBGEQ: case O_SOBGTR:
+	    addrstatus = KNOWN;
+	    stepto(addr);
+	    pstep(process);
+	    addr = reg(PROGCTR);
+	    pc = addr;
+	    if (not isbperr()) {
+		printstatus();
+	    }
+	    break;
+
+	default:
+	    addrstatus = SEQUENTIAL;
+	    break;
+    }
+    if (addrstatus != KNOWN) {
+	addr += 1;
+	op = optab[ins];
+	for (argno = 0; argno < op.numargs; argno++) {
+	    if (indexf == true) {
+		indexf = false;
+	    }
+	    argtype = op.argtype[argno];
+	    if (is_branch_disp(argtype)) {
+		mode = 0xAF + (typelen(argtype) << 5);
+	    } else {
+		iread(&mode, addr, sizeof(mode));
+		addr += 1;
+	    }
+	    r = regname[regnm(mode)];
+	    amode = addrmode(mode);
+	    switch (amode) {
+		case LITSHORT:
+		case LITUPTO31:
+		case LITUPTO47:
+		case LITUPTO63:
+		    argval = mode;
+		    break;
+
+		case INDEX:
+		    indexf = true;
+		    --argno;
+		    break;
+
+		case REG:
+		case REGDEF:
+		case AUTODEC:
+		    break;
+
+		case AUTOINC:
+		    if (r == regname[PROGCTR]) {
+			switch (typelen(argtype)) {
+			    case TYPB:
+				argval = getdisp(addr, 1, r, amode);
+				addr += 1;
+				break;
+
+			    case TYPW:
+				argval = getdisp(addr, 2, r, amode);
+				addr += 2;
+				break;
+
+			    case TYPL:
+				argval = getdisp(addr, 4, r, amode);
+				addr += 4;
+				break;
+
+			    case TYPF:
+				iread(&argval, addr, sizeof(argval));
+				addr += 4;
+				break;
+
+			    case TYPQ:
+			    case TYPD:
+				iread(&argval, addr+4, sizeof(argval));
+				addr += 8;
+				break;
+			}
+		    }
+		    break;
+
+		case AUTOINCDEF:
+		    if (r == regname[PROGCTR]) {
+			argval = getdisp(addr, 4, r, amode);
+			addr += 4;
+		    }
+		    break;
+
+		case BYTEDISP:
+		case BYTEDISPDEF:
+		    argval = getdisp(addr, 1, r, amode);
+		    addr += 1;
+		    break;
+
+		case WORDDISP:
+		case WORDDISPDEF:
+		    argval = getdisp(addr, 2, r, amode);
+		    addr += 2;
+		    break;
+
+		case LONGDISP:
+		case LONGDISPDEF:
+		    argval = getdisp(addr, 4, r, amode);
+		    addr += 4;
+		    break;
+	    }
+	}
+	if (ins == O_CALLS or ins == O_CALLG) {
+	    argval += 2;
+	}
+	if (addrstatus == BRANCH) {
+	    addr = argval;
+	}
+    }
+    return addr;
+}
+
+/*
+ * Get the displacement of an instruction that uses displacement addressing.
+ */
+
+private int getdisp(addr, nbytes, reg, mode)
+Address addr;
+int nbytes;
+String reg;
+int mode;
+{
+    char byte;
+    short hword;
+    int argval;
+
+    switch (nbytes) {
+	case 1:
+	    iread(&byte, addr, sizeof(byte));
+	    argval = byte;
+	    break;
+
+	case 2:
+	    iread(&hword, addr, sizeof(hword));
+	    argval = hword;
+	    break;
+
+	case 4:
+	    iread(&argval, addr, sizeof(argval));
+	    break;
+    }
+    if (reg == regname[PROGCTR] && mode >= BYTEDISP) {
+	argval += addr + nbytes;
+    }
+    return argval;
+}
+
+#define BP_OP       O_BPT       /* breakpoint trap */
+#define BP_ERRNO    SIGTRAP     /* signal received at a breakpoint */
+
+/*
+ * Setting a breakpoint at a location consists of saving
+ * the word at the location and poking a BP_OP there.
+ *
+ * We save the locations and words on a list for use in unsetting.
+ */
+
+typedef struct Savelist *Savelist;
+
+struct Savelist {
+    Address location;
+    Byte save;
+    Byte refcount;
+    Savelist link;
+};
+
+private Savelist savelist;
+
+/*
+ * Set a breakpoint at the given address.  Only save the word there
+ * if it's not already a breakpoint.
+ */
+
+public setbp(addr)
+Address addr;
+{
+    Byte w;
+    Byte save;
+    register Savelist newsave, s;
+
+    for (s = savelist; s != nil; s = s->link) {
+	if (s->location == addr) {
+	    s->refcount++;
+	    return;
+	}
+    }
+    iread(&save, addr, sizeof(save));
+    newsave = new(Savelist);
+    newsave->location = addr;
+    newsave->save = save;
+    newsave->refcount = 1;
+    newsave->link = savelist;
+    savelist = newsave;
+    w = BP_OP;
+    iwrite(&w, addr, sizeof(w));
+}
+
+/*
+ * Unset a breakpoint; unfortunately we have to search the SAVELIST
+ * to find the saved value.  The assumption is that the SAVELIST will
+ * usually be quite small.
+ */
+
+public unsetbp(addr)
+Address addr;
+{
+    register Savelist s, prev;
+
+    prev = nil;
+    for (s = savelist; s != nil; s = s->link) {
+	if (s->location == addr) {
+	    iwrite(&s->save, addr, sizeof(s->save));
+	    s->refcount--;
+	    if (s->refcount == 0) {
+		if (prev == nil) {
+		    savelist = s->link;
+		} else {
+		    prev->link = s->link;
+		}
+		dispose(s);
+	    }
+	    return;
+	}
+	prev = s;
+    }
+    panic("unsetbp: couldn't find address %d", addr);
+}
+
+/*
+ * Predicate to test if the reason the process stopped was because
+ * of a breakpoint.
+ */
+
+public Boolean isbperr()
+{
+    return (Boolean) (not isfinished(process) and errnum(process) == SIGTRAP);
+}
+
+/*
+ * Enter a procedure by creating and executing a call instruction.
+ */
+
+#define CALLSIZE 7	/* size of call instruction */
+
+public beginproc(p, argc)
+Symbol p;
+Integer argc;
+{
+    char save[CALLSIZE];
+    struct {
+	VaxOpcode op;
+	unsigned char numargs;
+	unsigned char mode;
+	char addr[sizeof(long)];	/* unaligned long */
+    } call;
+    long dest;
+
+    pc = 2;
+    iread(save, pc, sizeof(save));
+    call.op = O_CALLS;
+    call.numargs = argc;
+    call.mode = 0xef;
+    dest = codeloc(p) - 2 - (pc + 7);
+    mov(&dest, call.addr, sizeof(call.addr));
+    iwrite(&call, pc, sizeof(call));
+    setreg(PROGCTR, pc);
+    pstep(process);
+    iwrite(save, pc, sizeof(save));
+    pc = reg(PROGCTR);
+    if (not isbperr()) {
+	printstatus();
+    }
+}
diff --git a/dbx/machine.h b/dbx/machine.h
new file mode 100644
index 0000000..9a9cd18
--- /dev/null
+++ b/dbx/machine.h
@@ -0,0 +1,38 @@
+#ifndef machine_h
+#define machine_h
+typedef unsigned int Address;
+typedef unsigned char Byte;
+typedef unsigned int Word;
+
+#define NREG 16
+
+#define ARGP 12
+#define FRP 13
+#define STKP 14
+#define PROGCTR 15
+
+#define BITSPERBYTE 8
+#define BITSPERWORD (BITSPERBYTE * sizeof(Word))
+
+#define nargspassed(frame) argn(0, frame)
+
+#include "source.h"
+#include "symbols.h"
+
+Address pc;
+Address prtaddr;
+
+printinst(/* lowaddr, highaddr */);
+printninst(/* count, addr */);
+Address printdata(/* lowaddr, highaddr, format */);
+printndata(/* count, startaddr, format */);
+printvalue(/* v, format */);
+printerror(/*  */);
+endprogram(/*  */);
+dostep(/* isnext */);
+Address nextaddr(/* startaddr, isnext */);
+setbp(/* addr */);
+unsetbp(/* addr */);
+Boolean isbperr(/*  */);
+beginproc(/* p, argc */);
+#endif
diff --git a/dbx/main.c b/dbx/main.c
new file mode 100644
index 0000000..d52c94a
--- /dev/null
+++ b/dbx/main.c
@@ -0,0 +1,392 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)main.c 1.6 8/16/83";
+
+/*
+ * Debugger main routine.
+ */
+
+#include "defs.h"
+#include <setjmp.h>
+#include <signal.h>
+#include <errno.h>
+#include <fcntl.h>
+#include "main.h"
+#include "symbols.h"
+#include "scanner.h"
+#include "process.h"
+#include "source.h"
+#include "object.h"
+#include "mappings.h"
+
+#ifndef public
+
+#define isterm(file)	(interactive or isatty(fileno(file)))
+
+#include <sgtty.h>
+
+typedef struct {
+    struct sgttyb sgttyb;
+    struct tchars tchars;
+    int lmode;
+    struct ltchars ltchars;
+    int fcntl_flags;
+    int fcntl_owner;
+  } Ttyinfo;
+
+#endif
+
+public Boolean coredump;		/* true if using a core dump */
+public Boolean runfirst;		/* run program immediately */
+public Boolean interactive;		/* standard input IS a terminal */
+public Boolean lexdebug;		/* trace yylex return values */
+public Boolean tracebpts;		/* trace create/delete breakpoints */
+public Boolean traceexec;		/* trace process execution */
+public Boolean tracesyms;		/* print symbols as their read */
+
+public File corefile;			/* File id of core dump */
+
+#define FIRST_TIME 0			/* initial value setjmp returns */
+
+private Boolean initdone = false;	/* true if initialization done */
+private jmp_buf env;			/* setjmp/longjmp data */
+private char outbuf[BUFSIZ];		/* standard output buffer */
+private char namebuf[512];		/* possible name of object file */
+private int firstarg;			/* first program argument (for -r) */
+
+private Ttyinfo ttyinfo;
+
+private catchintr();
+
+/*
+ * Main program.
+ */
+
+main(argc, argv)
+int argc;
+String argv[];
+{
+    register Integer i;
+    extern String date;
+
+    cmdname = argv[0];
+    catcherrs();
+    onsyserr(EINTR, nil);
+    setbuf(stdout, outbuf);
+    printf("dbx version of %s.\nType 'help' for help.\n", date);
+    fflush(stdout);
+    scanargs(argc, argv);
+    language_init();
+    symbols_init();
+    process_init();
+    if (runfirst) {
+	if (setjmp(env) == FIRST_TIME) {
+	    arginit();
+	    for (i = firstarg; i < argc; i++) {
+		newarg(argv[i]);
+	    }
+	    run();
+	    /* NOTREACHED */
+	} else {
+	    runfirst = false;
+	}
+    } else {
+	init();
+    }
+    setjmp(env);
+    restoretty(stdout, &ttyinfo);
+    signal(SIGINT, catchintr);
+    yyparse();
+    putchar('\n');
+    quit(0);
+}
+
+/*
+ * Initialize the world, including setting initial input file
+ * if the file exists.
+ */
+
+public init()
+{
+    File f;
+    String home;
+    char buf[100];
+    extern String getenv();
+
+    savetty(stdout, &ttyinfo);
+    enterkeywords();
+    scanner_init();
+    if (not coredump and not runfirst) {
+	start(nil, nil, nil);
+    }
+    printf("reading symbolic information ...");
+    fflush(stdout);
+    readobj(objname);
+    printf("\n");
+    fflush(stdout);
+    if (coredump) {
+	curfunc = whatblock(pc);
+    } else {
+	curfunc = program;
+    }
+    bpinit();
+    f = fopen(initfile, "r");
+    if (f != nil) {
+	fclose(f);
+	setinput(initfile);
+    } else {
+	home = getenv("HOME");
+	if (home != nil) {
+	    sprintf(buf, "%s/%s", home, initfile);
+	    f = fopen(buf, "r");
+	    if (f != nil) {
+		fclose(f);
+		setinput(strdup(buf));
+	    }
+	}
+    }
+    initdone = true;
+}
+
+/*
+ * Re-initialize the world, first de-allocating all storage.
+ * This is necessary when the symbol information must be re-read
+ * from the object file when it has changed.
+ *
+ * Before "forgetting" things, we save the current tracing/breakpoint
+ * information to a temp file.  Then after re-creating the world,
+ * we read the temp file as commands.  This isn't always the right thing;
+ * if a procedure that was being traced is deleted, an error message
+ * will be generated.
+ *
+ * If the argument vector is not nil, then this is re-initialize is being
+ * done in preparation for running the program.  Since we want to process
+ * the commands in the temp file before running the program, we add the
+ * run command at the end of the temp file.  In this case, reinit longjmps
+ * back to parsing rather than returning.
+ */
+
+public reinit(argv, infile, outfile)
+String *argv;
+String infile;
+String outfile;
+{
+    register Integer i;
+    String tmpfile;
+    extern String mktemp();
+
+    tmpfile = mktemp("/tmp/dbxXXXX");
+    setout(tmpfile);
+    status();
+    print_alias(nil);
+    if (argv != nil) {
+	printf("run");
+	for (i = 1; argv[i] != nil; i++) {
+	    printf(" %s", argv[i]);
+	}
+	if (infile != nil) {
+	    printf(" < %s", infile);
+	}
+	if (outfile != nil) {
+	    printf(" > %s", outfile);
+	}
+	putchar('\n');
+    }
+    unsetout();
+    bpfree();
+    objfree();
+    process_init();
+    enterkeywords();
+    scanner_init();
+    readobj(objname);
+    bpinit();
+    fflush(stdout);
+    setinput(tmpfile);
+    unlink(tmpfile);
+    if (argv != nil) {
+	longjmp(env, 1);
+	/* NOTREACHED */
+    }
+}
+
+/*
+ * After a non-fatal error we jump back to command parsing.
+ */
+
+public erecover()
+{
+    if (initdone) {
+	gobble();
+	longjmp(env, 1);
+    }
+}
+
+/*
+ * This routine is called when an interrupt occurs.
+ */
+
+private catchintr()
+{
+    putchar('\n');
+    longjmp(env, 1);
+}
+
+/*
+ * Scan the argument list.
+ */
+
+private scanargs(argc, argv)
+int argc;
+String argv[];
+{
+    register int i, j;
+    register Boolean foundfile;
+    register File f;
+    char *tmp;
+
+    runfirst = false;
+    interactive = false;
+    lexdebug = false;
+    tracebpts = false;
+    traceexec = false;
+    tracesyms = false;
+    foundfile = false;
+    corefile = nil;
+    coredump = true;
+    sourcepath = list_alloc();
+    list_append(list_item("."), nil, sourcepath);
+    i = 1;
+    while (i < argc and (not foundfile or (corefile == nil and not runfirst))) {
+	if (argv[i][0] == '-') {
+	    if (streq(argv[i], "-I")) {
+		++i;
+		if (i >= argc) {
+		    fatal("missing directory for -I");
+		}
+		list_append(list_item(argv[i]), nil, sourcepath);
+	    } else {
+		for (j = 1; argv[i][j] != '\0'; j++) {
+		    setoption(argv[i][j]);
+		}
+	    }
+	} else if (not foundfile) {
+	    objname = argv[i];
+	    foundfile = true;
+	} else if (coredump and corefile == nil) {
+	    corefile = fopen(argv[i], "r");
+	    if (corefile == nil) {
+		coredump = false;
+	    }
+	}
+	++i;
+    }
+    if (i < argc and not runfirst) {
+	fatal("extraneous argument %s", argv[i]);
+    }
+    firstarg = i;
+    if (not foundfile and isatty(0)) {
+	printf("enter object file name (default is `%s'): ", objname);
+	fflush(stdout);
+	gets(namebuf);
+	if (namebuf[0] != '\0') {
+	    objname = namebuf;
+	}
+    }
+    f = fopen(objname, "r");
+    if (f == nil) {
+	fatal("can't read %s", objname);
+    } else {
+	fclose(f);
+    }
+    if (rindex(objname, '/') != nil) {
+	tmp = strdup(objname);
+	*(rindex(tmp, '/')) = '\0';
+	list_append(list_item(tmp), nil, sourcepath);
+    }
+    if (coredump and corefile == nil) {
+	corefile = fopen("core", "r");
+	if (corefile == nil) {
+	    coredump = false;
+	}
+    }
+}
+
+/*
+ * Take appropriate action for recognized command argument.
+ */
+
+private setoption(c)
+char c;
+{
+    switch (c) {
+	case 'r':   /* run program before accepting commands */
+	    runfirst = true;
+	    coredump = false;
+	    break;
+
+	case 'i':
+	    interactive = true;
+	    break;
+
+	case 'b':
+	    tracebpts = true;
+	    break;
+
+	case 'e':
+	    traceexec = true;
+	    break;
+
+	case 's':
+	    tracesyms = true;
+	    break;
+
+	case 'l':
+#   	    ifdef LEXDEBUG
+		lexdebug = true;
+#	    else
+		fatal("\"-l\" only applicable when compiled with LEXDEBUG");
+#	    endif
+	    break;
+
+	default:
+	    fatal("unknown option '%c'", c);
+    }
+}
+
+/*
+ * Save/restore the state of a tty.
+ */
+
+public savetty(f, t)
+File f;
+Ttyinfo *t;
+{
+    gtty(fileno(f), &t->sgttyb);
+    ioctl(fileno(f), TIOCGETC, &t->tchars);
+    ioctl(fileno(f), TIOCLGET, &t->lmode);
+    ioctl(fileno(f), TIOCGLTC, &t->ltchars);
+    t->fcntl_flags = fcntl(fileno(f), F_GETFL);
+    t->fcntl_owner = fcntl(fileno(f), F_GETOWN);
+}
+
+public restoretty(f, t)
+File f;
+Ttyinfo *t;
+{
+    ioctl(fileno(f), TIOCSETN, &t->sgttyb);	/* instead of stty --saj */
+    ioctl(fileno(f), TIOCSETC, &t->tchars);
+    ioctl(fileno(f), TIOCLSET, &t->lmode);
+    ioctl(fileno(f), TIOCSLTC, &t->ltchars);
+    fcntl(fileno(f), F_SETFL, t->fcntl_flags);
+    fcntl(fileno(f), F_SETOWN, t->fcntl_owner);
+}
+
+/*
+ * Exit gracefully.
+ */
+
+public quit(r)
+Integer r;
+{
+    exit(r);
+}
diff --git a/dbx/main.h b/dbx/main.h
new file mode 100644
index 0000000..7cc22d7
--- /dev/null
+++ b/dbx/main.h
@@ -0,0 +1,31 @@
+#ifndef main_h
+#define main_h
+
+#define isterm(file)	(interactive or isatty(fileno(file)))
+
+#include <sgtty.h>
+
+typedef struct {
+    struct sgttyb sgttyb;
+    struct tchars tchars;
+    int lmode;
+    struct ltchars ltchars;
+    int fcntl_flags;
+    int fcntl_owner;
+  } Ttyinfo;
+
+Boolean coredump;		/* true if using a core dump */
+Boolean runfirst;		/* run program immediately */
+Boolean interactive;		/* standard input IS a terminal */
+Boolean lexdebug;		/* trace yylex return values */
+Boolean tracebpts;		/* trace create/delete breakpoints */
+Boolean traceexec;		/* trace process execution */
+Boolean tracesyms;		/* print symbols as their read */
+File corefile;			/* File id of core dump */
+init(/*  */);
+reinit(/* argv, infile, outfile */);
+erecover(/*  */);
+savetty(/* f, t */);
+restoretty(/* f, t */);
+quit(/* r */);
+#endif
diff --git a/dbx/makedefs b/dbx/makedefs
new file mode 100755
index 0000000..8fd5f26
Binary files /dev/null and b/dbx/makedefs differ
diff --git a/dbx/makedefs.c b/dbx/makedefs.c
new file mode 100644
index 0000000..e94d559
--- /dev/null
+++ b/dbx/makedefs.c
@@ -0,0 +1,173 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)makedefs.c 1.2 12/15/82";
+
+/*
+ * Create a definitions file (e.g. .h) from an implementation file (e.g. .c).
+ *
+ * Usage is "makedefs source.c source.h" where source.h is to be created.
+ *
+ * Lines beginning with "public" or within a "#ifndef public ... #endif"
+ * block are copied to the new file.  Initializations (e.g. "int x = 3") are
+ * omitted ("int x;" is output).
+ *
+ * Normally a temporary definitions file is created and compared to
+ * the given destination.  If they are different, the temporary file
+ * is copied on top of the destination.  This is so that dependencies
+ * when using "make" are not triggered.
+ *
+ * The "-f" option overrides this and forces the destination file to be created.
+ */
+
+#include "defs.h"
+#include <signal.h>
+
+#define procedure void
+
+Boolean force;
+Boolean copytext;
+
+String tmpname;
+String modulename();
+procedure abnorm();
+
+main(argc, argv)
+int argc;
+String argv[];
+{
+    extern String mktemp();
+    String name;
+    File tmp;
+    Integer r;
+    Integer index;
+
+    if (streq(argv[1], "-f")) {
+	force = true;
+	index = 2;
+    } else {
+	force = false;
+	index = 1;
+    }
+    if (argc - index > 2) {
+	fatal("usage: makedefs [ -f ] file.c [ file.h ]\n");
+    }
+    tmp = nil;
+    if (freopen(argv[index], "r", stdin) == NULL) {
+	fatal("can't read %s", argv[index]);
+    }
+    signal(SIGINT, abnorm);
+    signal(SIGQUIT, abnorm);
+    if (index + 1 < argc) {
+	if (force) {
+	    tmpname = argv[index + 1];
+	} else {
+	    tmpname = mktemp("/tmp/makedefsXXXXXX");
+	}
+	tmp = freopen(tmpname, "w", stdout);
+	if (tmp == nil) {
+	    fatal("can't write %s", tmpname);
+	}
+    }
+    copytext = false;
+    name = modulename(argv[index]);
+    printf("#ifndef %s\n", name);
+    printf("#define %s\n", name);
+    copy();
+    printf("#endif\n");
+    if (tmp != NULL and not force) {
+	fclose(tmp);
+	r = call("cmp", stdin, stderr, "-s", tmpname, argv[2], nil);
+	if (r != 0) {
+	    r = call("cp", stdin, stderr, tmpname, argv[2], nil);
+	    if (r != 0) {
+		fprintf(stderr, "can't create %s\n", argv[2]);
+	    }
+	}
+	unlink(tmpname);
+    }
+    quit(0);
+}
+
+String modulename(s)
+String s;
+{
+    String r, i, j;
+    static char buf[256];
+
+    strcpy(buf, s);
+    i = rindex(buf, '/');
+    if (i == nil) {
+	i = buf;
+    }
+    for (j = i; *j != '.'; j++);
+    *j++ = '_';
+    *j++ = 'h';
+    *j = '\0';
+    return buf;
+}
+
+copy()
+{
+    register char *p;
+    char line[1024];
+
+    while (gets(line) != NULL) {
+	if (strncmp(line, "#ifndef public", 14) == 0) {
+	    copytext = true;
+	} else if (strncmp(line, "#endif", 6) == 0) {
+	    copytext = false;
+	} else if (strncmp(line, "public", 6) == 0) {
+	    copydef(line);
+	} else if (copytext) {
+	    printf("%s\n", line);
+	}
+    }
+}
+
+copydef(s)
+String s;
+{
+    register char *p;
+    register Boolean isproc;
+
+    isproc = false;
+    for (p = &s[7]; *p != '\0' and *p != '='; p++) {
+	if (*p == '(') {
+	    isproc = true;
+	    printf("(/* ");
+	} else if (*p == ')' and isproc and *(p+1) == '\0') {
+	    printf(" */)");
+	} else {
+	    putchar(*p);
+	}
+    }
+    if (isproc or *p == '=') {
+	putchar(';');
+    }
+    putchar('\n');
+}
+
+/*
+ * Terminate program.
+ */
+
+procedure abnorm(signo)
+int signo;
+{
+    unlink(tmpname);
+    quit(signo);
+}
+
+quit(r)
+int r;
+{
+    exit(r);
+}
+
+/*
+ * No special error recovery strategy.
+ */
+
+erecover()
+{
+}
diff --git a/dbx/mappings.c b/dbx/mappings.c
new file mode 100644
index 0000000..491ab8c
--- /dev/null
+++ b/dbx/mappings.c
@@ -0,0 +1,304 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)mappings.c 1.4 8/10/83";
+
+/*
+ * Source-to-object and vice versa mappings.
+ */
+
+#include "defs.h"
+#include "mappings.h"
+#include "symbols.h"
+#include "source.h"
+#include "object.h"
+#include "machine.h"
+
+#ifndef public
+#include "machine.h"
+#include "source.h"
+#include "symbols.h"
+
+typedef struct {
+    Address addr;
+    String filename;
+    Lineno lineindex;		/* index to first linetab entry */
+} Filetab;
+
+typedef struct {
+    Lineno line;
+    Address addr;
+} Linetab;
+
+Filetab *filetab;
+Linetab *linetab;
+
+#define NOADDR ((Address) -1)	/* no address for line or procedure */
+
+#endif
+
+/*
+ * Get the source file name associated with a given address.
+ */
+
+public String srcfilename(addr)
+Address addr;
+{
+    register Address i, j, k;
+    Address a;
+    Filetab *ftp;
+    String s;
+
+    s = nil;
+    if (nlhdr.nfiles != 0 and addr >= filetab[0].addr) {
+	i = 0;
+	j = nlhdr.nfiles - 1;
+	while (i < j) {
+	    k = (i + j) / 2;
+	    ftp = &filetab[k];
+	    a = ftp->addr;
+	    if (a == addr) {
+		s = ftp->filename;
+		break;
+	    } else if (addr > a) {
+		i = k + 1;
+	    } else {
+		j = k - 1;
+	    }
+	}
+	if (s == nil) {
+	    if (addr >= filetab[i].addr) {
+		s = filetab[i].filename;
+	    } else {
+		s = filetab[i-1].filename;
+	    }
+	}
+    }
+    return s;
+}
+
+/*
+ * Find the line associated with the given address.
+ * If the second parameter is true, then the address must match
+ * a source line exactly.  Otherwise the nearest source line
+ * below the given address is returned.  In any case, if no suitable
+ * line exists, 0 is returned.
+ */
+
+private Lineno findline(addr, exact)
+Address addr;
+Boolean exact;
+{
+    register Address i, j, k;
+    register Lineno r;
+    register Address a;
+
+    if (nlhdr.nlines == 0 or addr < linetab[0].addr) {
+	r = 0;
+    } else {
+	i = 0;
+	j = nlhdr.nlines - 1;
+	if (addr == linetab[i].addr) {
+	    r = linetab[i].line;
+	} else if (addr == linetab[j].addr) {
+	    r = linetab[j].line;
+	} else if (addr > linetab[j].addr) {
+	    r = exact ? 0 : linetab[j].line;
+	} else {
+	    do {
+		k = (i + j) div 2;
+		a = linetab[k].addr;
+	    if (a == addr) break;
+		if (addr > a) {
+		    i = k + 1;
+		} else {
+		    j = k - 1;
+		}
+	    } while (i <= j);
+	    if (a == addr) {
+		r = linetab[k].line;
+	    } else if (exact) {
+		r = 0;
+	    } else if (addr > linetab[i].addr) {
+		r = linetab[i].line;
+	    } else {
+		r = linetab[i-1].line;
+	    }
+	}
+    }
+    return r;
+}
+
+/*
+ * Lookup the source line number nearest from below to an address.
+ */
+
+public Lineno srcline(addr)
+Address addr;
+{
+    return findline(addr, false);
+}
+
+/*
+ * Look for a line exactly corresponding to the given address.
+ */
+
+public Lineno linelookup(addr)
+Address addr;
+{
+    return findline(addr, true);
+}
+
+/*
+ * Lookup the object address of a given line from the named file.
+ *
+ * Potentially all files in the file table need to be checked
+ * until the line is found since a particular file name may appear
+ * more than once in the file table (caused by includes).
+ */
+
+public Address objaddr(line, name)
+Lineno line;
+String name;
+{
+    register Filetab *ftp;
+    register Lineno i, j;
+    Boolean foundfile;
+
+    if (nlhdr.nlines == 0) {
+	return NOADDR;
+    }
+    if (name == nil) {
+	name = cursource;
+    }
+    foundfile = false;
+    for (ftp = &filetab[0]; ftp < &filetab[nlhdr.nfiles]; ftp++) {
+	if (streq(ftp->filename, name)) {
+	    foundfile = true;
+	    i = ftp->lineindex;
+	    if (ftp == &filetab[nlhdr.nfiles-1]) {
+		j = nlhdr.nlines;
+	    } else {
+		j = (ftp + 1)->lineindex;
+	    }
+	    while (i < j) {
+		if (linetab[i].line == line) {
+		    return linetab[i].addr;
+		}
+		i++;
+	    }
+	}
+    }
+    if (not foundfile) {
+	error("unknown source file \"%s\"", name);
+    }
+    return NOADDR;
+}
+
+/*
+ * Table for going from object addresses to the functions in which they belong.
+ */
+
+#define MAXNFUNCS 2001      /* maximum number of functions allowed */
+
+typedef struct {
+    Symbol func;
+    Address addr;
+} AddrOfFunc;
+
+private AddrOfFunc functab[MAXNFUNCS];
+private int nfuncs;
+
+/*
+ * Insert a new function into the table.
+ * The table is ordered by object address.
+ */
+
+public newfunc(f, addr)
+Symbol f;
+Address addr;
+{
+    register AddrOfFunc *af;
+
+    if (nfuncs >= MAXNFUNCS) {
+	panic("too many procedures/functions");
+    }
+    af = &functab[nfuncs];
+    af->func = f;
+    af->addr = addr;
+    ++nfuncs;
+}
+
+/*
+ * Return the function that begins at the given address.
+ */
+
+public Symbol whatblock(addr)
+Address addr;
+{
+    register int i, j, k;
+    Address a;
+
+    i = 0;
+    j = nfuncs - 1;
+    if (addr < functab[i].addr) {
+	return program;
+    } else if (addr == functab[i].addr) {
+	return functab[i].func;
+    } else if (addr >= functab[j].addr) {
+	return functab[j].func;
+    }
+    while (i <= j) {
+	k = (i + j) / 2;
+	a = functab[k].addr;
+	if (a == addr) {
+	    return functab[k].func;
+	} else if (addr > a) {
+	    i = k+1;
+	} else {
+	    j = k-1;
+	}
+    }
+    if (addr > functab[i].addr) {
+	return functab[i].func;
+    } else {
+	return functab[i-1].func;
+    }
+    /* NOTREACHED */
+}
+
+/*
+ * Order the functab.
+ */
+
+private int cmpfunc(f1, f2)
+AddrOfFunc *f1, *f2;
+{
+    register Address a1, a2;
+
+    a1 = (*f1).addr;
+    a2 = (*f2).addr;
+    return ( (a1 < a2) ? -1 : ( (a1 == a2) ? 0 : 1 ) );
+}
+
+public ordfunctab()
+{
+    qsort(functab, nfuncs, sizeof(AddrOfFunc), cmpfunc);
+}
+
+/*
+ * Clear out the functab, used when re-reading the object information.
+ */
+
+public clrfunctab()
+{
+    nfuncs = 0;
+}
+
+public dumpfunctab()
+{
+    int i;
+
+    for (i = 0; i < nfuncs; i++) { 
+	psym(functab[i].func);
+    }
+}
diff --git a/dbx/mappings.h b/dbx/mappings.h
new file mode 100644
index 0000000..4cef795
--- /dev/null
+++ b/dbx/mappings.h
@@ -0,0 +1,32 @@
+#ifndef mappings_h
+#define mappings_h
+#include "machine.h"
+#include "source.h"
+#include "symbols.h"
+
+typedef struct {
+    Address addr;
+    String filename;
+    Lineno lineindex;		/* index to first linetab entry */
+} Filetab;
+
+typedef struct {
+    Lineno line;
+    Address addr;
+} Linetab;
+
+Filetab *filetab;
+Linetab *linetab;
+
+#define NOADDR ((Address) -1)	/* no address for line or procedure */
+
+String srcfilename(/* addr */);
+Lineno srcline(/* addr */);
+Lineno linelookup(/* addr */);
+Address objaddr(/* line, name */);
+newfunc(/* f, addr */);
+Symbol whatblock(/* addr */);
+ordfunctab(/*  */);
+clrfunctab(/*  */);
+dumpfunctab(/*  */);
+#endif
diff --git a/dbx/mkdate b/dbx/mkdate
new file mode 100755
index 0000000..7e7f89c
Binary files /dev/null and b/dbx/mkdate differ
diff --git a/dbx/mkdate.c b/dbx/mkdate.c
new file mode 100644
index 0000000..28ff53e
--- /dev/null
+++ b/dbx/mkdate.c
@@ -0,0 +1,23 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)mkdate.c 1.2 7/3/83";
+
+#include <stdio.h>
+#include <sys/time.h>
+
+main()
+{
+    struct tm *t;
+    long clock;
+    char name[100];
+    int namelen;
+
+    printf("char *date = \"");
+    clock = time(0);
+    t = localtime(&clock);
+    printf("%d/%d/%d ", t->tm_mon + 1, t->tm_mday, t->tm_year % 100);
+    printf("%d:%02d", t->tm_hour, t->tm_min);
+    gethostname(name, &namelen);
+    printf(" (%s)", name);
+    printf("\";\n");
+}
diff --git a/dbx/names.c b/dbx/names.c
new file mode 100644
index 0000000..09c76ce
--- /dev/null
+++ b/dbx/names.c
@@ -0,0 +1,166 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)names.c 1.3 2/16/83";
+
+/*
+ * Name are the internal representation for identifiers.
+ *
+ * A hash table is used to map identifiers to names.
+ */
+
+#include "defs.h"
+#include "names.h"
+
+#ifndef public
+typedef struct Name *Name;
+
+/*
+ * Inline (for speed) function to return the identifier (string)
+ * associated with a name.  Because C cannot support both inlines
+ * and data hiding at the same time, the Name structure must be
+ * publicly visible.  It is not used explicitly, however, outside of this file.
+ */
+
+struct Name {
+    char *identifier;
+    Name chain;
+};
+
+#define ident(n) ((n == nil) ? "(noname)" : n->identifier)
+#endif
+
+#define HASHTABLESIZE 2997
+
+private Name nametable[HASHTABLESIZE];
+
+/*
+ * Names are allocated in large chunks to avoid calls to malloc
+ * and to cluster names in memory so that tracing hash chains
+ * doesn't cause many a page fault.
+ */
+
+#define CHUNKSIZE 200
+
+typedef struct Namepool {
+    struct Name name[CHUNKSIZE];
+    struct Namepool *prevpool;
+} *Namepool;
+
+private Namepool namepool = nil;
+private Integer nleft = 0;
+
+/*
+ * Given an identifier, convert it to a name.
+ * If it's not in the hash table, then put it there.
+ *
+ * The second argument specifies whether the string should be copied
+ * into newly allocated space if not found.
+ *
+ * Pardon my use of goto's, but it seemed more efficient and less convoluted
+ * than adding a collection of boolean variables.  This routine is time
+ * critical when starting up the debugger on large programs.
+ */
+
+public Name identname(s, isallocated)
+String s;
+Boolean isallocated;
+{
+    register unsigned h;
+    register Char *p, *q;
+    register Name n;
+    register Integer len;
+    Namepool newpool;
+
+    h = 0;
+    for (p = s; *p != '\0'; p++) {
+	h = (h << 1) ^ (*p);
+    }
+    h = h mod HASHTABLESIZE;
+    len = p - s;
+    n = nametable[h];
+    while (n != nil) {
+	p = s;
+	q = n->identifier;
+	for (;;) {
+	    if (*p != *q) {
+		goto nomatch;
+	    } else if (*p == '\0') {
+		goto match;
+	    }
+	    ++p;
+	    ++q;
+	}
+    nomatch:
+	n = n->chain;
+    }
+
+    /*
+     * Now we know that name hasn't been found (otherwise we'd have jumped
+     * down to match), so we allocate a name, store the identifier, and
+     * enter it in the hash table.
+     */
+    if (nleft <= 0) {
+	newpool = new(Namepool);
+	bzero(newpool, sizeof(newpool));
+	newpool->prevpool = namepool;
+	namepool = newpool;
+	nleft = CHUNKSIZE;
+    }
+    --nleft;
+    n = &(namepool->name[nleft]);
+    if (isallocated) {
+	n->identifier = s;
+    } else {
+	n->identifier = newarr(char, len + 1);
+	p = s;
+	q = n->identifier;
+	while (*p != '\0') {
+	    *q++ = *p++;
+	}
+	*q = '\0';
+    }
+    n->chain = nametable[h];
+    nametable[h] = n;
+
+    /*
+     * The two possibilities (name known versus unknown) rejoin.
+     */
+match:
+    return n;
+}
+
+/*
+ * Return the identifier associated with a name.
+ *
+ * Currently compiled inline.
+ *
+ *
+ * public String ident(n)
+Name n;
+{
+    return (n == nil) ? "(noname)" : n->identifier;
+}
+ *
+ */
+
+/*
+ * Deallocate the name table.
+ */
+
+public names_free()
+{
+    register int i;
+    register Name n, next;
+
+    for (i = 0; i < HASHTABLESIZE; i++) {
+	n = nametable[i];
+	while (n != nil) {
+	    next = n->chain;
+	    dispose(n);
+	    n = next;
+	}
+	nametable[i] = nil;
+    }
+    namepool = nil;
+    nleft = 0;
+}
diff --git a/dbx/names.h b/dbx/names.h
new file mode 100644
index 0000000..db95146
--- /dev/null
+++ b/dbx/names.h
@@ -0,0 +1,20 @@
+#ifndef names_h
+#define names_h
+typedef struct Name *Name;
+
+/*
+ * Inline (for speed) function to return the identifier (string)
+ * associated with a name.  Because C cannot support both inlines
+ * and data hiding at the same time, the Name structure must be
+ * publicly visible.  It is not used explicitly, however, outside of this file.
+ */
+
+struct Name {
+    char *identifier;
+    Name chain;
+};
+
+#define ident(n) ((n == nil) ? "(noname)" : n->identifier)
+Name identname(/* s, isallocated */);
+names_free(/*  */);
+#endif
diff --git a/dbx/object.c b/dbx/object.c
new file mode 100644
index 0000000..937757b
--- /dev/null
+++ b/dbx/object.c
@@ -0,0 +1,1100 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)object.c 1.13 8/16/83";
+
+/*
+ * Object code interface, mainly for extraction of symbolic information.
+ */
+
+#include "defs.h"
+#include "object.h"
+#include "main.h"
+#include "symbols.h"
+#include "names.h"
+#include "languages.h"
+#include "mappings.h"
+#include "lists.h"
+#include <a.out.h>
+#include <stab.h>
+#include <ctype.h>
+
+#ifndef public
+
+struct {
+    unsigned int stringsize;	/* size of the dumped string table */
+    unsigned int nsyms;		/* number of symbols */
+    unsigned int nfiles;	/* number of files */
+    unsigned int nlines;	/* number of lines */
+} nlhdr;
+
+#endif
+
+public String objname = "a.out";
+public Integer objsize;
+public char *stringtab;
+
+private String progname = nil;
+private Language curlang;
+private Symbol curmodule;
+private Symbol curparam;
+private Boolean warned;
+private Symbol curcomm;
+private Symbol commchain;
+private Boolean strip_ = false;
+
+private Filetab *filep;
+private Linetab *linep, *prevlinep;
+
+#define curfilename() (filep-1)->filename
+
+/*
+ * Blocks are figured out on the fly while reading the symbol table.
+ */
+
+#define MAXBLKDEPTH 25
+
+private Symbol curblock;
+private Symbol blkstack[MAXBLKDEPTH];
+private Integer curlevel;
+private Integer bnum, nesting;
+private Address addrstk[MAXBLKDEPTH];
+
+#define enterblock(b) { \
+    blkstack[curlevel] = curblock; \
+    ++curlevel; \
+    b->level = curlevel; \
+    b->block = curblock; \
+    curblock = b; \
+}
+
+#define exitblock() { \
+    if (curblock->class == FUNC or curblock->class == PROC) { \
+	if (prevlinep != linep) { \
+	    curblock->symvalue.funcv.src = true; \
+	} \
+    } \
+    --curlevel; \
+    curblock = blkstack[curlevel]; \
+}
+
+/*
+ * Enter a source line or file name reference into the appropriate table.
+ * Expanded inline to reduce procedure calls.
+ *
+ * private enterline(linenumber, address)
+ * Lineno linenumber;
+ * Address address;
+ *  ...
+ */
+
+#define enterline(linenumber, address) \
+{ \
+    register Linetab *lp; \
+ \
+    lp = linep - 1; \
+    if (linenumber != lp->line) { \
+	if (address != lp->addr) { \
+	    ++lp; \
+	} \
+	lp->line = linenumber; \
+	lp->addr = address; \
+	linep = lp + 1; \
+    } \
+}
+
+#define NTYPES 1000
+
+private Symbol typetable[NTYPES];
+
+/*
+ * Read in the namelist from the obj file.
+ *
+ * Reads and seeks are used instead of fread's and fseek's
+ * for efficiency sake; there's a lot of data being read here.
+ */
+
+public readobj(file)
+String file;
+{
+    Fileid f;
+    struct exec hdr;
+    struct nlist nlist;
+
+    f = open(file, 0);
+    if (f < 0) {
+	fatal("can't open %s", file);
+    }
+    read(f, &hdr, sizeof(hdr));
+    objsize = hdr.a_text;
+    nlhdr.nsyms = hdr.a_syms / sizeof(nlist);
+    nlhdr.nfiles = nlhdr.nsyms;
+    nlhdr.nlines = nlhdr.nsyms;
+    if (nlhdr.nsyms > 0) {
+	lseek(f, (long) N_STROFF(hdr), 0);
+	read(f, &(nlhdr.stringsize), sizeof(nlhdr.stringsize));
+	nlhdr.stringsize -= 4;
+	stringtab = newarr(char, nlhdr.stringsize);
+	read(f, stringtab, nlhdr.stringsize);
+	allocmaps(nlhdr.nfiles, nlhdr.nlines);
+	lseek(f, (long) N_SYMOFF(hdr), 0);
+	readsyms(f);
+	ordfunctab();
+	setnlines();
+	setnfiles();
+    }
+    close(f);
+}
+
+/*
+ * Read in symbols from object file.
+ */
+
+private readsyms(f)
+Fileid f;
+{
+    struct nlist *namelist;
+    register struct nlist *np, *ub;
+    register int index;
+    register String name;
+    register Boolean afterlg;
+
+    initsyms();
+    namelist = newarr(struct nlist, nlhdr.nsyms);
+    read(f, namelist, nlhdr.nsyms * sizeof(struct nlist));
+    afterlg = false;
+    ub = &namelist[nlhdr.nsyms];
+    for (np = &namelist[0]; np < ub; np++) {
+	index = np->n_un.n_strx;
+	if (index != 0) {
+	    name = &stringtab[index - 4];
+	    /*
+             *  if the program contains any .f files a trailing _ is stripped
+       	     *  from the name on the assumption it was added by the compiler.
+	     *  This only affects names that follow the sdb N_SO entry with
+             *  the .f name. 
+             */
+            if (strip_ and name[0] != '\0' ) {
+		register char *p;
+
+		p = name;
+		while (*p != '\0') {
+		    ++p;
+		}
+		--p;
+		if (*p == '_') {
+		    *p = '\0';
+		}
+            }
+
+	} else {
+	    name = nil;
+	} 
+	/*
+	 * assumptions:
+	 *	not an N_STAB	==> name != nil
+	 *	name[0] == '-'	==> name == "-lg"
+	 *	name[0] != '_'	==> filename or invisible
+	 *
+	 * The "-lg" signals the beginning of global loader symbols.
+         *
+	 */
+	if ((np->n_type&N_STAB) != 0) {
+	    enter_nl(name, np);
+	} else if (name[0] == '-') {
+	    afterlg = true;
+	    if (curblock->class != PROG) {
+		exitblock();
+		if (curblock->class != PROG) {
+		    exitblock();
+		}
+	    }
+	    enterline(0, (linep-1)->addr + 1);
+	} else if (afterlg) {
+	    if (name[0] == '_') {
+		check_global(&name[1], np);
+	    }
+	} else if (name[0] == '_') {
+	    check_local(&name[1], np);
+	} else if ((np->n_type&N_TEXT) == N_TEXT) {
+	    check_filename(name);
+	}
+    }
+    if (not afterlg) {
+	fatal("not linked for debugging, use \"cc -g ...\"");
+    }
+    dispose(namelist);
+}
+
+/*
+ * Initialize symbol information.
+ */
+
+private initsyms()
+{
+    curblock = nil;
+    curlevel = 0;
+    nesting = 0;
+    if (progname == nil) {
+	progname = strdup(objname);
+	if (rindex(progname, '/') != nil) {
+	    progname = rindex(progname, '/') + 1;
+	}
+	if (index(progname, '.') != nil) {
+	    *(index(progname, '.')) = '\0';
+	}
+    }
+    program = insert(identname(progname, true));
+    program->class = PROG;
+    program->symvalue.funcv.beginaddr = 0;
+    program->symvalue.funcv.inline = false;
+    newfunc(program, codeloc(program));
+    findbeginning(program);
+    enterblock(program);
+    curmodule = program;
+}
+
+/*
+ * Free all the object file information that's being stored.
+ */
+
+public objfree()
+{
+    symbol_free();
+    keywords_free();
+    names_free();
+    dispose(stringtab);
+    clrfunctab();
+}
+
+/*
+ * Enter a namelist entry.
+ */
+
+private enter_nl(name, np)
+String name;
+register struct nlist *np;
+{
+    register Symbol s;
+    register Name n, nn;
+    char buf[100];
+
+    s = nil;
+    if (name == nil) {
+	n = nil;
+    } else {
+	n = identname(name, true);
+    }
+    switch (np->n_type) {
+	/*
+	 * Build a symbol for the FORTRAN common area.  All GSYMS that follow
+	 * will be chained in a list with the head kept in common.offset, and
+	 * the tail in common.chain.
+	 */
+	case N_BCOMM:
+ 	    if (curcomm) {
+		curcomm->symvalue.common.chain = commchain;
+	    }
+	    curcomm = lookup(n);
+	    if (curcomm == nil) {
+		curcomm = insert(n);
+		curcomm->class = COMMON;
+		curcomm->block = curblock;
+		curcomm->level = program->level;
+		curcomm->symvalue.common.chain = nil;
+	    }
+	    commchain = curcomm->symvalue.common.chain;
+	    break;
+
+	case N_ECOMM:
+	    if (curcomm) {
+		curcomm->symvalue.common.chain = commchain;
+		curcomm = nil;
+	    }
+	    break;
+
+	case N_LBRAC:
+	    ++nesting;
+	    addrstk[nesting] = (linep - 1)->addr;
+	    break;
+
+	case N_RBRAC:
+	    if (addrstk[nesting] == NOADDR) {
+		exitblock();
+		newfunc(curblock, (linep - 1)->addr);
+	    }
+	    --nesting;
+	    break;
+
+	case N_SLINE:
+	    enterline((Lineno) np->n_desc, (Address) np->n_value);
+	    break;
+
+	/*
+	 * Source files.
+	 */
+	case N_SO:
+	    enterSourceModule(n, (Address) np->n_value);
+	    break;
+
+	/*
+	 * Textually included files.
+	 */
+	case N_SOL:
+	    enterfile(name, (Address) np->n_value);
+	    break;
+
+	/*
+	 * These symbols are assumed to have non-nil names.
+	 */
+	case N_GSYM:
+	case N_FUN:
+	case N_STSYM:
+	case N_LCSYM:
+	case N_RSYM:
+	case N_PSYM:
+	case N_LSYM:
+	case N_SSYM:
+	case N_LENG:
+	    if (index(name, ':') == nil) {
+		if (not warned) {
+		    warned = true;
+		    warning("old style symbol information found in \"%s\"",
+			curfilename());
+		}
+	    } else {
+		entersym(name, np);
+	    }
+	    break;
+
+	case N_PC:
+	    break;
+
+	default:
+	    printf("warning:  stab entry unrecognized: ");
+	    if (name != nil) {
+		printf("name %s,", name);
+	    }
+	    printf("ntype %2x, desc %x, value %x'\n",
+		np->n_type, np->n_desc, np->n_value);
+	    break;
+    }
+}
+
+/*
+ * Check to see if a global _name is already in the symbol table,
+ * if not then insert it.
+ */
+
+private check_global(name, np)
+String name;
+register struct nlist *np;
+{
+    register Name n;
+    register Symbol t, u;
+
+    if (not streq(name, "end")) {
+	n = identname(name, true);
+	if ((np->n_type&N_TYPE) == N_TEXT) {
+	    find(t, n) where
+		t->level == program->level and
+		(t->class == PROC or t->class == FUNC)
+	    endfind(t);
+	    if (t == nil) {
+		t = insert(n);
+		t->language = findlanguage(".s");
+		t->class = FUNC;
+		t->type = t_int;
+		t->block = curblock;
+		t->level = program->level;
+		t->symvalue.funcv.src = false;
+		t->symvalue.funcv.inline = false;
+	    }
+	    t->symvalue.funcv.beginaddr = np->n_value;
+	    newfunc(t, codeloc(t));
+	    findbeginning(t);
+	} else if ((np->n_type&N_TYPE) == N_BSS) {
+	    find(t, n) where
+		t->class == COMMON
+	    endfind(t);
+	    if (t != nil) {
+		u = (Symbol) t->symvalue.common.offset;
+		while (u != nil) {
+		    u->symvalue.offset = u->symvalue.common.offset+np->n_value;
+		    u = u->symvalue.common.chain;
+		}
+            } else {
+		check_var(np, n);
+	    }
+        } else {
+	    check_var(np, n);
+	}
+    }
+}
+
+/*
+ * Check to see if a namelist entry refers to a variable.
+ * If not, create a variable for the entry.  In any case,
+ * set the offset of the variable according to the value field
+ * in the entry.
+ */
+
+private check_var(np, n)
+struct nlist *np;
+register Name n;
+{
+    register Symbol t;
+
+    find(t, n) where
+	t->class == VAR and t->level == program->level
+    endfind(t);
+    if (t == nil) {
+	t = insert(n);
+	t->language = findlanguage(".s");
+	t->class = VAR;
+	t->type = t_int;
+	t->level = program->level;
+    }
+    t->block = curblock;
+    t->symvalue.offset = np->n_value;
+}
+
+/*
+ * Check to see if a local _name is known in the current scope.
+ * If not then enter it.
+ */
+
+private check_local(name, np)
+String name;
+register struct nlist *np;
+{
+    register Name n;
+    register Symbol t, cur;
+
+    n = identname(name, true);
+    cur = ((np->n_type&N_TYPE) == N_TEXT) ? curmodule : curblock;
+    find(t, n) where t->block == cur endfind(t);
+    if (t == nil) {
+	t = insert(n);
+	t->language = findlanguage(".s");
+	t->type = t_int;
+	t->block = cur;
+	t->level = cur->level;
+	if ((np->n_type&N_TYPE) == N_TEXT) {
+	    t->class = FUNC;
+	    t->symvalue.funcv.src = false;
+	    t->symvalue.funcv.inline = false;
+	    t->symvalue.funcv.beginaddr = np->n_value;
+	    newfunc(t, codeloc(t));
+	    findbeginning(t);
+	} else {
+	    t->class = VAR;
+	    t->symvalue.offset = np->n_value;
+	}
+    }
+}
+
+/*
+ * Check to see if a symbol corresponds to a object file name.
+ * For some reason these are listed as in the text segment.
+ */
+
+private check_filename(name)
+String name;
+{
+    register String mname;
+    register Integer i;
+    register Symbol s;
+
+    mname = strdup(name);
+    i = strlen(mname) - 2;
+    if (i >= 0 and mname[i] == '.' and mname[i+1] == 'o') {
+	mname[i] = '\0';
+	--i;
+	while (mname[i] != '/' and i >= 0) {
+	    --i;
+	}
+	s = insert(identname(&mname[i+1], true));
+	s->language = findlanguage(".s");
+	s->class = MODULE;
+	s->symvalue.funcv.beginaddr = 0;
+	findbeginning(s);
+	if (curblock->class != PROG) {
+	    exitblock();
+	    if (curblock->class != PROG) {
+		exitblock();
+	    }
+	}
+	enterblock(s);
+	curmodule = s;
+    }
+}
+
+/*
+ * Check to see if a symbol is about to be defined within an unnamed block.
+ * If this happens, we create a procedure for the unnamed block, make it
+ * "inline" so that tracebacks don't associate an activation record with it,
+ * and enter it into the function table so that it will be detected
+ * by "whatblock".
+ */
+
+private unnamed_block()
+{
+    register Symbol s;
+    static int bnum = 0;
+    char buf[100];
+
+    ++bnum;
+    sprintf(buf, "$b%d", bnum);
+    s = insert(identname(buf, false));
+    s->class = PROG;
+    s->symvalue.funcv.src = false;
+    s->symvalue.funcv.inline = true;
+    s->symvalue.funcv.beginaddr = addrstk[nesting];
+    enterblock(s);
+    newfunc(s, addrstk[nesting]);
+    addrstk[nesting] = NOADDR;
+}
+
+/*
+ * Compilation unit.  C associates scope with filenames
+ * so we treat them as "modules".  The filename without
+ * the suffix is used for the module name.
+ *
+ * Because there is no explicit "end-of-block" mark in
+ * the object file, we must exit blocks for the current
+ * procedure and module.
+ */
+
+private enterSourceModule(n, addr)
+Name n;
+Address addr;
+{
+    register Symbol s;
+    Name nn;
+    String mname, suffix;
+
+    mname = strdup(ident(n));
+    if (rindex(mname, '/') != nil) {
+	mname = rindex(mname, '/') + 1;
+    }
+    suffix = rindex(mname, '.');
+    curlang = findlanguage(suffix);
+    if (curlang == findlanguage(".f")) {
+	strip_ = true;
+    } 
+    if (suffix != nil) {
+	*suffix = '\0';
+    }
+    if (curblock->class != PROG) {
+	exitblock();
+	if (curblock->class != PROG) {
+	    exitblock();
+	}
+    }
+    nn = identname(mname, true);
+    if (curmodule == nil or curmodule->name != nn) {
+	s = insert(nn);
+	s->class = MODULE;
+	s->symvalue.funcv.beginaddr = 0;
+	findbeginning(s);
+    } else {
+	s = curmodule;
+    }
+    s->language = curlang;
+    enterblock(s);
+    curmodule = s;
+    if (program->language == nil) {
+	program->language = curlang;
+    }
+    warned = false;
+    enterfile(ident(n), addr);
+    bzero(typetable, sizeof(typetable));
+}
+
+/*
+ * Put an nlist into the symbol table.
+ * If it's already there just add the associated information.
+ *
+ * Type information is encoded in the name following a ":".
+ */
+
+private Symbol constype();
+private Char *curchar;
+
+#define skipchar(ptr, ch) { \
+    if (*ptr != ch) { \
+	panic("expected char '%c', found char '%c'", ch, *ptr); \
+    } \
+    ++ptr; \
+}
+
+private entersym(str, np)
+String str;
+struct nlist *np;
+{
+    register Symbol s;
+    register char *p;
+    register int c;
+    register Name n;
+    register Integer i;
+    Boolean knowtype, isnew;
+    Symclass class;
+    Integer level;
+
+    p = index(str, ':');
+    *p = '\0';
+    c = *(p+1);
+    n = identname(str, true);
+    if (index("FfGV", c) != nil) {
+	if (c == 'F' or c == 'f') {
+	    class = FUNC;
+	} else {
+	    class = VAR;
+	}
+	level = (c == 'f' ? curmodule->level : program->level);
+	find(s, n) where s->level == level and s->class == class endfind(s);
+	if (s == nil) {
+	    isnew = true;
+	    s = insert(n);
+	} else {
+	    isnew = false;
+	}
+    } else {
+	isnew = true;
+	s = insert(n);
+    }
+
+    if (nesting > 0 and addrstk[nesting] != NOADDR) {
+	unnamed_block();
+    }
+
+    /*
+     * Default attributes.
+     */
+    s->language = curlang;
+    s->class = VAR;
+    s->block = curblock;
+    s->level = curlevel;
+    s->symvalue.offset = np->n_value;
+    curchar = p + 2;
+    knowtype = false;
+    switch (c) {
+	case 't':	/* type name */
+	    s->class = TYPE;
+	    i = getint();
+	    if (i == 0) {
+		panic("bad input on type \"%s\" at \"%s\"", symname(s),
+		    curchar);
+	    } else if (i >= NTYPES) {
+		panic("too many types in file \"%s\"", curfilename());
+	    }
+	    /*
+	     * A hack for C typedefs that don't create new types,
+	     * e.g. typedef unsigned int Hashvalue;
+	     *  or  typedef struct blah BLAH;
+	     */
+	    if (*curchar == '\0') {
+		s->type = typetable[i];
+		if (s->type == nil) {
+		    s->type = symbol_alloc();
+		    typetable[i] = s->type;
+		}
+		knowtype = true;
+	    } else {
+		typetable[i] = s;
+		skipchar(curchar, '=');
+	    }
+	    break;
+
+	case 'T':	/* tag */
+	    s->class = TAG;
+	    i = getint();
+	    if (i == 0) {
+		panic("bad input on tag \"%s\" at \"%s\"", symname(s),
+		    curchar);
+	    } else if (i >= NTYPES) {
+		panic("too many types in file \"%s\"", curfilename());
+	    }
+	    if (typetable[i] != nil) {
+		typetable[i]->language = curlang;
+		typetable[i]->class = TYPE;
+		typetable[i]->type = s;
+	    } else {
+		typetable[i] = s;
+	    }
+	    skipchar(curchar, '=');
+	    break;
+
+	case 'F':	/* public function */
+	case 'f':	/* private function */
+	    s->class = FUNC;
+	    if (curblock->class == FUNC or curblock->class == PROC) {
+		exitblock();
+	    }
+	    enterblock(s);
+	    if (c == 'F') {
+		s->level = program->level;
+		isnew = false;
+	    }
+	    curparam = s;
+	    if (isnew) {
+		s->symvalue.funcv.src = false;
+		s->symvalue.funcv.inline = false;
+		s->symvalue.funcv.beginaddr = np->n_value;
+		newfunc(s, codeloc(s));
+		findbeginning(s);
+	    }
+	    break;
+
+	case 'G':	/* public variable */
+	    s->level = program->level;
+	    break;
+
+	case 'S':	/* private variable */
+	    s->level = curmodule->level;
+	    s->block = curmodule;
+	    break;
+
+/*
+ *  keep global BSS variables chained so can resolve when get the start
+ *  of common; keep the list in order so f77 can display all vars in a COMMON
+*/
+	case 'V':	/* own variable */
+	    s->level = 2;
+	    if (curcomm) {
+	      if (commchain != nil) {
+ 		  commchain->symvalue.common.chain = s;
+	      }			  
+	      else {
+		  curcomm->symvalue.common.offset = (int) s;
+	      }			  
+              commchain = s;
+              s->symvalue.common.offset = np->n_value;
+              s->symvalue.common.chain = nil;
+	    }
+	    break;
+
+	case 'r':	/* register variable */
+	    s->level = -(s->level);
+	    break;
+
+	case 'p':	/* parameter variable */
+	    curparam->chain = s;
+	    curparam = s;
+	    break;
+
+	case 'v':	/* varies parameter */
+	    s->class = REF;
+	    s->symvalue.offset = np->n_value;
+	    curparam->chain = s;
+	    curparam = s;
+	    break;
+
+	default:	/* local variable */
+	    --curchar;
+	    break;
+    }
+    if (not knowtype) {
+	s->type = constype(nil);
+	if (s->class == TAG) {
+	    addtag(s);
+	}
+    }
+    if (tracesyms) {
+	printdecl(s);
+	fflush(stdout);
+    }
+}
+
+/*
+ * Construct a type out of a string encoding.
+ *
+ * The forms of the string are
+ *
+ *	<number>
+ *	<number>=<type>
+ *	r<type>;<number>;<number>		$ subrange
+ *	a<type>;<type>				$ array[index] of element
+ *	s{<name>:<type>;<number>;<number>}	$ record
+ *	S<type>					$ set
+ *	*<type>					$ pointer
+ */
+
+private Rangetype getrangetype();
+
+private Symbol constype(type)
+Symbol type;
+{
+    register Symbol t, u;
+    register Char *p, *cur;
+    register Integer n;
+    Integer b;
+    Name name;
+    Char class;
+
+    b = curlevel;
+    if (isdigit(*curchar)) {
+	n = getint();
+	if (n == 0) {
+	    panic("bad type number at \"%s\"", curchar);
+	} else if (n >= NTYPES) {
+	    panic("too many types in file \"%s\"", curfilename());
+	}
+	if (*curchar == '=') {
+	    if (typetable[n] != nil) {
+		t = typetable[n];
+	    } else {
+		t = symbol_alloc();
+		typetable[n] = t;
+	    }
+	    ++curchar;
+	    constype(t);
+	} else {
+	    t = typetable[n];
+	    if (t == nil) {
+		t = symbol_alloc();
+		typetable[n] = t;
+	    }
+	}
+    } else {
+	if (type == nil) {
+	    t = symbol_alloc();
+	} else {
+	    t = type;
+	}
+	t->language = curlang;
+	t->level = b;
+	t->block = curblock;
+	class = *curchar++;
+	switch (class) {
+	    case 'r':
+		t->class = RANGE;
+		t->type = constype(nil);
+		skipchar(curchar, ';');
+		t->symvalue.rangev.lowertype = getrangetype();
+	        t->symvalue.rangev.lower = getint();
+		skipchar(curchar, ';');
+		t->symvalue.rangev.uppertype = getrangetype();
+		t->symvalue.rangev.upper = getint();
+		break;
+
+	    case 'a':
+		t->class = ARRAY;
+		t->chain = constype(nil);
+		skipchar(curchar, ';');
+		t->type = constype(nil);
+		break;
+
+	    case 'S':
+		t->class = SET;
+		t->type = constype(nil);
+		break;
+
+	    case 's':
+	    case 'u':
+		t->class = (class == 's') ? RECORD : VARNT;
+		t->symvalue.offset = getint();
+		u = t;
+		cur = curchar;
+		while (*cur != ';' and *cur != '\0') {
+		    p = index(cur, ':');
+		    if (p == nil) {
+			panic("index(\"%s\", ':') failed", curchar);
+		    }
+		    *p = '\0';
+		    name = identname(cur, true);
+		    u->chain = newSymbol(name, b, FIELD, nil, nil);
+		    cur = p + 1;
+		    u = u->chain;
+		    u->language = curlang;
+		    curchar = cur;
+		    u->type = constype(nil);
+		    skipchar(curchar, ',');
+		    u->symvalue.field.offset = getint();
+		    skipchar(curchar, ',');
+		    u->symvalue.field.length = getint();
+		    skipchar(curchar, ';');
+		    cur = curchar;
+		}
+		if (*cur == ';') {
+		    ++cur;
+		}
+		curchar = cur;
+		break;
+
+	    case 'e':
+		t->class = SCAL;
+		u = t;
+		while (*curchar != ';' and *curchar != '\0') {
+		    p = index(curchar, ':');
+		    assert(p != nil);
+		    *p = '\0';
+		    u->chain = insert(identname(curchar, true));
+		    curchar = p + 1;
+		    u = u->chain;
+		    u->language = curlang;
+		    u->class = CONST;
+		    u->level = b;
+		    u->block = curblock;
+		    u->type = t;
+		    u->symvalue.iconval = getint();
+		    skipchar(curchar, ',');
+		}
+		break;
+
+	    case '*':
+		t->class = PTR;
+		t->type = constype(nil);
+		break;
+
+	    case 'f':
+		t->class = FUNC;
+		t->type = constype(nil);
+		break;
+
+	    default:
+		badcaseval(class);
+	}
+    }
+    return t;
+}
+
+/*
+ * Get a range type.
+ *
+ * Special letters indicate a dynamic bound, i.e. what follows
+ * is the offset from the fp which contains the bound.
+ * J is a special flag to handle fortran a(*) bounds.
+ */
+
+private Rangetype getrangetype()
+{
+    Rangetype t;
+
+    switch (*curchar) {
+	case 'A':
+	    t = R_ARG;
+	    curchar++;
+	    break;
+
+	case 'T':
+	    t = R_TEMP;
+	    curchar++;
+	    break;
+
+	case 'J': 
+	    t = R_ADJUST;
+	    curchar++;
+	    break;
+
+	default:
+	    t = R_CONST;
+	    break;
+    }
+    return t;
+}
+
+/*
+ * Read an integer from the current position in the type string.
+ */
+
+private Integer getint()
+{
+    register Integer n;
+    register char *p;
+    register Boolean isneg;
+
+    n = 0;
+    p = curchar;
+    if (*p == '-') {
+	isneg = true;
+	++p;
+    } else {
+	isneg = false;
+    }
+    while (isdigit(*p)) {
+	n = 10*n + (*p - '0');
+	++p;
+    }
+    curchar = p;
+    return isneg ? (-n) : n;
+}
+
+/*
+ * Add a tag name.  This is a kludge to be able to refer
+ * to tags that have the same name as some other symbol
+ * in the same block.
+ */
+
+private addtag(s)
+register Symbol s;
+{
+    register Symbol t;
+    char buf[100];
+
+    sprintf(buf, "$$%.90s", ident(s->name));
+    t = insert(identname(buf, false));
+    t->language = s->language;
+    t->class = TAG;
+    t->type = s->type;
+    t->block = s->block;
+}
+
+/*
+ * Allocate file and line tables and initialize indices.
+ */
+
+private allocmaps(nf, nl)
+Integer nf, nl;
+{
+    if (filetab != nil) {
+	dispose(filetab);
+    }
+    if (linetab != nil) {
+	dispose(linetab);
+    }
+    filetab = newarr(Filetab, nf);
+    linetab = newarr(Linetab, nl);
+    filep = filetab;
+    linep = linetab;
+}
+
+/*
+ * Add a file to the file table.
+ *
+ * If the new address is the same as the previous file address
+ * this routine used to not enter the file, but this caused some
+ * problems so it has been removed.  It's not clear that this in
+ * turn may not also cause a problem.
+ */
+
+private enterfile(filename, addr)
+String filename;
+Address addr;
+{
+    filep->addr = addr;
+    filep->filename = filename;
+    filep->lineindex = linep - linetab;
+    ++filep;
+}
+
+/*
+ * Since we only estimated the number of lines (and it was a poor
+ * estimation) and since we need to know the exact number of lines
+ * to do a binary search, we set it when we're done.
+ */
+
+private setnlines()
+{
+    nlhdr.nlines = linep - linetab;
+}
+
+/*
+ * Similarly for nfiles ...
+ */
+
+private setnfiles()
+{
+    nlhdr.nfiles = filep - filetab;
+    setsource(filetab[0].filename);
+}
diff --git a/dbx/object.h b/dbx/object.h
new file mode 100644
index 0000000..881f60f
--- /dev/null
+++ b/dbx/object.h
@@ -0,0 +1,16 @@
+#ifndef object_h
+#define object_h
+
+struct {
+    unsigned int stringsize;	/* size of the dumped string table */
+    unsigned int nsyms;		/* number of symbols */
+    unsigned int nfiles;	/* number of files */
+    unsigned int nlines;	/* number of lines */
+} nlhdr;
+
+String objname ;
+Integer objsize;
+char *stringtab;
+readobj(/* file */);
+objfree(/*  */);
+#endif
diff --git a/dbx/operators.c b/dbx/operators.c
new file mode 100644
index 0000000..b616e72
--- /dev/null
+++ b/dbx/operators.c
@@ -0,0 +1,200 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)operators.c 1.4 5/18/83";
+
+/*
+ * Tree node classes.
+ */
+
+#include "defs.h"
+#include "operators.h"
+
+#ifndef public
+typedef struct {
+    char numargs;
+    char opflags;
+    String opstring;
+} Opinfo;
+
+typedef enum {
+    O_NOP,
+    O_NAME, O_SYM, O_LCON, O_FCON, O_SCON,
+    O_RVAL, O_INDEX, O_INDIR, O_DOT,
+    O_COMMA,
+
+    O_ITOF, O_ADD, O_ADDF, O_SUB, O_SUBF, O_NEG, O_NEGF,
+    O_MUL, O_MULF, O_DIVF, O_DIV, O_MOD,
+
+    O_AND, O_OR,
+
+    O_LT, O_LTF, O_LE, O_LEF, O_GT, O_GTF, O_GE, O_GEF,
+    O_EQ, O_EQF, O_NE, O_NEF,
+
+    O_ALIAS,		/* rename a command */
+    O_ASSIGN,		/* assign a value to a program variable */
+    O_CALL,		/* call a procedure in the program */
+    O_CATCH,		/* catch a signal before program does */
+    O_CHFILE,		/* change (or print) the current source file */
+    O_CONT,		/* continue execution */
+    O_DEBUG,		/* invoke a dbx internal debugging routine */
+    O_DELETE,		/* remove a trace/stop */
+    O_DUMP,		/* dump out variables */
+    O_EDIT,		/* edit a file (or function) */
+    O_FUNC,		/* set the current function */
+    O_GRIPE,		/* send mail to debugger support person */
+    O_HELP,		/* print a synopsis of debugger commands */
+    O_IGNORE,		/* let program catch signal */
+    O_LIST,		/* list source lines */
+    O_PRINT,		/* print the values of a list of expressions */
+    O_PSYM,		/* print symbol information */
+    O_RUN,		/* start up program */
+    O_SKIP,		/* skip the current line */
+    O_SOURCE,		/* read commands from a file */
+    O_STATUS,		/* display currently active trace/stop's */
+    O_STEP,		/* execute a single line */
+    O_STOP,		/* stop on an event */
+    O_STOPI,		/* stop on an event at an instruction boundary */
+    O_TRACE,		/* trace something on an event */
+    O_TRACEI,		/* trace at the instruction level */
+    O_WHATIS,		/* print the declaration of a variable */
+    O_WHERE,		/* print a stack trace */
+    O_WHEREIS,		/* print all the symbols with the given name */
+    O_WHICH,		/* print out full qualification of a symbol */
+    O_EXAMINE,		/* examine program instructions/data */
+
+    O_ADDEVENT,		/* add an event */
+    O_ENDX,		/* end of program reached */
+    O_IF,		/* if first arg is true, do commands in second arg */
+    O_ONCE,		/* add a "one-time" event, delete when first reached */
+    O_PRINTCALL,	/* print out the current procedure and its arguments */
+    O_PRINTIFCHANGED,	/* print the value of the argument if it has changed */
+    O_PRINTRTN,		/* print out the routine and value that just returned */
+    O_PRINTSRCPOS,	/* print out the current source position */
+    O_PROCRTN,		/* CALLPROC completed */
+    O_QLINE,		/* filename, line number */
+    O_STOPIFCHANGED,	/* stop if the value of the argument has changed */
+    O_STOPX,		/* stop execution */
+    O_TRACEON,		/* begin tracing source line, variable, or all lines */
+    O_TRACEOFF,		/* end tracing source line, variable, or all lines */
+
+    O_TYPERENAME,	/* state the type of an expression */
+
+    O_LASTOP
+} Operator;
+
+/*
+ * Operator flags and predicates.
+ */
+
+#define null 0
+#define LEAF 01
+#define UNARY 02
+#define BINARY 04
+#define BOOL 010
+#define REALOP 020
+#define INTOP 040
+
+#define isbitset(a, m)	((a&m) == m)
+#define isleaf(o)	isbitset(opinfo[ord(o)].opflags, LEAF)
+#define isunary(o)	isbitset(opinfo[ord(o)].opflags, UNARY)
+#define isbinary(o)	isbitset(opinfo[ord(o)].opflags, BINARY)
+#define isreal(o)	isbitset(opinfo[ord(o)].opflags, REALOP)
+#define isint(o)	isbitset(opinfo[ord(o)].opflags, INTOP)
+#define isboolean(o)	isbitset(opinfo[ord(o)].opflags, BOOL)
+
+#define degree(o)	(opinfo[ord(o)].opflags&(LEAF|UNARY|BINARY))
+#define nargs(o)	(opinfo[ord(o)].numargs)
+
+#endif
+
+/*
+ * Operator information structure.
+ */
+
+public Opinfo opinfo[] ={
+/* O_NOP */		0,	null,		0,
+/* O_NAME */		-1,	LEAF,		0,
+/* O_SYM */		-1,	LEAF,		0,
+/* O_LCON */		-1,	LEAF,		0,
+/* O_FCON */		-1,	LEAF,		0,
+/* O_SCON */		-1,	LEAF,		0,
+/* O_RVAL */		1,	UNARY,		0,
+/* O_INDEX */		2,	BINARY,		0,
+/* O_INDIR */		1,	UNARY,		"^",
+/* O_DOT */		2,	null,		".",
+/* O_COMMA */		2,	BINARY,		",",
+/* O_ITOF */		1,	UNARY|INTOP,	0,
+/* O_ADD */		2,	BINARY|INTOP,	"+",
+/* O_ADDF */		2,	BINARY|REALOP,	"+",
+/* O_SUB */		2,	BINARY|INTOP,	"-",
+/* O_SUBF */		2,	BINARY|REALOP,	"-",
+/* O_NEG */		1,	UNARY|INTOP,	"-",
+/* O_NEGF */		1,	UNARY|REALOP,	"-",
+/* O_MUL */		2,	BINARY|INTOP,	"*",
+/* O_MULF */		2,	BINARY|REALOP,	"*",
+/* O_DIVF */		2,	BINARY|REALOP,	"/",
+/* O_DIV */		2,	BINARY|INTOP,	" div ",
+/* O_MOD */		2,	BINARY|INTOP,	" mod ",
+/* O_AND */		2,	BINARY|INTOP,	" and ",
+/* O_OR */		2,	BINARY|INTOP,	" or ",
+/* O_LT */		2,	BINARY|INTOP,	" < ",
+/* O_LTF */		2,	BINARY|REALOP,	" < ",
+/* O_LE */		2,	BINARY|INTOP,	" <= ",
+/* O_LEF */		2,	BINARY|REALOP,	" <= ",
+/* O_GT */		2,	BINARY|INTOP,	" > ",
+/* O_GTF */		2,	BINARY|REALOP,	" > ",
+/* O_GE */		2,	BINARY|INTOP,	" >= ",
+/* O_GEF */		2,	BINARY|REALOP,	" >= ",
+/* O_EQ */		2,	BINARY|INTOP,	" = ",
+/* O_EQF */		2,	BINARY|REALOP,	" = ",
+/* O_NE */		2,	BINARY|INTOP,	" <> ",
+/* O_NEF */		2,	BINARY|REALOP,	" <> ",
+
+/* O_ALIAS */		2,	null,		"alias",
+/* O_ASSIGN */		2,	BINARY,		" := ",
+/* O_CALL */		2,	null,		"call",
+/* O_CATCH */		0,	null,		"catch",
+/* O_CHFILE */		0,	null,		"file",
+/* O_CONT */		0,	null,		"cont",
+/* O_DEBUG */		0,	null,		"debug",
+/* O_DELETE */		0,	null,		"delete",
+/* O_DUMP */		0,	null,		"dump",
+/* O_EDIT */		0,	null,		"edit",
+/* O_FUNC */		1,	null,		"func",
+/* O_GRIPE */		0,	null,		"gripe",
+/* O_HELP */		0,	null,		"help",
+/* O_IGNORE */		0,	null,		"ignore",
+/* O_LIST */		2,	null,		"list",
+/* O_PRINT */		1,	null,		"print",
+/* O_PSYM */		1,	null,		"psym",
+/* O_RUN */		0,	null,		"run",
+/* O_SKIP */		0,	null,		"skip",
+/* O_SOURCE */		0,	null,		"source",
+/* O_STATUS */		0,	null,		"status",
+/* O_STEP */		0,	null,		"step",
+/* O_STOP */		3,	null,		"stop",
+/* O_STOPI */		3,	null,		"stopi",
+/* O_TRACE */		3,	null,		"trace",
+/* O_TRACEI */		3,	null,		"tracei",
+/* O_WHATIS */		1,	null,		"whatis",
+/* O_WHERE */		0,	null,		"where",
+/* O_WHEREIS */		1,	null,		"whereis",
+/* O_WHICH */		1,	null,		"which",
+/* O_EXAMINE */		0,	null,		"examine",
+
+/* O_ADDEVENT */	0,	null,		"when",
+/* O_ENDX */		0,	null,		nil,
+/* O_IF */		0,	null,		"if",
+/* O_ONCE */		0,	null,		"once",
+/* O_PRINTCALL */	1,	null,		"printcall",
+/* O_PRINTIFCHANGED */	1,	null,		"printifchanged",
+/* O_PRINTRTN */	1,	null,		"printrtn",
+/* O_PRINTSRCPOS */	1,	null,		"printsrcpos",
+/* O_PROCRTN */		1,	null,		"procrtn",
+/* O_QLINE */		2,	null,		nil,
+/* O_STOPIFCHANGED */	1,	null,		"stopifchanged",
+/* O_STOPX */		0,	null,		"stop",
+/* O_TRACEON */		1,	null,		"traceon",
+/* O_TRACEOFF */	1,	null,		"traceoff",
+/* O_TYPERENAME */	2,	UNARY,		"traceoff",
+};
diff --git a/dbx/operators.h b/dbx/operators.h
new file mode 100644
index 0000000..ae393dc
--- /dev/null
+++ b/dbx/operators.h
@@ -0,0 +1,99 @@
+#ifndef operators_h
+#define operators_h
+typedef struct {
+    char numargs;
+    char opflags;
+    String opstring;
+} Opinfo;
+
+typedef enum {
+    O_NOP,
+    O_NAME, O_SYM, O_LCON, O_FCON, O_SCON,
+    O_RVAL, O_INDEX, O_INDIR, O_DOT,
+    O_COMMA,
+
+    O_ITOF, O_ADD, O_ADDF, O_SUB, O_SUBF, O_NEG, O_NEGF,
+    O_MUL, O_MULF, O_DIVF, O_DIV, O_MOD,
+
+    O_AND, O_OR,
+
+    O_LT, O_LTF, O_LE, O_LEF, O_GT, O_GTF, O_GE, O_GEF,
+    O_EQ, O_EQF, O_NE, O_NEF,
+
+    O_ALIAS,		/* rename a command */
+    O_ASSIGN,		/* assign a value to a program variable */
+    O_CALL,		/* call a procedure in the program */
+    O_CATCH,		/* catch a signal before program does */
+    O_CHFILE,		/* change (or print) the current source file */
+    O_CONT,		/* continue execution */
+    O_DEBUG,		/* invoke a dbx internal debugging routine */
+    O_DELETE,		/* remove a trace/stop */
+    O_DUMP,		/* dump out variables */
+    O_EDIT,		/* edit a file (or function) */
+    O_FUNC,		/* set the current function */
+    O_GRIPE,		/* send mail to debugger support person */
+    O_HELP,		/* print a synopsis of debugger commands */
+    O_IGNORE,		/* let program catch signal */
+    O_LIST,		/* list source lines */
+    O_PRINT,		/* print the values of a list of expressions */
+    O_PSYM,		/* print symbol information */
+    O_RUN,		/* start up program */
+    O_SKIP,		/* skip the current line */
+    O_SOURCE,		/* read commands from a file */
+    O_STATUS,		/* display currently active trace/stop's */
+    O_STEP,		/* execute a single line */
+    O_STOP,		/* stop on an event */
+    O_STOPI,		/* stop on an event at an instruction boundary */
+    O_TRACE,		/* trace something on an event */
+    O_TRACEI,		/* trace at the instruction level */
+    O_WHATIS,		/* print the declaration of a variable */
+    O_WHERE,		/* print a stack trace */
+    O_WHEREIS,		/* print all the symbols with the given name */
+    O_WHICH,		/* print out full qualification of a symbol */
+    O_EXAMINE,		/* examine program instructions/data */
+
+    O_ADDEVENT,		/* add an event */
+    O_ENDX,		/* end of program reached */
+    O_IF,		/* if first arg is true, do commands in second arg */
+    O_ONCE,		/* add a "one-time" event, delete when first reached */
+    O_PRINTCALL,	/* print out the current procedure and its arguments */
+    O_PRINTIFCHANGED,	/* print the value of the argument if it has changed */
+    O_PRINTRTN,		/* print out the routine and value that just returned */
+    O_PRINTSRCPOS,	/* print out the current source position */
+    O_PROCRTN,		/* CALLPROC completed */
+    O_QLINE,		/* filename, line number */
+    O_STOPIFCHANGED,	/* stop if the value of the argument has changed */
+    O_STOPX,		/* stop execution */
+    O_TRACEON,		/* begin tracing source line, variable, or all lines */
+    O_TRACEOFF,		/* end tracing source line, variable, or all lines */
+
+    O_TYPERENAME,	/* state the type of an expression */
+
+    O_LASTOP
+} Operator;
+
+/*
+ * Operator flags and predicates.
+ */
+
+#define null 0
+#define LEAF 01
+#define UNARY 02
+#define BINARY 04
+#define BOOL 010
+#define REALOP 020
+#define INTOP 040
+
+#define isbitset(a, m)	((a&m) == m)
+#define isleaf(o)	isbitset(opinfo[ord(o)].opflags, LEAF)
+#define isunary(o)	isbitset(opinfo[ord(o)].opflags, UNARY)
+#define isbinary(o)	isbitset(opinfo[ord(o)].opflags, BINARY)
+#define isreal(o)	isbitset(opinfo[ord(o)].opflags, REALOP)
+#define isint(o)	isbitset(opinfo[ord(o)].opflags, INTOP)
+#define isboolean(o)	isbitset(opinfo[ord(o)].opflags, BOOL)
+
+#define degree(o)	(opinfo[ord(o)].opflags&(LEAF|UNARY|BINARY))
+#define nargs(o)	(opinfo[ord(o)].numargs)
+
+Opinfo opinfo[] ;
+#endif
diff --git a/dbx/ops.c b/dbx/ops.c
new file mode 100644
index 0000000..6539236
--- /dev/null
+++ b/dbx/ops.c
@@ -0,0 +1,620 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)ops.c 1.3 12/18/82";
+
+/*
+ * Machine operators.
+ */
+
+#include "defs.h"
+#include "ops.h"
+
+#ifndef public
+typedef unsigned char VaxOpcode;
+
+#define O_HALT 0x00		/* halt */
+#define O_NOP 0x01		/* no operation */
+#define O_REI 0x02		/* return from exception or interrupt */
+#define O_BPT 0x03		/* break point fault */
+#define O_RET 0x04		/* return from called procedure */
+#define O_RSB 0x05		/* return from subroutine */
+#define O_LDPCTX 0x06		/* load process context */
+#define O_SVPCTX 0x07		/* save process context */
+#define O_CVTPS 0x08		/* convert packed to leading separate numeric */
+#define O_CVTSP 0x09		/* convert leading separate numeric to packed */
+#define O_INDEX 0x0A		/* compute index */
+#define O_CRC 0x0B		/* calculate cyclic redundancy check */
+#define O_PROBER 0x0C		/* probe read access */
+#define O_PROBEW 0x0D		/* probe write access */
+#define O_INSQUE 0x0E		/* insert into queue */
+#define O_REMQUE 0x0F		/* remove from queue */
+#define O_BSBB 0x10		/* branch to subroutine with byte disp */
+#define O_BRB 0x11		/* branch with byte disp */
+#define O_BNEQ 0x12		/* branch on not equal (also BNEQU) */
+#define O_BEQL 0x13		/* branch on equal (also BEQLU */
+#define O_BGTR 0x14		/* branch on greater */
+#define O_BLEQ 0x15		/* branch on less or equal */
+#define O_JSB 0x16		/* jump to subroutine */
+#define O_JMP 0x17		/* jump */
+#define O_BGEQ 0x18		/* branch on greater or equal */
+#define O_BLSS 0x19		/* branch on less */
+#define O_BGTRU 0x1A		/* branch on greater unsigned */
+#define O_BLEQU 0x1B		/* branch on less of equal unsigned */
+#define O_BVC 0x1C		/* branch on overflow clear */
+#define O_BVS 0x1D		/* branch on overflow set */
+#define O_BCC 0x1E		/* branch on carry clear (also BGEQU) */
+#define O_BCS 0x1F		/* branch on carry set (also BLSSU) */
+#define O_ADDP4 0x20		/* add packed 4 operand */
+#define O_ADDP6 0x21		/* add packed 6 operand */
+#define O_SUBP4 0x22		/* subtract packed 4 operand */
+#define O_SUBP6 0x23		/* subtract packed 6 operand */
+#define O_CVTPT 0x24		/* convert packed to trailing numeric */
+#define O_MULP 0x25		/* multiply packed */
+#define O_CVTTP 0x26		/* convert trailing numeric to packed */
+#define O_DIVP 0x27		/* divide packed */
+#define O_MOVC3 0x28		/* move character 3 operand */
+#define O_CMPC3 0x29		/* compare character 3 operand */
+#define O_SCANC 0x2A		/* scan for character */
+#define O_SPANC 0x2B		/* span characters */
+#define O_MOVC5 0x2C		/* move character 5 operand */
+#define O_CMPC5 0x2D		/* compare character 5 operand */
+#define O_MOVTC 0x2E		/* move translated characters */
+#define O_MOVTUC 0x2F		/* move translated until character */
+#define O_BSBW 0x30		/* branch to subroutine with word disp */
+#define O_BRW 0x31		/* branch with word disp */
+#define O_CVTWL 0x32		/* convert word to long */
+#define O_CVTWB 0x33		/* convert word to byte */
+#define O_MOVP 0x34		/* move packed */
+#define O_CMPP3 0x35		/* compare packed 3 operand */
+#define O_CVTPL 0x36		/* convert packed to long */
+#define O_CMPP4 0x37		/* compare packed 4 operand */
+#define O_EDITPC 0x38		/* edit packed to character */
+#define O_MATCHC 0x39		/* match characters */
+#define O_LOCC 0x3A		/* locate characters */
+#define O_SKPC 0x3B		/* skip character */
+#define O_MOVZWL 0x3C		/* move zero-extended word to long */
+#define O_ACBW 0x3D		/* add compare and branch word */
+#define O_MOVAW 0x3E		/* move address of word */
+#define O_PUSHAW 0x3F		/* push address of word */
+#define O_ADDF2 0x40		/* add floating 2 operand */
+#define O_ADDF3 0x41		/* add floating 3 operand */
+#define O_SUBF2 0x42		/* subtract floating 2 operand */
+#define O_SUBF3 0x43		/* subtract floating 3 operand */
+#define O_MULF2 0x44		/* multiply floating 2 operand */
+#define O_MULF3 0x45		/* multiply floating 3 operand */
+#define O_DIVF2 0x46		/* divide floating 2 operand */
+#define O_DIVF3 0x47		/* divide floating 3 operand */
+#define O_CVTFB 0x48		/* convert float to byte */
+#define O_CVTFW 0x49		/* convert float to word */
+#define O_CVTFL 0x4A		/* convert float to long */
+#define O_CVTRFL 0x4B		/* convert rounded float to long */
+#define O_CVTBF 0x4C		/* convert byte to float */
+#define O_CVTWF 0x4D		/* convert word to float */
+#define O_CVTLF 0x4E		/* convert long to float */
+#define O_ACBF 0x4F		/* add compare and branch floating */
+#define O_MOVF 0x50		/* move float */
+#define O_CMPF 0x51		/* compare floating */
+#define O_MNEGF 0x52		/* move negated floating */
+#define O_TSTF 0x53		/* test float */
+#define O_EMODF 0x54		/* extended modulus floating */
+#define O_POLYF 0x55		/* evaluate polynomial floating */
+#define O_CVTFD 0x56		/* convert float to double */
+#define O_DUMMY57 0x57		/* RESERVED to DIGITAL */
+#define O_ADAWI 0x58		/* add aligned word interlocked */
+#define O_DUMMY59 0x59		/* RESERVED to DIGITAL */
+#define O_DUMMY5a 0x5A		/* RESERVED to DIGITAL */
+#define O_DUMMY5b 0x5B		/* RESERVED to DIGITAL */
+#define O_INSQHI 0x5C		/* insert into queue head, interlocked */
+#define O_INSQTI 0x5D		/* insert into queue tail, interlocked */
+#define O_REMQHI 0x5E		/* remove from queue head, interlocked */
+#define O_REMQTI 0x5F		/* remove from queue tail, interlocked */
+#define O_ADDD2 0x60		/* add double 2 operand */
+#define O_ADDD3 0x61		/* add double 3 operand */
+#define O_SUBD2 0x62		/* subtract double 2 operand */
+#define O_SUBD3 0x63		/* subtrace double 3 operand */
+#define O_MULD2 0x64		/* multiply double 2 operand */
+#define O_MULD3 0x65		/* multiply double 3 operand */
+#define O_DIVD2 0x66		/* divide double 2 operand */
+#define O_DIVD3 0x67		/* divide double 3 operand */
+#define O_CVTDB 0x68		/* convert double to byte */
+#define O_CVTDW 0x69		/* convert double to word */
+#define O_CVTDL 0x6A		/* convert double to long */
+#define O_CVTRDL 0x6B		/* convert rounded double to long */
+#define O_CVTBD 0x6C		/* convert byte to double */
+#define O_CVTWD 0x6D		/* convert word to double */
+#define O_CVTLD 0x6E		/* convert long to double */
+#define O_ACBD 0x6F		/* add compare and branch double */
+#define O_MOVD 0x70		/* move double */
+#define O_CMPD 0x71		/* compare double */
+#define O_MNEGD 0x72		/* move negated double */
+#define O_TSTD 0x73		/* test double */
+#define O_EMODD 0x74		/* extended modulus double */
+#define O_POLYD 0x75		/* evaluate polynomial double */
+#define O_CVTDF 0x76		/* convert double to float */
+#define O_DUMMY77 0x77		/* RESERVED to DIGITAL */
+#define O_ASHL 0x78		/* arithmetic shift long */
+#define O_ASHQ 0x79		/* arithmetic shift quad */
+#define O_EMUL 0x7A		/* extended multiply */
+#define O_EDIV 0x7B		/* extended divide */
+#define O_CLRQ 0x7C		/* clear quad (also CLRD) */
+#define O_MOVQ 0x7D		/* move quad */
+#define O_MOVAQ 0x7E		/* move address of quad (also MOVAD) */
+#define O_PUSHAQ 0x7F		/* push address of quad (also PUSHAD) */
+#define O_ADDB2 0x80		/* add byte 2 operand */
+#define O_ADDB3 0x81		/* add byte 3 operand */
+#define O_SUBB2 0x82		/* subtract byte 2 operand */
+#define O_SUBB3 0x83		/* subtract byte 3 operand */
+#define O_MULB2 0x84		/* multiply byte 2 operand */
+#define O_MULB3 0x85		/* multiply byte 3 operand */
+#define O_DIVB2 0x86		/* divide byte 2 operand */
+#define O_DIVB3 0x87		/* divide byte 3 operand */
+#define O_BISB2 0x88		/* bit set byte 2 operand */
+#define O_BISB3 0x89		/* bit set byte 3 operand */
+#define O_BICB2 0x8A		/* bit clear byte 2 operand */
+#define O_BICB3 0x8B		/* bit clear byte 3 operand */
+#define O_XORB2 0x8C		/* exclusive or byte 2 operand */
+#define O_XORB3 0x8D		/* exclusive or byte 3 operand */
+#define O_MNEGB 0x8E		/* move negated byte */
+#define O_CASEB 0x8F		/* case byte */
+#define O_MOVB 0x90		/* move byte */
+#define O_CMPB 0x91		/* compare byte */
+#define O_MCOMB 0x92		/* move complemented byte */
+#define O_BITB 0x93		/* bit test byte */
+#define O_CLRB 0x94		/* clear byte */
+#define O_TSTB 0x95		/* test byte */
+#define O_INCB 0x96		/* increment byte */
+#define O_DECB 0x97		/* decrement byte */
+#define O_CVTBL 0x98		/* convert byte to long */
+#define O_CVTBW 0x99		/* convert byte to word */
+#define O_MOVZBL 0x9A		/* move zero-extended byte to long */
+#define O_MOVZBW 0x9B		/* move zero-extended byte to word */
+#define O_ROTL 0x9C		/* rotate long */
+#define O_ACBB 0x9D		/* add compare and branch byte */
+#define O_MOVAB 0x9E		/* move address of byte */
+#define O_PUSHAB 0x9F		/* push address of byte */
+#define O_ADDW2 0xA0		/* add word 2 operand */
+#define O_ADDW3 0xA1		/* add word 3 operand */
+#define O_SUBW2 0xA2		/* subtract word 2 operand */
+#define O_SUBW3 0xA3		/* subtract word 3 operand */
+#define O_MULW2 0xA4		/* multiply word 2 operand */
+#define O_MULW3 0xA5		/* multiply word 3 operand */
+#define O_DIVW2 0xA6		/* divide word 2 operand */
+#define O_DIVW3 0xA7		/* divide word 3 operand */
+#define O_BISW2 0xA8		/* bit set word 2 operand */
+#define O_BISW3 0xA9		/* bit set word 3 operand */
+#define O_BICW2 0xAA		/* bit clear word 2 operand */
+#define O_BICW3 0xAB		/* bit clear word 3 operand */
+#define O_XORW2 0xAC		/* exclusive or word 2 operand */
+#define O_XORW3 0xAD		/* exclusive or word 3 operand */
+#define O_MNEGW 0xAE		/* move negated word */
+#define O_CASEW 0xAF		/* case word */
+#define O_MOVW 0xB0		/* move word */
+#define O_CMPW 0xB1		/* compare word */
+#define O_MCOMW 0xB2		/* move complemented word */
+#define O_BITW 0xB3		/* bit test word */
+#define O_CLRW 0xB4		/* clear word */
+#define O_TSTW 0xB5		/* test word */
+#define O_INCW 0xB6		/* increment word */
+#define O_DECW 0xB7		/* decrement word */
+#define O_BISPSW 0xB8		/* bit set processor status word */
+#define O_BICPSW 0xB9		/* bit clear processor status word */
+#define O_POPR 0xBA		/* pop register */
+#define O_PUSHR 0xBB		/* push register */
+#define O_CHMK 0xBC		/* change mode to kernel */
+#define O_CHME 0xBD		/* change mode to executive */
+#define O_CHMS 0xBE		/* change mode to supervisor */
+#define O_CHMU 0xBF		/* change mode to user */
+#define O_ADDL2 0xC0		/* add long 2 operand */
+#define O_ADDL3 0xC1		/* add long 3 operand */
+#define O_SUBL2 0xC2		/* subtract long 2 operand */
+#define O_SUBL3 0xC3		/* subtract long 3 operand */
+#define O_MULL2 0xC4		/* multiply long 2 operand */
+#define O_MULL3 0xC5		/* multiply long 3 operand */
+#define O_DIVL2 0xC6		/* divide long 2 operand */
+#define O_DIVL3 0xC7		/* divide long 3 operand */
+#define O_BISL2 0xC8		/* bit set long 2 operand */
+#define O_BISL3 0xC9		/* bit set long 3 operand */
+#define O_BICL2 0xCA		/* bit clear long 2 operand */
+#define O_BICL3 0xCB		/* bit clear long 3 operand */
+#define O_XORL2 0xCC		/* exclusive or long 2 operand */
+#define O_XORL3 0xCD		/* exclusive or long 3 operand */
+#define O_MNEGL 0xCE		/* move negated long */
+#define O_CASEL 0xCF		/* case long */
+#define O_MOVL 0xD0		/* move long */
+#define O_CMPL 0xD1		/* compare long */
+#define O_MCOML 0xD2		/* move complemented long */
+#define O_BITL 0xD3		/* bit test long */
+#define O_CLRL 0xD4		/* clear long (also CLRF) */
+#define O_TSTL 0xD5		/* test long */
+#define O_INCL 0xD6		/* increment long */
+#define O_DECL 0xD7		/* decrement long */
+#define O_ADWC 0xD8		/* add with carry */
+#define O_SBWC 0xD9		/* subtrace with carry */
+#define O_MTPR 0xDA		/* move to processor register */
+#define O_MFPR 0xDB		/* move from processor register */
+#define O_MOVPSL 0xDC		/* move processor status longword */
+#define O_PUSHL 0xDD		/* push long */
+#define O_MOVAL 0xDE		/* move address of long (also MOVAF) */
+#define O_PUSHAL 0xDF		/* push address of long (also PUSHAF) */
+#define O_BBS 0xE0		/* branch on bit set */
+#define O_BBC 0xE1		/* branch on bit clear */
+#define O_BBSS 0xE2		/* branch on bit set and set */
+#define O_BBCS 0xE3		/* branch on bit clear and set */
+#define O_BBSC 0xE4		/* branch on bit set and clear */
+#define O_BBCC 0xE5		/* branch on bit clear and clear */
+#define O_BBSSI 0xE6		/* branch on bit set and set interlocked */
+#define O_BBCCI 0xE7		/* branch on bit clear and clear interlocked */
+#define O_BLBS 0xE8		/* branch on low bit set */
+#define O_BLBC 0xE9		/* branch on low bit clear */
+#define O_FFS 0xEA		/* find first set bit */
+#define O_FFC 0xEB		/* find first clear bit */
+#define O_CMPV 0xEC		/* compare field */
+#define O_CMPZV 0xED		/* compare zero-extended field */
+#define O_EXTV 0xEE		/* extract field */
+#define O_EXTZV 0xEF		/* extract zero-extended field */
+#define O_INSV 0xF0		/* insert field */
+#define O_ACBL 0xF1		/* add compare and branch long */
+#define O_AOBLSS 0xF2		/* add one and branch on less */
+#define O_AOBLEQ 0xF3		/* add one and branch on less or equal */
+#define O_SOBGEQ 0xF4		/* subtract one and branch on gtr or equal */
+#define O_SOBGTR 0xF5		/* subtract one and branch on greater */
+#define O_CVTLB 0xF6		/* convert long to byte */
+#define O_CVTLW 0xF7		/* convert long to word */
+#define O_ASHP 0xF8		/* arithmetic shift and round packed */
+#define O_CVTLP 0xF9		/* convert long to packed */
+#define O_CALLG 0xFA		/* call with general argument list */
+#define O_CALLS 0xFB		/* call with stack */
+#define O_XFC 0xFC		/* extended function call */
+#define O_ESCD 0xFD		/* ESCD to DIGITAL */
+#define O_ESCE 0xFE		/* ESCE to DIGITAL */
+#define O_ESCF 0xFF		/* ESCF to DIGITAL */
+
+/*
+ * Opcode definitions.
+ *
+ * Much of this was taken from the assembler.
+ */
+
+/*
+ * Argument access types.
+ */
+
+#define ACCA    0100    /* address only */
+#define ACCR    010	/* read */
+#define ACCW    020	/* write */
+#define ACCM    030	/* modify */
+#define ACCB    040	/* branch displacement */
+#define ACCI    050	/* variable field */
+
+/*
+ * Argument lengths.
+ */
+
+#define TYPB    0	/* byte */
+#define TYPW    01	/* word */
+#define TYPL    02	/* long */
+#define TYPQ    03	/* quad */
+#define TYPF    04	/* floating */
+#define TYPD    05	/* double floating */
+
+/*
+ * Addressing modes.
+ */
+
+#define LITSHORT    0x0	/* short literals */
+#define LITUPTO31   0x1
+#define LITUPTO47   0x2
+#define LITUPTO63   0x3
+#define INDEX       0x4 /* i[r] */
+#define REG	    0x5 /* r */
+#define REGDEF      0x6 /* (r) */
+#define AUTODEC     0x7 /* -(r) */
+#define AUTOINC     0x8 /* (r)+ */
+#define AUTOINCDEF  0x9 /* *(r)+ */
+#define BYTEDISP    0xA /* BD(r) */
+#define BYTEDISPDEF 0xB /* *BD(r) */
+#define WORDDISP    0xC /* WD(r) */
+#define WORDDISPDEF 0xD /* *WD(r) */
+#define LONGDISP    0xE /* LD(r) */
+#define LONGDISPDEF 0xF /* *LD(r) */
+
+#define is_branch_disp(arg) ((arg & ACCB) != 0)
+#define typelen(arg)        (arg & 07)
+#define regnm(mode)	    (mode & 0xF)
+#define addrmode(mode)      (mode >> 4)
+
+/*
+ * Operator information structure.
+ */
+
+typedef struct {
+    char *iname;
+    char val;
+    char numargs;
+    char argtype[6];
+} Optab;
+
+#endif
+
+public Optab optab[] = {
+    {"halt", 0x00, 0, 0, 0, 0, 0, 0, 0}, 
+    {"nop", 0x01, 0, 0, 0, 0, 0, 0, 0}, 
+    {"rei", 0x02, 0, 0, 0, 0, 0, 0, 0}, 
+    {"bpt", 0x03, 0, 0, 0, 0, 0, 0, 0}, 
+    {"ret", 0x04, 0, 0, 0, 0, 0, 0, 0}, 
+    {"rsb", 0x05, 0, 0, 0, 0, 0, 0, 0}, 
+    {"ldpctx", 0x06, 0, 0, 0, 0, 0, 0, 0}, 
+    {"svpctx", 0x07, 0, 0, 0, 0, 0, 0, 0}, 
+    {"cvtps", 0x08, 4, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0}, 
+    {"cvtsp", 0x09, 4, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0}, 
+    {"index", 0x0a, 6, ACCR+TYPL, ACCR+TYPL, ACCR+TYPL, ACCR+TYPL, ACCR+TYPL, ACCW+TYPL}, 
+    {"crc", 0x0b, 4, ACCA+TYPB, ACCR+TYPL, ACCR+TYPW, ACCA+TYPB, 0, 0}, 
+    {"prober", 0x0c, 3, ACCR+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0, 0}, 
+    {"probew", 0x0d, 3, ACCR+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0, 0}, 
+    {"insque", 0x0e, 2, ACCA+TYPB, ACCA+TYPB, 0, 0, 0, 0}, 
+    {"remque", 0x0f, 2, ACCA+TYPB, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"bsbb", 0x10, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"brb", 0x11, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"bneq", 0x12, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"beql", 0x13, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"bgtr", 0x14, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"bleq", 0x15, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"jsb", 0x16, 1, ACCA+TYPB, 0, 0, 0, 0, 0}, 
+    {"jmp", 0x17, 1, ACCA+TYPB, 0, 0, 0, 0, 0}, 
+    {"bgeq", 0x18, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"blss", 0x19, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"bgtru", 0x1a, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"blequ", 0x1b, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"bvc", 0x1c, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"bvs", 0x1d, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"bcc", 0x1e, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"bcs", 0x1f, 1, ACCB+TYPB, 0, 0, 0, 0, 0}, 
+    {"addp4", 0x20, 4, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0}, 
+    {"addp6", 0x21, 6, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB}, 
+    {"subp4", 0x22, 4, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0}, 
+    {"subp6", 0x23, 6, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB}, 
+    {"cvtpt", 0x24, 5, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, 0}, 
+    {"mulp", 0x25, 6, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB}, 
+    {"cvttp", 0x26, 5, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, 0}, 
+    {"divp", 0x27, 6, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB}, 
+    {"movc3", 0x28, 3, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, 0, 0, 0}, 
+    {"cmpc3", 0x29, 3, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, 0, 0, 0}, 
+    {"scanc", 0x2a, 4, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, ACCR+TYPB, 0, 0}, 
+    {"spanc", 0x2b, 4, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, ACCR+TYPB, 0, 0}, 
+    {"movc5", 0x2c, 5, ACCR+TYPW, ACCA+TYPB, ACCR+TYPB, ACCR+TYPW, ACCA+TYPB, 0}, 
+    {"cmpc5", 0x2d, 5, ACCR+TYPW, ACCA+TYPB, ACCR+TYPB, ACCR+TYPW, ACCA+TYPB, 0}, 
+    {"movtc", 0x2e, 6, ACCR+TYPW, ACCA+TYPB, ACCR+TYPB, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB}, 
+    {"movtuc", 0x2f, 6, ACCR+TYPW, ACCA+TYPB, ACCR+TYPB, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB}, 
+    {"bsbw", 0x30, 1, ACCB+TYPW, 0, 0, 0, 0, 0}, 
+    {"brw", 0x31, 1, ACCB+TYPW, 0, 0, 0, 0, 0}, 
+    {"cvtwl", 0x32, 2, ACCR+TYPW, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"cvtwb", 0x33, 2, ACCR+TYPW, ACCW+TYPB, 0, 0, 0, 0}, 
+    {"movp", 0x34, 3, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, 0, 0, 0}, 
+    {"cmpp3", 0x35, 3, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, 0, 0, 0}, 
+    {"cvtpl", 0x36, 3, ACCR+TYPW, ACCA+TYPB, ACCW+TYPL, 0, 0, 0}, 
+    {"cmpp4", 0x37, 4, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0}, 
+    {"editpc", 0x38, 4, ACCR+TYPW, ACCA+TYPB, ACCA+TYPB, ACCA+TYPB, 0, 0}, 
+    {"matchc", 0x39, 4, ACCR+TYPW, ACCA+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0}, 
+    {"locc", 0x3a, 3, ACCR+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0, 0}, 
+    {"skpc", 0x3b, 3, ACCR+TYPB, ACCR+TYPW, ACCA+TYPB, 0, 0, 0}, 
+    {"movzwl", 0x3c, 2, ACCR+TYPW, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"acbw", 0x3d, 4, ACCR+TYPW, ACCR+TYPW, ACCM+TYPW, ACCB+TYPW, 0, 0}, 
+    {"movaw", 0x3e, 2, ACCA+TYPW, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"pushaw", 0x3f, 1, ACCA+TYPW, 0, 0, 0, 0, 0}, 
+    {"addf2", 0x40, 2, ACCR+TYPF, ACCM+TYPF, 0, 0, 0, 0}, 
+    {"addf3", 0x41, 3, ACCR+TYPF, ACCR+TYPF, ACCW+TYPF, 0, 0, 0}, 
+    {"subf2", 0x42, 2, ACCR+TYPF, ACCM+TYPF, 0, 0, 0, 0}, 
+    {"subf3", 0x43, 3, ACCR+TYPF, ACCR+TYPF, ACCW+TYPF, 0, 0, 0}, 
+    {"mulf2", 0x44, 2, ACCR+TYPF, ACCM+TYPF, 0, 0, 0, 0}, 
+    {"mulf3", 0x45, 3, ACCR+TYPF, ACCR+TYPF, ACCW+TYPF, 0, 0, 0}, 
+    {"divf2", 0x46, 2, ACCR+TYPF, ACCM+TYPF, 0, 0, 0, 0}, 
+    {"divf3", 0x47, 3, ACCR+TYPF, ACCR+TYPF, ACCW+TYPF, 0, 0, 0}, 
+    {"cvtfb", 0x48, 2, ACCR+TYPF, ACCW+TYPB, 0, 0, 0, 0}, 
+    {"cvtfw", 0x49, 2, ACCR+TYPF, ACCW+TYPW, 0, 0, 0, 0}, 
+    {"cvtfl", 0x4a, 2, ACCR+TYPF, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"cvtrfl", 0x4b, 2, ACCR+TYPF, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"cvtbf", 0x4c, 2, ACCR+TYPB, ACCW+TYPB, 0, 0, 0, 0}, 
+    {"cvtwf", 0x4d, 2, ACCR+TYPW, ACCW+TYPF, 0, 0, 0, 0}, 
+    {"cvtlf", 0x4e, 2, ACCR+TYPL, ACCW+TYPF, 0, 0, 0, 0}, 
+    {"acbf", 0x4f, 4, ACCR+TYPF, ACCR+TYPF, ACCM+TYPF, ACCB+TYPW, 0, 0}, 
+    {"movf", 0x50, 2, ACCR+TYPF, ACCW+TYPF, 0, 0, 0, 0}, 
+    {"cmpf", 0x51, 2, ACCR+TYPF, ACCR+TYPF, 0, 0, 0, 0}, 
+    {"mnegf", 0x52, 2, ACCR+TYPF, ACCW+TYPF, 0, 0, 0, 0}, 
+    {"tstf", 0x53, 1, ACCR+TYPF, 0, 0, 0, 0, 0}, 
+    {"emodf", 0x54, 5, ACCR+TYPF, ACCR+TYPB, ACCR+TYPF, ACCW+TYPL, ACCW+TYPF, 0}, 
+    {"polyf", 0x55, 3, ACCR+TYPF, ACCR+TYPW, ACCA+TYPB, 0, 0, 0}, 
+    {"cvtfd", 0x56, 2, ACCR+TYPF, ACCW+TYPD, 0, 0, 0, 0}, 
+    {"dummy", 0x57, 0, 0, 0, 0, 0, 0, 0},
+    {"adawi", 0x58, 2, ACCR+TYPW, ACCM+TYPW, 0, 0, 0, 0}, 
+    {"dummy", 0x59, 0, 0, 0, 0, 0, 0, 0},
+    {"dummy", 0x5a, 0, 0, 0, 0, 0, 0, 0},
+    {"dummy", 0x5b, 0, 0, 0, 0, 0, 0, 0},
+    {"dummy", 0x5c, 0, 0, 0, 0, 0, 0, 0},
+    {"dummy", 0x5d, 0, 0, 0, 0, 0, 0, 0},
+    {"dummy", 0x5e, 0, 0, 0, 0, 0, 0, 0},
+    {"dummy", 0x5f, 0, 0, 0, 0, 0, 0, 0},
+    {"addd2", 0x60, 2, ACCR+TYPD, ACCM+TYPD, 0, 0, 0, 0}, 
+    {"addd3", 0x61, 3, ACCR+TYPD, ACCR+TYPD, ACCW+TYPD, 0, 0, 0}, 
+    {"subd2", 0x62, 2, ACCR+TYPD, ACCM+TYPD, 0, 0, 0, 0}, 
+    {"subd3", 0x63, 3, ACCR+TYPD, ACCR+TYPD, ACCW+TYPD, 0, 0, 0}, 
+    {"muld2", 0x64, 2, ACCR+TYPD, ACCM+TYPD, 0, 0, 0, 0}, 
+    {"muld3", 0x65, 3, ACCR+TYPD, ACCR+TYPD, ACCW+TYPD, 0, 0, 0}, 
+    {"divd2", 0x66, 2, ACCR+TYPD, ACCM+TYPD, 0, 0, 0, 0}, 
+    {"divd3", 0x67, 3, ACCR+TYPD, ACCR+TYPD, ACCR+TYPD, 0, 0, 0}, 
+    {"cvtdb", 0x68, 2, ACCR+TYPD, ACCW+TYPB, 0, 0, 0, 0}, 
+    {"cvtdw", 0x69, 2, ACCR+TYPD, ACCW+TYPW, 0, 0, 0, 0}, 
+    {"cvtdl", 0x6a, 2, ACCR+TYPD, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"cvtrdl", 0x6b, 2, ACCR+TYPD, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"cvtbd", 0x6c, 2, ACCR+TYPB, ACCW+TYPD, 0, 0, 0, 0}, 
+    {"cvtwd", 0x6d, 2, ACCR+TYPW, ACCW+TYPD, 0, 0, 0, 0}, 
+    {"cvtld", 0x6e, 2, ACCR+TYPL, ACCW+TYPD, 0, 0, 0, 0}, 
+    {"acbd", 0x6f, 4, ACCR+TYPD, ACCR+TYPD, ACCM+TYPD, ACCB+TYPW, 0, 0}, 
+    {"movd", 0x70, 2, ACCR+TYPD, ACCW+TYPD, 0, 0, 0, 0}, 
+    {"cmpd", 0x71, 2, ACCR+TYPD, ACCR+TYPD, 0, 0, 0, 0}, 
+    {"mnegd", 0x72, 2, ACCR+TYPD, ACCW+TYPD, 0, 0, 0, 0}, 
+    {"tstd", 0x73, 1, ACCR+TYPD, 0, 0, 0, 0, 0}, 
+    {"emodd", 0x74, 5, ACCR+TYPD, ACCR+TYPB, ACCR+TYPD, ACCW+TYPL, ACCW+TYPD, 0}, 
+    {"polyd", 0x75, 3, ACCR+TYPD, ACCR+TYPW, ACCA+TYPB, 0, 0, 0}, 
+    {"cvtdf", 0x76, 2, ACCR+TYPD, ACCW+TYPF, 0, 0, 0, 0}, 
+    {"dummy0x77", 0x77, 0, 0, 0, 0, 0, 0, 0},
+    {"ashl", 0x78, 3, ACCR+TYPB, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"ashq", 0x79, 3, ACCR+TYPB, ACCR+TYPQ, ACCW+TYPQ, 0, 0, 0}, 
+    {"emul", 0x7a, 4, ACCR+TYPL, ACCR+TYPL, ACCR+TYPL, ACCW+TYPQ, 0, 0}, 
+    {"ediv", 0x7b, 4, ACCR+TYPL, ACCR+TYPQ, ACCW+TYPL, ACCW+TYPL, 0, 0}, 
+    {"clrq", 0x7c, 1, ACCW+TYPD, 0, 0, 0, 0, 0}, 
+    {"movq", 0x7d, 2, ACCR+TYPQ, ACCW+TYPQ, 0, 0, 0, 0}, 
+    {"movaq", 0x7e, 2, ACCA+TYPQ, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"pushaq", 0x7f, 1, ACCA+TYPQ, 0, 0, 0, 0, 0}, 
+    {"addb2", 0x80, 2, ACCR+TYPB, ACCM+TYPB, 0, 0, 0, 0}, 
+    {"addb3", 0x81, 3, ACCR+TYPB, ACCR+TYPB, ACCW+TYPB, 0, 0, 0}, 
+    {"subb2", 0x82, 2, ACCR+TYPB, ACCM+TYPB, 0, 0, 0, 0}, 
+    {"subb3", 0x83, 3, ACCR+TYPB, ACCR+TYPB, ACCW+TYPB, 0, 0, 0}, 
+    {"mulb2", 0x84, 2, ACCR+TYPB, ACCM+TYPB, 0, 0, 0, 0}, 
+    {"mulb3", 0x85, 3, ACCR+TYPB, ACCR+TYPB, ACCW+TYPB, 0, 0, 0}, 
+    {"divb2", 0x86, 2, ACCR+TYPB, ACCM+TYPB, 0, 0, 0, 0}, 
+    {"divb3", 0x87, 3, ACCR+TYPB, ACCR+TYPB, ACCW+TYPB, 0, 0, 0}, 
+    {"bisb2", 0x88, 2, ACCR+TYPB, ACCM+TYPB, 0, 0, 0, 0}, 
+    {"bisb3", 0x89, 3, ACCR+TYPB, ACCR+TYPB, ACCW+TYPB, 0, 0, 0}, 
+    {"bicb2", 0x8a, 2, ACCR+TYPB, ACCM+TYPB, 0, 0, 0, 0}, 
+    {"bicb3", 0x8b, 3, ACCR+TYPB, ACCR+TYPB, ACCW+TYPB, 0, 0, 0}, 
+    {"xorb2", 0x8c, 2, ACCR+TYPB, ACCM+TYPB, 0, 0, 0, 0}, 
+    {"xorb3", 0x8d, 3, ACCR+TYPB, ACCR+TYPB, ACCW+TYPB, 0, 0, 0}, 
+    {"mnegb", 0x8e, 2, ACCR+TYPB, ACCW+TYPB, 0, 0, 0, 0}, 
+    {"caseb", 0x8f, 3, ACCR+TYPB, ACCR+TYPB, ACCR+TYPB, 0, 0, 0}, 
+    {"movb", 0x90, 2, ACCR+TYPB, ACCW+TYPB, 0, 0, 0, 0}, 
+    {"cmpb", 0x91, 2, ACCR+TYPB, ACCR+TYPB, 0, 0, 0, 0}, 
+    {"mcomb", 0x92, 2, ACCR+TYPB, ACCW+TYPB, 0, 0, 0, 0}, 
+    {"bitb", 0x93, 2, ACCR+TYPB, ACCR+TYPB, 0, 0, 0, 0}, 
+    {"clrb", 0x94, 1, ACCW+TYPB, 0, 0, 0, 0, 0}, 
+    {"tstb", 0x95, 1, ACCR+TYPB, 0, 0, 0, 0, 0}, 
+    {"incb", 0x96, 1, ACCM+TYPB, 0, 0, 0, 0, 0}, 
+    {"decb", 0x97, 1, ACCM+TYPB, 0, 0, 0, 0, 0}, 
+    {"cvtbl", 0x98, 2, ACCR+TYPB, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"cvtbw", 0x99, 2, ACCR+TYPB, ACCW+TYPW, 0, 0, 0, 0}, 
+    {"movzbl", 0x9a, 2, ACCR+TYPB, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"movzbw", 0x9b, 2, ACCR+TYPB, ACCW+TYPW, 0, 0, 0, 0}, 
+    {"rotl", 0x9c, 3, ACCR+TYPB, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"acbb", 0x9d, 4, ACCR+TYPB, ACCR+TYPB, ACCM+TYPB, ACCB+TYPW, 0, 0}, 
+    {"movab", 0x9e, 2, ACCA+TYPB, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"pushab", 0x9f, 1, ACCA+TYPB, 0, 0, 0, 0, 0}, 
+    {"addw2", 0xa0, 2, ACCR+TYPW, ACCM+TYPW, 0, 0, 0, 0}, 
+    {"addw3", 0xa1, 3, ACCR+TYPW, ACCR+TYPW, ACCW+TYPW, 0, 0, 0}, 
+    {"subw2", 0xa2, 2, ACCR+TYPW, ACCM+TYPW, 0, 0, 0, 0}, 
+    {"subw3", 0xa3, 3, ACCR+TYPW, ACCR+TYPW, ACCW+TYPW, 0, 0, 0}, 
+    {"mulw2", 0xa4, 2, ACCR+TYPW, ACCM+TYPW, 0, 0, 0, 0}, 
+    {"mulw3", 0xa5, 3, ACCR+TYPW, ACCR+TYPW, ACCW+TYPW, 0, 0, 0}, 
+    {"divw2", 0xa6, 2, ACCR+TYPW, ACCM+TYPW, 0, 0, 0, 0}, 
+    {"divw3", 0xa7, 3, ACCR+TYPW, ACCR+TYPW, ACCW+TYPW, 0, 0, 0}, 
+    {"bisw2", 0xa8, 2, ACCR+TYPW, ACCM+TYPW, 0, 0, 0, 0}, 
+    {"bisw3", 0xa9, 3, ACCR+TYPW, ACCR+TYPW, ACCW+TYPW, 0, 0, 0}, 
+    {"bicw2", 0xaa, 2, ACCR+TYPW, ACCM+TYPW, 0, 0, 0, 0}, 
+    {"bicw3", 0xab, 3, ACCR+TYPW, ACCR+TYPW, ACCW+TYPW, 0, 0, 0}, 
+    {"xorw2", 0xac, 2, ACCR+TYPW, ACCM+TYPW, 0, 0, 0, 0}, 
+    {"xorw3", 0xad, 3, ACCR+TYPW, ACCR+TYPW, ACCW+TYPW, 0, 0, 0}, 
+    {"mnegw", 0xae, 2, ACCR+TYPW, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"casew", 0xaf, 3, ACCR+TYPW, ACCR+TYPW, ACCR+TYPW, 0, 0, 0}, 
+    {"movw", 0xb0, 2, ACCR+TYPW, ACCW+TYPW, 0, 0, 0, 0}, 
+    {"cmpw", 0xb1, 2, ACCR+TYPW, ACCR+TYPW, 0, 0, 0, 0}, 
+    {"mcomw", 0xb2, 2, ACCR+TYPW, ACCW+TYPW, 0, 0, 0, 0}, 
+    {"bitw", 0xb3, 2, ACCR+TYPW, ACCR+TYPW, 0, 0, 0, 0}, 
+    {"clrw", 0xb4, 1, ACCW+TYPW, 0, 0, 0, 0, 0}, 
+    {"tstw", 0xb5, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"incw", 0xb6, 1, ACCM+TYPW, 0, 0, 0, 0, 0}, 
+    {"decw", 0xb7, 1, ACCM+TYPW, 0, 0, 0, 0, 0}, 
+    {"bispsw", 0xb8, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"bicpsw", 0xb9, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"popr", 0xba, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"pushr", 0xbb, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"chmk", 0xbc, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"chme", 0xbd, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"chms", 0xbe, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"chmu", 0xbf, 1, ACCR+TYPW, 0, 0, 0, 0, 0}, 
+    {"addl2", 0xc0, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"addl3", 0xc1, 3, ACCR+TYPL, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"subl2", 0xc2, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"subl3", 0xc3, 3, ACCR+TYPL, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"mull2", 0xc4, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"mull3", 0xc5, 3, ACCR+TYPL, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"divl2", 0xc6, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"divl3", 0xc7, 3, ACCR+TYPL, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"bisl2", 0xc8, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"bisl3", 0xc9, 3, ACCR+TYPL, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"bicl2", 0xca, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"bicl3", 0xcb, 3, ACCR+TYPL, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"xorl2", 0xcc, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"xorl3", 0xcd, 3, ACCR+TYPL, ACCR+TYPL, ACCW+TYPL, 0, 0, 0}, 
+    {"mnegl", 0xce, 2, ACCR+TYPL, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"casel", 0xcf, 3, ACCR+TYPL, ACCR+TYPL, ACCR+TYPL, 0, 0, 0}, 
+    {"movl", 0xd0, 2, ACCR+TYPL, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"cmpl", 0xd1, 2, ACCR+TYPL, ACCR+TYPL, 0, 0, 0, 0}, 
+    {"mcoml", 0xd2, 2, ACCR+TYPL, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"bitl", 0xd3, 2, ACCR+TYPL, ACCR+TYPL, 0, 0, 0, 0}, 
+    {"clrl", 0xd4, 1, ACCW+TYPL, 0, 0, 0, 0, 0}, 
+    {"tstl", 0xd5, 1, ACCR+TYPL, 0, 0, 0, 0, 0}, 
+    {"incl", 0xd6, 1, ACCM+TYPL, 0, 0, 0, 0, 0}, 
+    {"decl", 0xd7, 1, ACCM+TYPL, 0, 0, 0, 0, 0}, 
+    {"adwc", 0xd8, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"sbwc", 0xd9, 2, ACCR+TYPL, ACCM+TYPL, 0, 0, 0, 0}, 
+    {"mtpr", 0xda, 2, ACCR+TYPL, ACCR+TYPL, 0, 0, 0, 0}, 
+    {"mfpr", 0xdb, 2, ACCR+TYPL, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"movpsl", 0xdc, 1, ACCW+TYPL, 0, 0, 0, 0, 0}, 
+    {"pushl", 0xdd, 1, ACCR+TYPL, 0, 0, 0, 0, 0}, 
+    {"moval", 0xde, 2, ACCA+TYPL, ACCW+TYPL, 0, 0, 0, 0}, 
+    {"pushal", 0xdf, 1, ACCA+TYPL, 0, 0, 0, 0, 0}, 
+    {"bbs", 0xe0, 3, ACCR+TYPL, ACCR+TYPB, ACCB+TYPB, 0, 0, 0}, 
+    {"bbc", 0xe1, 3, ACCR+TYPL, ACCR+TYPB, ACCB+TYPB, 0, 0, 0}, 
+    {"bbss", 0xe2, 3, ACCR+TYPL, ACCR+TYPB, ACCB+TYPB, 0, 0, 0}, 
+    {"bbcs", 0xe3, 3, ACCR+TYPL, ACCR+TYPB, ACCB+TYPB, 0, 0, 0}, 
+    {"bbsc", 0xe4, 3, ACCR+TYPL, ACCR+TYPB, ACCB+TYPB, 0, 0, 0}, 
+    {"bbcc", 0xe5, 3, ACCR+TYPL, ACCR+TYPB, ACCB+TYPB, 0, 0, 0}, 
+    {"bbssi", 0xe6, 3, ACCR+TYPL, ACCR+TYPB, ACCB+TYPB, 0, 0, 0}, 
+    {"bbcci", 0xe7, 3, ACCR+TYPL, ACCR+TYPB, ACCB+TYPB, 0, 0, 0}, 
+    {"blbs", 0xe8, 2, ACCR+TYPL, ACCB+TYPB, 0, 0, 0, 0}, 
+    {"blbc", 0xe9, 2, ACCR+TYPL, ACCB+TYPB, 0, 0, 0, 0}, 
+    {"ffs", 0xea, 4, ACCR+TYPL, ACCR+TYPB, ACCR+TYPB, ACCW+TYPL, 0, 0}, 
+    {"ffc", 0xeb, 4, ACCR+TYPL, ACCR+TYPB, ACCR+TYPB, ACCW+TYPL, 0, 0}, 
+    {"cmpv", 0xec, 4, ACCR+TYPL, ACCR+TYPB, ACCR+TYPB, ACCR+TYPL, 0, 0}, 
+    {"cmpzv", 0xed, 4, ACCR+TYPL, ACCR+TYPB, ACCR+TYPB, ACCR+TYPL, 0, 0}, 
+    {"extv", 0xee, 4, ACCR+TYPL, ACCR+TYPB, ACCR+TYPB, ACCW+TYPL, 0, 0}, 
+    {"extzv", 0xef, 4, ACCR+TYPL, ACCR+TYPB, ACCR+TYPB, ACCW+TYPL, 0, 0}, 
+    {"insv", 0xf0, 4, ACCR+TYPL, ACCR+TYPL, ACCR+TYPB, ACCW+TYPB, 0, 0}, 
+    {"acbl", 0xf1, 4, ACCR+TYPL, ACCR+TYPL, ACCM+TYPL, ACCB+TYPW, 0, 0}, 
+    {"aoblss", 0xf2, 3, ACCR+TYPL, ACCM+TYPL, ACCB+TYPB, 0, 0, 0}, 
+    {"aobleq", 0xf3, 3, ACCR+TYPL, ACCM+TYPL, ACCB+TYPB, 0, 0, 0}, 
+    {"sobgeq", 0xf4, 2, ACCM+TYPL, ACCB+TYPB, 0, 0, 0, 0}, 
+    {"sobgtr", 0xf5, 2, ACCM+TYPL, ACCB+TYPB, 0, 0, 0, 0}, 
+    {"cvtlb", 0xf6, 2, ACCR+TYPL, ACCW+TYPB, 0, 0, 0, 0}, 
+    {"cvtlw", 0xf7, 2, ACCR+TYPL, ACCW+TYPW, 0, 0, 0, 0}, 
+    {"ashp", 0xf8, 6, ACCR+TYPB, ACCR+TYPW, ACCA+TYPB, ACCR+TYPB, ACCR+TYPW, ACCA+TYPB}, 
+    {"cvtlp", 0xf9, 3, ACCR+TYPL, ACCR+TYPW, ACCA+TYPB, 0, 0, 0}, 
+    {"callg", 0xfa, 2, ACCA+TYPB, ACCA+TYPB, 0, 0, 0, 0}, 
+    {"calls", 0xfb, 2, ACCR+TYPL, ACCA+TYPB, 0, 0, 0, 0}, 
+    {"xfc", 0xfc, 1, ACCI+TYPB, 0, 0, 0, 0, 0}, 
+    {"escd", 0xfd, 0, 0, 0, 0, 0, 0, 0}, 
+    {"esce", 0xfe, 0, 0, 0, 0, 0, 0, 0}, 
+    {"escf", 0xff, 0, 0, 0, 0, 0, 0, 0},
+};
+
+/*
+ * Register names.
+ */
+
+public String regname[] = {
+    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+    "r8", "r9", "r10","r11","ap", "fp", "sp", "pc"
+};
+
+/*
+ * Floating point immediate operands.
+ */
+
+public String fltimm[] = {
+    "0.5", "0.5625", "0.625", "0.6875", "0.75", "0.8125", "0.875", "0.9375",
+    "1.0", "1.125", "1.25", "1.375", "1.5", "1.625", "1.75", "1.875",
+    "2.0", "2.25", "2.5", "2.75", "3.0", "3.25", "3.5", "3.75",
+    "4.0", "4.5", "5.0", "5.5", "6.0", "6.5", "7.0", "7.5",
+    "8.0", "9.0", "10.0", "11.0", "12.0", "13.0", "14.0", "15.0",
+    "16.0", "18.0", "20.0", "22.0", "24.0", "26.0", "28.0", "30.0",
+    "32.0", "36.0", "40.0", "44.0", "48.0", "52.0", "56.0", "60.0",
+    "64.0", "72.0", "80.0", "88.0", "96.0", "104.0", "112.0", "120.0"
+};
diff --git a/dbx/ops.h b/dbx/ops.h
new file mode 100644
index 0000000..cc04f2d
--- /dev/null
+++ b/dbx/ops.h
@@ -0,0 +1,330 @@
+#ifndef ops_h
+#define ops_h
+typedef unsigned char VaxOpcode;
+
+#define O_HALT 0x00		/* halt */
+#define O_NOP 0x01		/* no operation */
+#define O_REI 0x02		/* return from exception or interrupt */
+#define O_BPT 0x03		/* break point fault */
+#define O_RET 0x04		/* return from called procedure */
+#define O_RSB 0x05		/* return from subroutine */
+#define O_LDPCTX 0x06		/* load process context */
+#define O_SVPCTX 0x07		/* save process context */
+#define O_CVTPS 0x08		/* convert packed to leading separate numeric */
+#define O_CVTSP 0x09		/* convert leading separate numeric to packed */
+#define O_INDEX 0x0A		/* compute index */
+#define O_CRC 0x0B		/* calculate cyclic redundancy check */
+#define O_PROBER 0x0C		/* probe read access */
+#define O_PROBEW 0x0D		/* probe write access */
+#define O_INSQUE 0x0E		/* insert into queue */
+#define O_REMQUE 0x0F		/* remove from queue */
+#define O_BSBB 0x10		/* branch to subroutine with byte disp */
+#define O_BRB 0x11		/* branch with byte disp */
+#define O_BNEQ 0x12		/* branch on not equal (also BNEQU) */
+#define O_BEQL 0x13		/* branch on equal (also BEQLU */
+#define O_BGTR 0x14		/* branch on greater */
+#define O_BLEQ 0x15		/* branch on less or equal */
+#define O_JSB 0x16		/* jump to subroutine */
+#define O_JMP 0x17		/* jump */
+#define O_BGEQ 0x18		/* branch on greater or equal */
+#define O_BLSS 0x19		/* branch on less */
+#define O_BGTRU 0x1A		/* branch on greater unsigned */
+#define O_BLEQU 0x1B		/* branch on less of equal unsigned */
+#define O_BVC 0x1C		/* branch on overflow clear */
+#define O_BVS 0x1D		/* branch on overflow set */
+#define O_BCC 0x1E		/* branch on carry clear (also BGEQU) */
+#define O_BCS 0x1F		/* branch on carry set (also BLSSU) */
+#define O_ADDP4 0x20		/* add packed 4 operand */
+#define O_ADDP6 0x21		/* add packed 6 operand */
+#define O_SUBP4 0x22		/* subtract packed 4 operand */
+#define O_SUBP6 0x23		/* subtract packed 6 operand */
+#define O_CVTPT 0x24		/* convert packed to trailing numeric */
+#define O_MULP 0x25		/* multiply packed */
+#define O_CVTTP 0x26		/* convert trailing numeric to packed */
+#define O_DIVP 0x27		/* divide packed */
+#define O_MOVC3 0x28		/* move character 3 operand */
+#define O_CMPC3 0x29		/* compare character 3 operand */
+#define O_SCANC 0x2A		/* scan for character */
+#define O_SPANC 0x2B		/* span characters */
+#define O_MOVC5 0x2C		/* move character 5 operand */
+#define O_CMPC5 0x2D		/* compare character 5 operand */
+#define O_MOVTC 0x2E		/* move translated characters */
+#define O_MOVTUC 0x2F		/* move translated until character */
+#define O_BSBW 0x30		/* branch to subroutine with word disp */
+#define O_BRW 0x31		/* branch with word disp */
+#define O_CVTWL 0x32		/* convert word to long */
+#define O_CVTWB 0x33		/* convert word to byte */
+#define O_MOVP 0x34		/* move packed */
+#define O_CMPP3 0x35		/* compare packed 3 operand */
+#define O_CVTPL 0x36		/* convert packed to long */
+#define O_CMPP4 0x37		/* compare packed 4 operand */
+#define O_EDITPC 0x38		/* edit packed to character */
+#define O_MATCHC 0x39		/* match characters */
+#define O_LOCC 0x3A		/* locate characters */
+#define O_SKPC 0x3B		/* skip character */
+#define O_MOVZWL 0x3C		/* move zero-extended word to long */
+#define O_ACBW 0x3D		/* add compare and branch word */
+#define O_MOVAW 0x3E		/* move address of word */
+#define O_PUSHAW 0x3F		/* push address of word */
+#define O_ADDF2 0x40		/* add floating 2 operand */
+#define O_ADDF3 0x41		/* add floating 3 operand */
+#define O_SUBF2 0x42		/* subtract floating 2 operand */
+#define O_SUBF3 0x43		/* subtract floating 3 operand */
+#define O_MULF2 0x44		/* multiply floating 2 operand */
+#define O_MULF3 0x45		/* multiply floating 3 operand */
+#define O_DIVF2 0x46		/* divide floating 2 operand */
+#define O_DIVF3 0x47		/* divide floating 3 operand */
+#define O_CVTFB 0x48		/* convert float to byte */
+#define O_CVTFW 0x49		/* convert float to word */
+#define O_CVTFL 0x4A		/* convert float to long */
+#define O_CVTRFL 0x4B		/* convert rounded float to long */
+#define O_CVTBF 0x4C		/* convert byte to float */
+#define O_CVTWF 0x4D		/* convert word to float */
+#define O_CVTLF 0x4E		/* convert long to float */
+#define O_ACBF 0x4F		/* add compare and branch floating */
+#define O_MOVF 0x50		/* move float */
+#define O_CMPF 0x51		/* compare floating */
+#define O_MNEGF 0x52		/* move negated floating */
+#define O_TSTF 0x53		/* test float */
+#define O_EMODF 0x54		/* extended modulus floating */
+#define O_POLYF 0x55		/* evaluate polynomial floating */
+#define O_CVTFD 0x56		/* convert float to double */
+#define O_DUMMY57 0x57		/* RESERVED to DIGITAL */
+#define O_ADAWI 0x58		/* add aligned word interlocked */
+#define O_DUMMY59 0x59		/* RESERVED to DIGITAL */
+#define O_DUMMY5a 0x5A		/* RESERVED to DIGITAL */
+#define O_DUMMY5b 0x5B		/* RESERVED to DIGITAL */
+#define O_INSQHI 0x5C		/* insert into queue head, interlocked */
+#define O_INSQTI 0x5D		/* insert into queue tail, interlocked */
+#define O_REMQHI 0x5E		/* remove from queue head, interlocked */
+#define O_REMQTI 0x5F		/* remove from queue tail, interlocked */
+#define O_ADDD2 0x60		/* add double 2 operand */
+#define O_ADDD3 0x61		/* add double 3 operand */
+#define O_SUBD2 0x62		/* subtract double 2 operand */
+#define O_SUBD3 0x63		/* subtrace double 3 operand */
+#define O_MULD2 0x64		/* multiply double 2 operand */
+#define O_MULD3 0x65		/* multiply double 3 operand */
+#define O_DIVD2 0x66		/* divide double 2 operand */
+#define O_DIVD3 0x67		/* divide double 3 operand */
+#define O_CVTDB 0x68		/* convert double to byte */
+#define O_CVTDW 0x69		/* convert double to word */
+#define O_CVTDL 0x6A		/* convert double to long */
+#define O_CVTRDL 0x6B		/* convert rounded double to long */
+#define O_CVTBD 0x6C		/* convert byte to double */
+#define O_CVTWD 0x6D		/* convert word to double */
+#define O_CVTLD 0x6E		/* convert long to double */
+#define O_ACBD 0x6F		/* add compare and branch double */
+#define O_MOVD 0x70		/* move double */
+#define O_CMPD 0x71		/* compare double */
+#define O_MNEGD 0x72		/* move negated double */
+#define O_TSTD 0x73		/* test double */
+#define O_EMODD 0x74		/* extended modulus double */
+#define O_POLYD 0x75		/* evaluate polynomial double */
+#define O_CVTDF 0x76		/* convert double to float */
+#define O_DUMMY77 0x77		/* RESERVED to DIGITAL */
+#define O_ASHL 0x78		/* arithmetic shift long */
+#define O_ASHQ 0x79		/* arithmetic shift quad */
+#define O_EMUL 0x7A		/* extended multiply */
+#define O_EDIV 0x7B		/* extended divide */
+#define O_CLRQ 0x7C		/* clear quad (also CLRD) */
+#define O_MOVQ 0x7D		/* move quad */
+#define O_MOVAQ 0x7E		/* move address of quad (also MOVAD) */
+#define O_PUSHAQ 0x7F		/* push address of quad (also PUSHAD) */
+#define O_ADDB2 0x80		/* add byte 2 operand */
+#define O_ADDB3 0x81		/* add byte 3 operand */
+#define O_SUBB2 0x82		/* subtract byte 2 operand */
+#define O_SUBB3 0x83		/* subtract byte 3 operand */
+#define O_MULB2 0x84		/* multiply byte 2 operand */
+#define O_MULB3 0x85		/* multiply byte 3 operand */
+#define O_DIVB2 0x86		/* divide byte 2 operand */
+#define O_DIVB3 0x87		/* divide byte 3 operand */
+#define O_BISB2 0x88		/* bit set byte 2 operand */
+#define O_BISB3 0x89		/* bit set byte 3 operand */
+#define O_BICB2 0x8A		/* bit clear byte 2 operand */
+#define O_BICB3 0x8B		/* bit clear byte 3 operand */
+#define O_XORB2 0x8C		/* exclusive or byte 2 operand */
+#define O_XORB3 0x8D		/* exclusive or byte 3 operand */
+#define O_MNEGB 0x8E		/* move negated byte */
+#define O_CASEB 0x8F		/* case byte */
+#define O_MOVB 0x90		/* move byte */
+#define O_CMPB 0x91		/* compare byte */
+#define O_MCOMB 0x92		/* move complemented byte */
+#define O_BITB 0x93		/* bit test byte */
+#define O_CLRB 0x94		/* clear byte */
+#define O_TSTB 0x95		/* test byte */
+#define O_INCB 0x96		/* increment byte */
+#define O_DECB 0x97		/* decrement byte */
+#define O_CVTBL 0x98		/* convert byte to long */
+#define O_CVTBW 0x99		/* convert byte to word */
+#define O_MOVZBL 0x9A		/* move zero-extended byte to long */
+#define O_MOVZBW 0x9B		/* move zero-extended byte to word */
+#define O_ROTL 0x9C		/* rotate long */
+#define O_ACBB 0x9D		/* add compare and branch byte */
+#define O_MOVAB 0x9E		/* move address of byte */
+#define O_PUSHAB 0x9F		/* push address of byte */
+#define O_ADDW2 0xA0		/* add word 2 operand */
+#define O_ADDW3 0xA1		/* add word 3 operand */
+#define O_SUBW2 0xA2		/* subtract word 2 operand */
+#define O_SUBW3 0xA3		/* subtract word 3 operand */
+#define O_MULW2 0xA4		/* multiply word 2 operand */
+#define O_MULW3 0xA5		/* multiply word 3 operand */
+#define O_DIVW2 0xA6		/* divide word 2 operand */
+#define O_DIVW3 0xA7		/* divide word 3 operand */
+#define O_BISW2 0xA8		/* bit set word 2 operand */
+#define O_BISW3 0xA9		/* bit set word 3 operand */
+#define O_BICW2 0xAA		/* bit clear word 2 operand */
+#define O_BICW3 0xAB		/* bit clear word 3 operand */
+#define O_XORW2 0xAC		/* exclusive or word 2 operand */
+#define O_XORW3 0xAD		/* exclusive or word 3 operand */
+#define O_MNEGW 0xAE		/* move negated word */
+#define O_CASEW 0xAF		/* case word */
+#define O_MOVW 0xB0		/* move word */
+#define O_CMPW 0xB1		/* compare word */
+#define O_MCOMW 0xB2		/* move complemented word */
+#define O_BITW 0xB3		/* bit test word */
+#define O_CLRW 0xB4		/* clear word */
+#define O_TSTW 0xB5		/* test word */
+#define O_INCW 0xB6		/* increment word */
+#define O_DECW 0xB7		/* decrement word */
+#define O_BISPSW 0xB8		/* bit set processor status word */
+#define O_BICPSW 0xB9		/* bit clear processor status word */
+#define O_POPR 0xBA		/* pop register */
+#define O_PUSHR 0xBB		/* push register */
+#define O_CHMK 0xBC		/* change mode to kernel */
+#define O_CHME 0xBD		/* change mode to executive */
+#define O_CHMS 0xBE		/* change mode to supervisor */
+#define O_CHMU 0xBF		/* change mode to user */
+#define O_ADDL2 0xC0		/* add long 2 operand */
+#define O_ADDL3 0xC1		/* add long 3 operand */
+#define O_SUBL2 0xC2		/* subtract long 2 operand */
+#define O_SUBL3 0xC3		/* subtract long 3 operand */
+#define O_MULL2 0xC4		/* multiply long 2 operand */
+#define O_MULL3 0xC5		/* multiply long 3 operand */
+#define O_DIVL2 0xC6		/* divide long 2 operand */
+#define O_DIVL3 0xC7		/* divide long 3 operand */
+#define O_BISL2 0xC8		/* bit set long 2 operand */
+#define O_BISL3 0xC9		/* bit set long 3 operand */
+#define O_BICL2 0xCA		/* bit clear long 2 operand */
+#define O_BICL3 0xCB		/* bit clear long 3 operand */
+#define O_XORL2 0xCC		/* exclusive or long 2 operand */
+#define O_XORL3 0xCD		/* exclusive or long 3 operand */
+#define O_MNEGL 0xCE		/* move negated long */
+#define O_CASEL 0xCF		/* case long */
+#define O_MOVL 0xD0		/* move long */
+#define O_CMPL 0xD1		/* compare long */
+#define O_MCOML 0xD2		/* move complemented long */
+#define O_BITL 0xD3		/* bit test long */
+#define O_CLRL 0xD4		/* clear long (also CLRF) */
+#define O_TSTL 0xD5		/* test long */
+#define O_INCL 0xD6		/* increment long */
+#define O_DECL 0xD7		/* decrement long */
+#define O_ADWC 0xD8		/* add with carry */
+#define O_SBWC 0xD9		/* subtrace with carry */
+#define O_MTPR 0xDA		/* move to processor register */
+#define O_MFPR 0xDB		/* move from processor register */
+#define O_MOVPSL 0xDC		/* move processor status longword */
+#define O_PUSHL 0xDD		/* push long */
+#define O_MOVAL 0xDE		/* move address of long (also MOVAF) */
+#define O_PUSHAL 0xDF		/* push address of long (also PUSHAF) */
+#define O_BBS 0xE0		/* branch on bit set */
+#define O_BBC 0xE1		/* branch on bit clear */
+#define O_BBSS 0xE2		/* branch on bit set and set */
+#define O_BBCS 0xE3		/* branch on bit clear and set */
+#define O_BBSC 0xE4		/* branch on bit set and clear */
+#define O_BBCC 0xE5		/* branch on bit clear and clear */
+#define O_BBSSI 0xE6		/* branch on bit set and set interlocked */
+#define O_BBCCI 0xE7		/* branch on bit clear and clear interlocked */
+#define O_BLBS 0xE8		/* branch on low bit set */
+#define O_BLBC 0xE9		/* branch on low bit clear */
+#define O_FFS 0xEA		/* find first set bit */
+#define O_FFC 0xEB		/* find first clear bit */
+#define O_CMPV 0xEC		/* compare field */
+#define O_CMPZV 0xED		/* compare zero-extended field */
+#define O_EXTV 0xEE		/* extract field */
+#define O_EXTZV 0xEF		/* extract zero-extended field */
+#define O_INSV 0xF0		/* insert field */
+#define O_ACBL 0xF1		/* add compare and branch long */
+#define O_AOBLSS 0xF2		/* add one and branch on less */
+#define O_AOBLEQ 0xF3		/* add one and branch on less or equal */
+#define O_SOBGEQ 0xF4		/* subtract one and branch on gtr or equal */
+#define O_SOBGTR 0xF5		/* subtract one and branch on greater */
+#define O_CVTLB 0xF6		/* convert long to byte */
+#define O_CVTLW 0xF7		/* convert long to word */
+#define O_ASHP 0xF8		/* arithmetic shift and round packed */
+#define O_CVTLP 0xF9		/* convert long to packed */
+#define O_CALLG 0xFA		/* call with general argument list */
+#define O_CALLS 0xFB		/* call with stack */
+#define O_XFC 0xFC		/* extended function call */
+#define O_ESCD 0xFD		/* ESCD to DIGITAL */
+#define O_ESCE 0xFE		/* ESCE to DIGITAL */
+#define O_ESCF 0xFF		/* ESCF to DIGITAL */
+
+/*
+ * Opcode definitions.
+ *
+ * Much of this was taken from the assembler.
+ */
+
+/*
+ * Argument access types.
+ */
+
+#define ACCA    0100    /* address only */
+#define ACCR    010	/* read */
+#define ACCW    020	/* write */
+#define ACCM    030	/* modify */
+#define ACCB    040	/* branch displacement */
+#define ACCI    050	/* variable field */
+
+/*
+ * Argument lengths.
+ */
+
+#define TYPB    0	/* byte */
+#define TYPW    01	/* word */
+#define TYPL    02	/* long */
+#define TYPQ    03	/* quad */
+#define TYPF    04	/* floating */
+#define TYPD    05	/* double floating */
+
+/*
+ * Addressing modes.
+ */
+
+#define LITSHORT    0x0	/* short literals */
+#define LITUPTO31   0x1
+#define LITUPTO47   0x2
+#define LITUPTO63   0x3
+#define INDEX       0x4 /* i[r] */
+#define REG	    0x5 /* r */
+#define REGDEF      0x6 /* (r) */
+#define AUTODEC     0x7 /* -(r) */
+#define AUTOINC     0x8 /* (r)+ */
+#define AUTOINCDEF  0x9 /* *(r)+ */
+#define BYTEDISP    0xA /* BD(r) */
+#define BYTEDISPDEF 0xB /* *BD(r) */
+#define WORDDISP    0xC /* WD(r) */
+#define WORDDISPDEF 0xD /* *WD(r) */
+#define LONGDISP    0xE /* LD(r) */
+#define LONGDISPDEF 0xF /* *LD(r) */
+
+#define is_branch_disp(arg) ((arg & ACCB) != 0)
+#define typelen(arg)        (arg & 07)
+#define regnm(mode)	    (mode & 0xF)
+#define addrmode(mode)      (mode >> 4)
+
+/*
+ * Operator information structure.
+ */
+
+typedef struct {
+    char *iname;
+    char val;
+    char numargs;
+    char argtype[6];
+} Optab;
+
+Optab optab[] ;
+String regname[] ;
+String fltimm[] ;
+#endif
diff --git a/dbx/pascal.c b/dbx/pascal.c
new file mode 100644
index 0000000..4361f6c
--- /dev/null
+++ b/dbx/pascal.c
@@ -0,0 +1,440 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)pascal.c 1.2 12/15/82";
+
+/*
+ * Pascal-dependent symbol routines.
+ */
+
+#include "defs.h"
+#include "symbols.h"
+#include "pascal.h"
+#include "languages.h"
+#include "tree.h"
+#include "eval.h"
+#include "mappings.h"
+#include "process.h"
+#include "runtime.h"
+#include "machine.h"
+
+#ifndef public
+#endif
+
+/*
+ * Initialize Pascal information.
+ */
+
+public pascal_init()
+{
+    Language lang;
+
+    lang = language_define("pascal", ".p");
+    language_setop(lang, L_PRINTDECL, pascal_printdecl);
+    language_setop(lang, L_PRINTVAL, pascal_printval);
+    language_setop(lang, L_TYPEMATCH, pascal_typematch);
+}
+
+/*
+ * Compatible tests if two types are compatible.  The issue
+ * is complicated a bit by ranges.
+ *
+ * Integers and reals are not compatible since they cannot always be mixed.
+ */
+
+public Boolean pascal_typematch(type1, type2)
+Symbol type1, type2;
+{
+    Boolean b;
+    register Symbol t1, t2;
+
+    t1 = rtype(t1);
+    t2 = rtype(t2);
+    b = (Boolean)
+	(t1->type == t2->type and (
+	    (t1->class == RANGE and t2->class == RANGE) or
+	    (t1->class == SCAL and t2->class == CONST) or
+	    (t1->class == CONST and t2->class == SCAL) or
+	    (t1->type == t_char and t1->class == ARRAY and t2->class == ARRAY)
+	) or
+	(t1 == t_nil and t2->class == PTR) or
+	(t1->class == PTR and t2 == t_nil)
+    );
+    return b;
+}
+
+public pascal_printdecl(s)
+Symbol s;
+{
+    register Symbol t;
+    Boolean semicolon;
+
+    semicolon = true;
+    switch (s->class) {
+	case CONST:
+	    if (s->type->class == SCAL) {
+		printf("(enumeration constant, ord %ld)",
+		    s->symvalue.iconval);
+	    } else {
+		printf("const %s = ", symname(s));
+		printval(s);
+	    }
+	    break;
+
+	case TYPE:
+	    printf("type %s = ", symname(s));
+	    printtype(s, s->type);
+	    break;
+
+	case VAR:
+	    if (isparam(s)) {
+		printf("(parameter) %s : ", symname(s));
+	    } else {
+		printf("var %s : ", symname(s));
+	    }
+	    printtype(s, s->type);
+	    break;
+
+	case REF:
+	    printf("(var parameter) %s : ", symname(s));
+	    printtype(s, s->type);
+	    break;
+
+	case RANGE:
+	case ARRAY:
+	case RECORD:
+	case VARNT:
+	case PTR:
+	    printtype(s, s);
+	    semicolon = false;
+	    break;
+
+	case FVAR:
+	    printf("(function variable) %s : ", symname(s));
+	    printtype(s, s->type);
+	    break;
+
+	case FIELD:
+	    printf("(field) %s : ", symname(s));
+	    printtype(s, s->type);
+	    break;
+
+	case PROC:
+	    printf("procedure %s", symname(s));
+	    listparams(s);
+	    break;
+
+	case PROG:
+	    printf("program %s", symname(s));
+	    t = s->chain;
+	    if (t != nil) {
+		printf("(%s", symname(t));
+		for (t = t->chain; t != nil; t = t->chain) {
+		    printf(", %s", symname(t));
+		}
+		printf(")");
+	    }
+	    break;
+
+	case FUNC:
+	    printf("function %s", symname(s));
+	    listparams(s);
+	    printf(" : ");
+	    printtype(s, s->type);
+	    break;
+
+	default:
+	    error("class %s in printdecl", classname(s));
+    }
+    if (semicolon) {
+	putchar(';');
+    }
+    putchar('\n');
+}
+
+/*
+ * Recursive whiz-bang procedure to print the type portion
+ * of a declaration.  Doesn't work quite right for variant records.
+ *
+ * The symbol associated with the type is passed to allow
+ * searching for type names without getting "type blah = blah".
+ */
+
+private printtype(s, t)
+Symbol s;
+Symbol t;
+{
+    register Symbol tmp;
+
+    switch (t->class) {
+	case VAR:
+	case CONST:
+	case FUNC:
+	case PROC:
+	    panic("printtype: class %s", classname(t));
+	    break;
+
+	case ARRAY:
+	    printf("array[");
+	    tmp = t->chain;
+	    if (tmp != nil) {
+		for (;;) {
+		    printtype(tmp, tmp);
+		    tmp = tmp->chain;
+		    if (tmp == nil) {
+			break;
+		    }
+		    printf(", ");
+		}
+	    }
+	    printf("] of ");
+	    printtype(t, t->type);
+	    break;
+
+	case RECORD:
+	    printf("record\n");
+	    if (t->chain != nil) {
+		printtype(t->chain, t->chain);
+	    }
+	    printf("end");
+	    break;
+
+	case FIELD:
+	    if (t->chain != nil) {
+		printtype(t->chain, t->chain);
+	    }
+	    printf("\t%s : ", symname(t));
+	    printtype(t, t->type);
+	    printf(";\n");
+	    break;
+
+	case RANGE: {
+	    long r0, r1;
+
+	    r0 = t->symvalue.rangev.lower;
+	    r1 = t->symvalue.rangev.upper;
+	    if (t == t_char) {
+		if (r0 < 0x20 or r0 > 0x7e) {
+		    printf("%ld..", r0);
+		} else {
+		    printf("'%c'..", (char) r0);
+		}
+		if (r1 < 0x20 or r1 > 0x7e) {
+		    printf("\\%lo", r1);
+		} else {
+		    printf("'%c'", (char) r1);
+		}
+	    } else if (r0 > 0 and r1 == 0) {
+		printf("%ld byte real", r0);
+	    } else if (r0 >= 0) {
+		printf("%lu..%lu", r0, r1);
+	    } else {
+		printf("%ld..%ld", r0, r1);
+	    }
+	    break;
+	}
+
+	case PTR:
+	    putchar('*');
+	    printtype(t, t->type);
+	    break;
+
+	case TYPE:
+	    if (symname(t) != nil) {
+		printf("%s", symname(t));
+	    } else {
+		printtype(t, t->type);
+	    }
+	    break;
+
+	case SCAL:
+	    printf("(");
+	    t = t->type->chain;
+	    if (t != nil) {
+		printf("%s", symname(t));
+		t = t->chain;
+		while (t != nil) {
+		    printf(", %s", symname(t));
+		    t = t->chain;
+		}
+	    } else {
+		panic("empty enumeration");
+	    }
+	    printf(")");
+	    break;
+
+	default:
+	    printf("(class %d)", t->class);
+	    break;
+    }
+}
+
+/*
+ * List the parameters of a procedure or function.
+ * No attempt is made to combine like types.
+ */
+
+private listparams(s)
+Symbol s;
+{
+    Symbol t;
+
+    if (s->chain != nil) {
+	putchar('(');
+	for (t = s->chain; t != nil; t = t->chain) {
+	    switch (t->class) {
+		case REF:
+		    printf("var ");
+		    break;
+
+		case FPROC:
+		    printf("procedure ");
+		    break;
+
+		case FFUNC:
+		    printf("function ");
+		    break;
+
+		case VAR:
+		    break;
+
+		default:
+		    panic("unexpected class %d for parameter", t->class);
+	    }
+	    printf("%s : ", symname(t));
+	    printtype(t, t->type);
+	    if (t->chain != nil) {
+		printf("; ");
+	    }
+	}
+	putchar(')');
+    }
+}
+
+/*
+ * Print out the value on the top of the expression stack
+ * in the format for the type of the given symbol.
+ */
+
+public pascal_printval(s)
+Symbol s;
+{
+    Symbol t;
+    Address a;
+    int len;
+    double r;
+
+    if (s->class == REF) {
+	s = s->type;
+    }
+    switch (s->class) {
+	case TYPE:
+	    pascal_printval(s->type);
+	    break;
+
+	case ARRAY:
+	    t = rtype(s->type);
+	    if (t==t_char or (t->class==RANGE and t->type==t_char)) {
+		len = size(s);
+		sp -= len;
+		printf("'%.*s'", len, sp);
+		break;
+	    } else {
+		printarray(s);
+	    }
+	    break;
+
+	case RECORD:
+	    printrecord(s);
+	    break;
+
+	case VARNT:
+	    error("can't print out variant records");
+	    break;
+
+
+	case RANGE:
+	    if (s == t_boolean) {
+		printf(((Boolean) popsmall(s)) == true ? "true" : "false");
+	    } else if (s == t_char) {
+		printf("'%c'", pop(char));
+	    } else if (s->symvalue.rangev.upper == 0 and
+			s->symvalue.rangev.lower > 0) {
+		switch (s->symvalue.rangev.lower) {
+		    case sizeof(float):
+			prtreal(pop(float));
+			break;
+
+		    case sizeof(double):
+			prtreal(pop(double));
+			break;
+
+		    default:
+			panic("bad real size %d", s->symvalue.rangev.lower);
+			break;
+		}
+	    } else if (s->symvalue.rangev.lower >= 0) {
+		printf("%lu", popsmall(s));
+	    } else {
+		printf("%ld", popsmall(s));
+	    }
+	    break;
+
+	case FILET:
+	case PTR: {
+	    Address addr;
+
+	    addr = pop(Address);
+	    if (addr == 0) {
+		printf("0, (nil)");
+	    } else {
+		printf("0x%x, 0%o", addr, addr);
+	    }
+	    break;
+	}
+
+	case FIELD:
+	    error("missing record specification");
+	    break;
+
+	case SCAL: {
+	    int scalar;
+	    Boolean found;
+
+	    scalar = popsmall(s);
+	    found = false;
+	    for (t = s->chain; t != nil; t = t->chain) {
+		if (t->symvalue.iconval == scalar) {
+		    printf("%s", symname(t));
+		    found = true;
+		    break;
+		}
+	    }
+	    if (not found) {
+		printf("(scalar = %d)", scalar);
+	    }
+	    break;
+	}
+
+	case FPROC:
+	case FFUNC:
+	{
+	    Address a;
+
+	    a = fparamaddr(pop(long));
+	    t = whatblock(a);
+	    if (t == nil) {
+		printf("(proc %d)", a);
+	    } else {
+		printf("%s", symname(t));
+	    }
+	    break;
+	}
+
+	default:
+	    if (ord(s->class) < ord(BADUSE) or ord(s->class) > ord(TYPEREF)) {
+		panic("printval: bad class %d", ord(s->class));
+	    }
+	    error("don't know how to print a %s", classname(s));
+	    /* NOTREACHED */
+    }
+}
diff --git a/dbx/pascal.h b/dbx/pascal.h
new file mode 100644
index 0000000..8ed9401
--- /dev/null
+++ b/dbx/pascal.h
@@ -0,0 +1,7 @@
+#ifndef pascal_h
+#define pascal_h
+pascal_init(/*  */);
+Boolean pascal_typematch(/* type1, type2 */);
+pascal_printdecl(/* s */);
+pascal_printval(/* s */);
+#endif
diff --git a/dbx/printsym.c b/dbx/printsym.c
new file mode 100644
index 0000000..663ae81
--- /dev/null
+++ b/dbx/printsym.c
@@ -0,0 +1,573 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)printsym.c 1.12 8/10/83";
+
+/*
+ * Printing of symbolic information.
+ */
+
+#include "defs.h"
+#include "symbols.h"
+#include "languages.h"
+#include "printsym.h"
+#include "tree.h"
+#include "eval.h"
+#include "mappings.h"
+#include "process.h"
+#include "runtime.h"
+#include "machine.h"
+#include "names.h"
+#include "main.h"
+
+#ifndef public
+#endif
+
+/*
+ * Maximum number of arguments to a function.
+ * This is used as a check for the possibility that the stack has been
+ * overwritten and therefore a saved argument pointer might indicate
+ * to an absurdly large number of arguments.
+ */
+
+#define MAXARGSPASSED 20
+
+/*
+ * Return a pointer to the string for the name of the class that
+ * the given symbol belongs to.
+ */
+
+private String clname[] = {
+    "bad use", "constant", "type", "variable", "array", "fileptr",
+    "record", "field", "procedure", "function", "funcvar",
+    "ref", "pointer", "file", "set", "range", "label", "withptr",
+    "scalar", "string", "program", "improper", "variant",
+    "procparam", "funcparam", "module", "tag", "common", "typeref"
+};
+
+public String classname(s)
+Symbol s;
+{
+    return clname[ord(s->class)];
+}
+
+/*
+ * Note the entry of the given block, unless it's the main program.
+ */
+
+public printentry(s)
+Symbol s;
+{
+    if (s != program) {
+	printf("\nentering %s %s\n", classname(s), symname(s));
+    }
+}
+
+/*
+ * Note the exit of the given block
+ */
+
+public printexit(s)
+Symbol s;
+{
+    if (s != program) {
+	printf("leaving %s %s\n\n", classname(s), symname(s));
+    }
+}
+
+/*
+ * Note the call of s from t.
+ */
+
+public printcall(s, t)
+Symbol s, t;
+{
+    printf("calling %s", symname(s));
+    printparams(s, nil);
+    printf(" from %s %s\n", classname(t), symname(t));
+}
+
+/*
+ * Note the return from s.  If s is a function, print the value
+ * it is returning.  This is somewhat painful, since the function
+ * has actually just returned.
+ */
+
+public printrtn(s)
+Symbol s;
+{
+    register Symbol t;
+    register int len;
+    Boolean isindirect;
+
+    printf("returning ");
+    if (s->class == FUNC && (!istypename(s->type,"void"))) {
+	len = size(s->type);
+	if (canpush(len)) {
+	    t = rtype(s->type);
+	    isindirect = (Boolean) (t->class == RECORD or t->class == VARNT);
+	    pushretval(len, isindirect);
+	    printval(s->type);
+	    putchar(' ');
+	} else {
+	    printf("(value too large) ");
+	}
+    }
+    printf("from %s\n", symname(s));
+}
+
+/*
+ * Print the values of the parameters of the given procedure or function.
+ * The frame distinguishes recursive instances of a procedure.
+ */
+
+public printparams(f, frame)
+Symbol f;
+Frame frame;
+{
+    Symbol param;
+    int n, m, s;
+
+    n = nargspassed(frame);
+    param = f->chain;
+    if (param != nil or n > 0) {
+	printf("(");
+	m = n;
+	if (param != nil) {
+	    for (;;) {
+		s = size(param) div sizeof(Word);
+		if (s == 0) {
+		    s = 1;
+		}
+		m -= s;
+		printv(param, frame);
+		param = param->chain;
+	    if (param == nil) break;
+		printf(", ");
+	    }
+	}
+	if (m > 0) {
+	    if (m > MAXARGSPASSED) {
+		m = MAXARGSPASSED;
+	    }
+	    if (f->chain != nil) {
+		printf(", ");
+	    }
+	    for (;;) {
+		--m;
+		printf("0x%x", argn(n - m, frame));
+	    if (m <= 0) break;
+		printf(", ");
+	    }
+	}
+	printf(")");
+    }
+}
+
+/*
+ * Test if a symbol should be printed.  We don't print files,
+ * for example, simply because there's no good way to do it.
+ * The symbol must be within the given function.
+ */
+
+public Boolean should_print(s)
+Symbol s;
+{
+    Boolean b;
+    register Symbol t;
+
+    switch (s->class) {
+	case VAR:
+	case FVAR:
+	    if (isparam(s)) {
+		b = false;
+	    } else {
+		t = rtype(s->type);
+		if (t == nil) {
+		    b = false;
+		} else {
+		    switch (t->class) {
+			case FILET:
+			case SET:
+			case BADUSE:
+			    b = false;
+			    break;
+
+			default:
+			    b = true;
+			    break;
+		    }
+		}
+	    }
+	    break;
+
+	default:
+	    b = false;
+	    break;
+    }
+    return b;
+}
+
+/*
+ * Print the name and value of a variable.
+ */
+
+public printv(s, frame)
+Symbol s;
+Frame frame;
+{
+    Address addr;
+    int len;
+
+    if (isambiguous(s) and ismodule(container(s))) {
+	printname(stdout, s);
+	printf(" = ");
+    } else {
+	printf("%s = ", symname(s));
+    }
+    if(s->type->class == ARRAY && (! istypename(s->type->type,"char")) ) {
+	printf(" ARRAY ");
+    } else {
+       if (isvarparam(s)) {
+	   rpush(address(s, frame), sizeof(Address));
+	   addr = pop(Address);
+	   len = size(s->type);
+       } else {
+	   addr = address(s, frame);
+	   len = size(s);
+       }
+       if (canpush(len)) {
+	   rpush(addr, len);
+	   printval(s->type);
+       } else {
+	   printf("*** expression too large ***");
+       }
+   }
+}
+
+/*
+ * Print out the name of a symbol.
+ */
+
+public printname(f, s)
+File f;
+Symbol s;
+{
+    if (s == nil) {
+	fprintf(f, "(noname)");
+    } else if (isredirected() or isambiguous(s)) {
+	printwhich(f, s);
+    } else {
+	fprintf(f, "%s", symname(s));
+    }
+}
+
+/*
+ * Print the fully specified variable that is described by the given identifer.
+ */
+
+public printwhich(f, s)
+File f;
+Symbol s;
+{
+    printouter(f, container(s));
+    fprintf(f, "%s", symname(s));
+}
+
+/*
+ * Print the fully qualified name of each symbol that has the same name
+ * as the given symbol.
+ */
+
+public printwhereis(f, s)
+File f;
+Symbol s;
+{
+    register Name n;
+    register Symbol t;
+
+    checkref(s);
+    n = s->name;
+    t = lookup(n);
+    printwhich(f, t);
+    t = t->next_sym;
+    while (t != nil) {
+	if (t->name == n) {
+	    putc(' ', f);
+	    printwhich(f, t);
+	}
+	t = t->next_sym;
+    }
+    putc('\n', f);
+}
+
+private printouter(f, s)
+File f;
+Symbol s;
+{
+    Symbol outer;
+
+    if (s != nil) {
+	outer = container(s);
+	if (outer != nil and outer != program) {
+	    printouter(f, outer);
+	}
+	fprintf(f, "%s.", symname(s));
+    }
+}
+
+public printdecl(s)
+Symbol s;
+{
+    checkref(s);
+    (*language_op(s->language, L_PRINTDECL))(s);
+}
+
+/*
+ * Straight dump of symbol information.
+ */
+
+public psym(s)
+Symbol s;
+{
+    printf("name\t%s\n", symname(s));
+    printf("lang\t%s\n", language_name(s->language));
+    printf("level\t%d\n", s->level);
+    printf("class\t%s\n", classname(s));
+    printf("type\t0x%x", s->type);
+    if (s->type != nil and s->type->name != nil) {
+	printf(" (%s)", symname(s->type));
+    }
+    printf("\nchain\t0x%x", s->chain);
+    if (s->chain != nil and s->chain->name != nil) {
+	printf(" (%s)", symname(s->chain));
+    }
+    printf("\nblock\t0x%x", s->block);
+    if (s->block->name != nil) {
+	printf(" (");
+	printname(stdout, s->block);
+	putchar(')');
+    }
+    putchar('\n');
+    switch (s->class) {
+	case VAR:
+	case REF:
+	    if (s->level >= 3) {
+		printf("address\t0x%x\n", s->symvalue.offset);
+	    } else {
+		printf("offset\t%d\n", s->symvalue.offset);
+	    }
+	    printf("size\t%d\n", size(s));
+	    break;
+
+	case RECORD:
+	case VARNT:
+	    printf("size\t%d\n", s->symvalue.offset);
+	    break;
+
+	case FIELD:
+	    printf("offset\t%d\n", s->symvalue.field.offset);
+	    printf("size\t%d\n", s->symvalue.field.length);
+	    break;
+
+	case PROG:
+	case PROC:
+	case FUNC:
+	    printf("address\t0x%x\n", s->symvalue.funcv.beginaddr);
+	    if (isinline(s)) {
+		printf("inline procedure\n");
+	    }
+	    if (nosource(s)) {
+		printf("does not have source information\n");
+	    } else {
+		printf("has source information\n");
+	    }
+	    break;
+
+	case RANGE:
+
+	    prangetype(s->symvalue.rangev.lowertype);
+	    printf("lower\t%d\n", s->symvalue.rangev.lower);
+	    prangetype(s->symvalue.rangev.uppertype);
+	    printf("upper\t%d\n", s->symvalue.rangev.upper);
+	    break;
+
+	default:
+	    /* do nothing */
+	    break;
+    }
+}
+
+private prangetype(r)
+Rangetype r;
+{
+    switch (r) {
+	case R_CONST:
+	    printf("CONST");
+	    break;
+
+	case R_ARG:
+	    printf("ARG");
+	    break;
+
+	case R_TEMP:
+	    printf("TEMP");
+	    break;
+
+	case R_ADJUST:
+	    printf("ADJUST");
+	    break;
+    }
+}
+
+/*
+ * Print out the value on top of the stack according to the given type.
+ */
+
+public printval(t)
+Symbol t;
+{
+    Symbol s;
+
+    checkref(t);
+    switch (t->class) {
+	case PROC:
+	case FUNC:
+	    s = pop(Symbol);
+	    printf("%s", symname(s));
+	    break;
+
+	default:
+	    if (t->language == nil) {
+		error("unknown language");
+	    } else {
+		(*language_op(t->language, L_PRINTVAL))(t);
+	    }
+	    break;
+    }
+}
+
+/*
+ * Print out the value of a record, field by field.
+ */
+
+public printrecord(s)
+Symbol s;
+{
+    if (s->chain == nil) {
+	error("record has no fields");
+    }
+    printf("(");
+    sp -= size(s);
+    printfield(s->chain);
+    printf(")");
+}
+
+/*
+ * Print out a field, first printing out other fields.
+ * This is done because the fields are chained together backwards.
+ */
+
+private printfield(s)
+Symbol s;
+{
+    Stack *savesp;
+
+    if (s->chain != nil) {
+	printfield(s->chain);
+	printf(", ");
+    }
+    printf("%s = ", symname(s));
+    savesp = sp;
+    sp += ((s->symvalue.field.offset div BITSPERBYTE) + size(s->type));
+    printval(s);
+    sp = savesp;
+}
+
+/*
+ * Print out the contents of an array.
+ * Haven't quite figured out what the best format is.
+ *
+ * This is rather inefficient.
+ *
+ * The "2*elsize" is there since "printval" drops the stack by elsize.
+ */
+
+public printarray(a)
+Symbol a;
+{
+    Stack *savesp, *newsp;
+    Symbol eltype;
+    long elsize;
+    String sep;
+
+    savesp = sp;
+    sp -= (size(a));
+    newsp = sp;
+    eltype = rtype(a->type);
+    elsize = size(eltype);
+    printf("(");
+    if (eltype->class == RECORD or eltype->class == ARRAY or
+      eltype->class == VARNT) {
+	sep = "\n";
+	putchar('\n');
+    } else {
+	sep = ", ";
+    }
+    for (sp += elsize; sp <= savesp; sp += 2*elsize) {
+	if (sp - elsize != newsp) {
+	    fputs(sep, stdout);
+	}
+	printval(eltype);
+    }
+    sp = newsp;
+    if (streq(sep, "\n")) {
+	putchar('\n');
+    }
+    printf(")");
+}
+
+/*
+ * Print out the value of a real number in Pascal notation.
+ * This is, unfortunately, different than what one gets
+ * from "%g" in printf.
+ */
+
+public prtreal(r)
+double r;
+{
+    extern char *index();
+    char buf[256];
+
+    sprintf(buf, "%g", r);
+    if (buf[0] == '.') {
+	printf("0%s", buf);
+    } else if (buf[0] == '-' and buf[1] == '.') {
+	printf("-0%s", &buf[1]);
+    } else {
+	printf("%s", buf);
+    }
+    if (index(buf, '.') == nil) {
+	printf(".0");
+    }
+}
+
+/*
+ * Print out a character using ^? notation for unprintables.
+ */
+
+public printchar(c)
+char c;
+{
+    if (c == 0) {
+	putchar('\\');
+	putchar('0');
+    } else if (c == '\n') {
+	putchar('\\');
+	putchar('n');
+    } else if (c > 0 and c < ' ') {
+	putchar('^');
+	putchar(c - 1 + 'A');
+    } else {
+	putchar(c);
+    }
+}
diff --git a/dbx/printsym.h b/dbx/printsym.h
new file mode 100644
index 0000000..e238e69
--- /dev/null
+++ b/dbx/printsym.h
@@ -0,0 +1,21 @@
+#ifndef printsym_h
+#define printsym_h
+String classname(/* s */);
+printentry(/* s */);
+printexit(/* s */);
+printcall(/* s, t */);
+printrtn(/* s */);
+printparams(/* f, frame */);
+Boolean should_print(/* s */);
+printv(/* s, frame */);
+printname(/* f, s */);
+printwhich(/* f, s */);
+printwhereis(/* f, s */);
+printdecl(/* s */);
+psym(/* s */);
+printval(/* t */);
+printrecord(/* s */);
+printarray(/* a */);
+prtreal(/* r */);
+printchar(/* c */);
+#endif
diff --git a/dbx/process.c b/dbx/process.c
new file mode 100644
index 0000000..fb8963a
--- /dev/null
+++ b/dbx/process.c
@@ -0,0 +1,1117 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)process.c 1.12 8/19/83";
+
+/*
+ * Process management.
+ *
+ * This module contains the routines to manage the execution and
+ * tracing of the debuggee process.
+ */
+
+#include "defs.h"
+#include "process.h"
+#include "machine.h"
+#include "events.h"
+#include "tree.h"
+#include "eval.h"
+#include "operators.h"
+#include "source.h"
+#include "object.h"
+#include "mappings.h"
+#include "main.h"
+#include "coredump.h"
+#include <signal.h>
+#include <errno.h>
+#include <sys/param.h>
+#include <machine/reg.h>
+#include <sys/stat.h>
+
+#ifndef public
+
+typedef struct Process *Process;
+
+Process process;
+
+#define DEFSIG -1
+
+#include "machine.h"
+
+#endif
+
+#define NOTSTARTED 1
+#define STOPPED 0177
+#define FINISHED 0
+
+/*
+ * Cache-ing of instruction segment is done to reduce the number
+ * of system calls.
+ */
+
+#define CSIZE 1003       /* size of instruction cache */
+
+typedef struct {
+    Word addr;
+    Word val;
+} CacheWord;
+
+/*
+ * This structure holds the information we need from the user structure.
+ */
+
+struct Process {
+    int pid;			/* process being traced */
+    int mask;			/* process status word */
+    Word reg[NREG];		/* process' registers */
+    Word oreg[NREG];		/* registers when process last stopped */
+    short status;		/* either STOPPED or FINISHED */
+    short signo;		/* signal that stopped process */
+    int exitval;		/* return value from exit() */
+    long sigset;		/* bit array of traced signals */
+    CacheWord word[CSIZE];	/* text segment cache */
+    Ttyinfo ttyinfo;		/* process' terminal characteristics */
+};
+
+/*
+ * These definitions are for the arguments to "pio".
+ */
+
+typedef enum { PREAD, PWRITE } PioOp;
+typedef enum { TEXTSEG, DATASEG } PioSeg;
+
+private struct Process pbuf;
+
+#define MAXNCMDARGS 100         /* maximum number of arguments to RUN */
+
+extern int errno;
+
+private Boolean just_started;
+private int argc;
+private String argv[MAXNCMDARGS];
+private String infile, outfile;
+
+/*
+ * Initialize process information.
+ */
+
+public process_init()
+{
+    register Integer i;
+    Char buf[10];
+
+    process = &pbuf;
+    process->status = (coredump) ? STOPPED : NOTSTARTED;
+    setsigtrace();
+    for (i = 0; i < NREG; i++) {
+	sprintf(buf, "$r%d", i);
+	defregname(identname(buf, false), i);
+    }
+    defregname(identname("$ap", true), ARGP);
+    defregname(identname("$fp", true), FRP);
+    defregname(identname("$sp", true), STKP);
+    defregname(identname("$pc", true), PROGCTR);
+    if (coredump) {
+	coredump_readin(process->mask, process->reg, process->signo);
+	pc = process->reg[PROGCTR];
+	getsrcpos();
+    }
+    arginit();
+}
+
+/*
+ * Routines to get at process information from outside this module.
+ */
+
+public Word reg(n)
+Integer n;
+{
+    register Word w;
+
+    if (n == NREG) {
+	w = process->mask;
+    } else {
+	w = process->reg[n];
+    }
+    return w;
+}
+
+public setreg(n, w)
+Integer n;
+Word w;
+{
+    process->reg[n] = w;
+}
+
+/*
+ * Begin execution.
+ *
+ * We set a breakpoint at the end of the code so that the
+ * process data doesn't disappear after the program terminates.
+ */
+
+private Boolean remade();
+
+public start(argv, infile, outfile)
+String argv[];
+String infile, outfile;
+{
+    String pargv[4];
+    Node cond;
+
+    if (coredump) {
+	coredump = false;
+	fclose(corefile);
+	coredump_close();
+    }
+    if (argv == nil) {
+	argv = pargv;
+	pargv[0] = objname;
+	pargv[1] = nil;
+    } else {
+	argv[argc] = nil;
+    }
+    if (remade(objname)) {
+	reinit(argv, infile, outfile);
+    }
+    pstart(process, argv, infile, outfile);
+    if (process->status == STOPPED) {
+	pc = 0;
+	curfunc = program;
+	if (objsize != 0) {
+	    cond = build(O_EQ, build(O_SYM, pcsym), build(O_LCON, lastaddr()));
+	    event_once(cond, buildcmdlist(build(O_ENDX)));
+	}
+    }
+}
+
+/*
+ * Check to see if the object file has changed since the symbolic
+ * information last was read.
+ */
+
+private time_t modtime;
+
+private Boolean remade(filename)
+String filename;
+{
+    struct stat s;
+    Boolean b;
+
+    stat(filename, &s);
+    b = (Boolean) (modtime != 0 and modtime < s.st_mtime);
+    modtime = s.st_mtime;
+    return b;
+}
+
+/*
+ * Set up what signals we want to trace.
+ */
+
+private setsigtrace()
+{
+    register Integer i;
+    register Process p;
+
+    p = process;
+    for (i = 1; i <= NSIG; i++) {
+	psigtrace(p, i, true);
+    }
+    psigtrace(p, SIGHUP, false);
+    psigtrace(p, SIGKILL, false);
+    psigtrace(p, SIGALRM, false);
+    psigtrace(p, SIGTSTP, false);
+    psigtrace(p, SIGCONT, false);
+    psigtrace(p, SIGCHLD, false);
+}
+
+/*
+ * Initialize the argument list.
+ */
+
+public arginit()
+{
+    infile = nil;
+    outfile = nil;
+    argv[0] = objname;
+    argc = 1;
+}
+
+/*
+ * Add an argument to the list for the debuggee.
+ */
+
+public newarg(arg)
+String arg;
+{
+    if (argc >= MAXNCMDARGS) {
+	error("too many arguments");
+    }
+    argv[argc++] = arg;
+}
+
+/*
+ * Set the standard input for the debuggee.
+ */
+
+public inarg(filename)
+String filename;
+{
+    if (infile != nil) {
+	error("multiple input redirects");
+    }
+    infile = filename;
+}
+
+/*
+ * Set the standard output for the debuggee.
+ * Probably should check to avoid overwriting an existing file.
+ */
+
+public outarg(filename)
+String filename;
+{
+    if (outfile != nil) {
+	error("multiple output redirect");
+    }
+    outfile = filename;
+}
+
+/*
+ * Start debuggee executing.
+ */
+
+public run()
+{
+    process->status = STOPPED;
+    fixbps();
+    curline = 0;
+    start(argv, infile, outfile);
+    just_started = true;
+    isstopped = false;
+    cont(0);
+}
+
+/*
+ * Continue execution wherever we left off.
+ *
+ * Note that this routine never returns.  Eventually bpact() will fail
+ * and we'll call printstatus or step will call it.
+ */
+
+typedef int Intfunc();
+
+private Intfunc *dbintr;
+private intr();
+
+#define succeeds    == true
+#define fails       == false
+
+public cont(signo)
+int signo;
+{
+    dbintr = signal(SIGINT, intr);
+    if (just_started) {
+	just_started = false;
+    } else {
+	if (not isstopped) {
+	    error("can't continue execution");
+	}
+	isstopped = false;
+	stepover();
+    }
+    for (;;) {
+	if (single_stepping) {
+	    printnews();
+	} else {
+	    setallbps();
+	    resume(signo);
+	    unsetallbps();
+	    if (bpact() fails) {
+		printstatus();
+	    }
+	}
+	stepover();
+    }
+    /* NOTREACHED */
+}
+
+/*
+ * This routine is called if we get an interrupt while "running" px
+ * but actually in the debugger.  Could happen, for example, while
+ * processing breakpoints.
+ *
+ * We basically just want to keep going; the assumption is
+ * that when the process resumes it will get the interrupt
+ * which will then be handled.
+ */
+
+private intr()
+{
+    signal(SIGINT, intr);
+}
+
+public fixintr()
+{
+    signal(SIGINT, dbintr);
+}
+
+/*
+ * Resume execution.
+ */
+
+public resume(signo)
+int signo;
+{
+    register Process p;
+
+    p = process;
+    if (traceexec) {
+	printf("execution resumes at pc 0x%x\n", process->reg[PROGCTR]);
+	fflush(stdout);
+    }
+    pcont(p, signo);
+    pc = process->reg[PROGCTR];
+    if (traceexec) {
+	printf("execution stops at pc 0x%x on sig %d\n",
+	    process->reg[PROGCTR], p->signo);
+	fflush(stdout);
+    }
+    if (p->status != STOPPED) {
+	if (p->signo != 0) {
+	    error("program terminated by signal %d", p->signo);
+	} else if (not runfirst) {
+	    error("program unexpectedly exited with %d", p->exitval);
+	}
+    }
+}
+
+/*
+ * Continue execution up to the next source line.
+ *
+ * There are two ways to define the next source line depending on what
+ * is desired when a procedure or function call is encountered.  Step
+ * stops at the beginning of the procedure or call; next skips over it.
+ */
+
+/*
+ * Stepc is what is called when the step command is given.
+ * It has to play with the "isstopped" information.
+ */
+
+public stepc()
+{
+    if (not isstopped) {
+	error("can't continue execution");
+    }
+    isstopped = false;
+    dostep(false);
+    isstopped = true;
+}
+
+public next()
+{
+    if (not isstopped) {
+	error("can't continue execution");
+    }
+    isstopped = false;
+    dostep(true);
+    isstopped = true;
+}
+
+/*
+ * Single-step over the current machine instruction.
+ *
+ * If we're single-stepping by source line we want to step to the
+ * next source line.  Otherwise we're going to continue so there's
+ * no reason to do all the work necessary to single-step to the next
+ * source line.
+ */
+
+private stepover()
+{
+    Boolean b;
+
+    if (single_stepping) {
+	dostep(false);
+    } else {
+	b = inst_tracing;
+	inst_tracing = true;
+	dostep(false);
+	inst_tracing = b;
+    }
+}
+
+/*
+ * Resume execution up to the given address.  It is assumed that
+ * no breakpoints exist between the current address and the one
+ * we're stepping to.  This saves us from setting all the breakpoints.
+ */
+
+public stepto(addr)
+Address addr;
+{
+    setbp(addr);
+    resume(DEFSIG);
+    unsetbp(addr);
+    if (not isbperr()) {
+	printstatus();
+    }
+}
+
+/*
+ * Print the status of the process.
+ * This routine does not return.
+ */
+
+public printstatus()
+{
+    int status;
+
+    if (process->status == FINISHED) {
+	exit(0);
+    } else {
+	curfunc = whatblock(pc);
+	getsrcpos();
+	if (process->signo == SIGINT) {
+	    isstopped = true;
+	    printerror();
+	} else if (isbperr() and isstopped) {
+	    printf("stopped ");
+	    printloc();
+	    putchar('\n');
+	    if (curline > 0) {
+		printlines(curline, curline);
+	    } else {
+		printinst(pc, pc);
+	    }
+	    erecover();
+	} else {
+	    fixbps();
+	    fixintr();
+	    isstopped = true;
+	    printerror();
+	}
+    }
+}
+
+/*
+ * Print out the current location in the debuggee.
+ */
+
+public printloc()
+{
+    printf("in ");
+    printname(stdout, curfunc);
+    putchar(' ');
+    if (curline > 0 and not useInstLoc) {
+	printsrcpos();
+    } else {
+	useInstLoc = false;
+	curline = 0;
+	printf("at 0x%x", pc);
+    }
+}
+
+/*
+ * Some functions for testing the state of the process.
+ */
+
+public Boolean notstarted(p)
+Process p;
+{
+    return (Boolean) (p->status == NOTSTARTED);
+}
+
+public Boolean isfinished(p)
+Process p;
+{
+    return (Boolean) (p->status == FINISHED);
+}
+
+/*
+ * Return the signal number which stopped the process.
+ */
+
+public Integer errnum(p)
+Process p;
+{
+    return p->signo;
+}
+
+/*
+ * Return the termination code of the process.
+ */
+
+public Integer exitcode(p)
+Process p;
+{
+    return p->exitval;
+}
+
+/*
+ * These routines are used to access the debuggee process from
+ * outside this module.
+ *
+ * They invoke "pio" which eventually leads to a call to "ptrace".
+ * The system generates an I/O error when a ptrace fails.  During reads
+ * these are ignored, during writes they are reported as an error, and
+ * for anything else they cause a fatal error.
+ */
+
+extern Intfunc *onsyserr();
+
+private badaddr;
+private read_err(), write_err();
+
+/*
+ * Read from the process' instruction area.
+ */
+
+public iread(buff, addr, nbytes)
+char *buff;
+Address addr;
+int nbytes;
+{
+    Intfunc *f;
+
+    f = onsyserr(EIO, read_err);
+    badaddr = addr;
+    if (coredump) {
+	coredump_readtext(buff, addr, nbytes);
+    } else {
+	pio(process, PREAD, TEXTSEG, buff, addr, nbytes);
+    }
+    onsyserr(EIO, f);
+}
+
+/* 
+ * Write to the process' instruction area, usually in order to set
+ * or unset a breakpoint.
+ */
+
+public iwrite(buff, addr, nbytes)
+char *buff;
+Address addr;
+int nbytes;
+{
+    Intfunc *f;
+
+    if (coredump) {
+	error("no process to write to");
+    }
+    f = onsyserr(EIO, write_err);
+    badaddr = addr;
+    pio(process, PWRITE, TEXTSEG, buff, addr, nbytes);
+    onsyserr(EIO, f);
+}
+
+/*
+ * Read for the process' data area.
+ */
+
+public dread(buff, addr, nbytes)
+char *buff;
+Address addr;
+int nbytes;
+{
+    Intfunc *f;
+
+    f = onsyserr(EIO, read_err);
+    badaddr = addr;
+    if (coredump) {
+	coredump_readdata(buff, addr, nbytes);
+    } else {
+	pio(process, PREAD, DATASEG, buff, addr, nbytes);
+    }
+    onsyserr(EIO, f);
+}
+
+/*
+ * Write to the process' data area.
+ */
+
+public dwrite(buff, addr, nbytes)
+char *buff;
+Address addr;
+int nbytes;
+{
+    Intfunc *f;
+
+    if (coredump) {
+	error("no process to write to");
+    }
+    f = onsyserr(EIO, write_err);
+    badaddr = addr;
+    pio(process, PWRITE, DATASEG, buff, addr, nbytes);
+    onsyserr(EIO, f);
+}
+
+/*
+ * Trap for errors in reading or writing to a process.
+ * The current approach is to "ignore" read errors and complain
+ * bitterly about write errors.
+ */
+
+private read_err()
+{
+    /*
+     * Ignore.
+     */
+}
+
+private write_err()
+{
+    error("can't write to process (address 0x%x)", badaddr);
+}
+
+/*
+ * Ptrace interface.
+ */
+
+/*
+ * This magic macro enables us to look at the process' registers
+ * in its user structure.
+ */
+
+#define regloc(reg)     (ctob(UPAGES) + ( sizeof(int) * (reg) ))
+
+#define WMASK           (~(sizeof(Word) - 1))
+#define cachehash(addr) ((unsigned) ((addr >> 2) % CSIZE))
+
+#define FIRSTSIG        SIGINT
+#define LASTSIG         SIGQUIT
+#define ischild(pid)    ((pid) == 0)
+#define traceme()       ptrace(0, 0, 0, 0)
+#define setrep(n)       (1 << ((n)-1))
+#define istraced(p)     (p->sigset&setrep(p->signo))
+
+/*
+ * Ptrace options (specified in first argument).
+ */
+
+#define UREAD   3       /* read from process's user structure */
+#define UWRITE  6       /* write to process's user structure */
+#define IREAD   1       /* read from process's instruction space */
+#define IWRITE  4       /* write to process's instruction space */
+#define DREAD   2       /* read from process's data space */
+#define DWRITE  5       /* write to process's data space */
+#define CONT    7       /* continue stopped process */
+#define SSTEP   9       /* continue for approximately one instruction */
+#define PKILL   8       /* terminate the process */
+
+/*
+ * Start up a new process by forking and exec-ing the
+ * given argument list, returning when the process is loaded
+ * and ready to execute.  The PROCESS information (pointed to
+ * by the first argument) is appropriately filled.
+ *
+ * If the given PROCESS structure is associated with an already running
+ * process, we terminate it.
+ */
+
+/* VARARGS2 */
+private pstart(p, argv, infile, outfile)
+Process p;
+String argv[];
+String infile;
+String outfile;
+{
+    int status;
+    Fileid in, out;
+
+    if (p->pid != 0) {			/* child already running? */
+	ptrace(PKILL, p->pid, 0, 0);	/* ... kill it! */
+	pwait(p->pid, &status);		/* wait for it to exit */
+	unptraced(p->pid);
+    }
+    psigtrace(p, SIGTRAP, true);
+    p->pid = vfork();
+    if (p->pid == -1) {
+	panic("can't fork");
+    }
+    if (ischild(p->pid)) {
+/*        setpgrp (p->pid, p->pid);  */
+	traceme();
+	if (infile != nil) {
+	    in = open(infile, 0);
+	    if (in == -1) {
+		write(2, "can't read ", 11);
+		write(2, infile, strlen(infile));
+		write(2, "\n", 1);
+		_exit(1);
+	    }
+	    fswap(0, in);
+	}
+	if (outfile != nil) {
+	    out = creat(outfile, 0666);
+	    if (out == -1) {
+		write(2, "can't write ", 12);
+		write(2, outfile, strlen(outfile));
+		write(2, "\n", 1);
+		_exit(1);
+	    }
+	    fswap(1, out);
+	}
+	execv(argv[0], argv);
+	write(2, "can't exec ", 11);
+	write(2, argv[0], strlen(argv[0]));
+	write(2, "\n", 1);
+	_exit(1);
+    }
+    pwait(p->pid, &status);
+    getinfo(p, status);
+    savetty(stdout, &(p->ttyinfo));
+    if (p->status != STOPPED) {
+	error("program could not begin execution");
+    }
+    ptraced(p->pid);
+}
+
+/*
+ * Continue a stopped process.  The first argument points to a Process
+ * structure.  Before the process is restarted it's user area is modified
+ * according to the values in the structure.  When this routine finishes,
+ * the structure has the new values from the process's user area.
+ *
+ * Pcont terminates when the process stops with a signal pending that
+ * is being traced (via psigtrace), or when the process terminates.
+ */
+
+private pcont(p, signo)
+Process p;
+int signo;
+{
+    int status;
+
+    if (p->pid == 0) {
+	error("program not active");
+    }
+    restoretty(stdout, &(p->ttyinfo));
+    do {
+	setinfo(p, signo);
+	sigs_off();
+	if (ptrace(CONT, p->pid, p->reg[PROGCTR], p->signo) < 0) {
+	    panic("error %d trying to continue process", errno);
+	}
+	pwait(p->pid, &status);
+	savetty(stdout, &(p->ttyinfo));
+	sigs_on();
+	getinfo(p, status);
+    } while (p->status == STOPPED and not istraced(p));
+}
+
+/*
+ * Single step as best ptrace can.
+ */
+
+public pstep(p)
+Process p;
+{
+    int status;
+
+    setinfo(p, DEFSIG);
+    sigs_off();
+    restoretty(stdout, &(p->ttyinfo));
+    ptrace(SSTEP, p->pid, p->reg[PROGCTR], p->signo);
+    pwait(p->pid, &status);
+    savetty(stdout, &(p->ttyinfo));
+    sigs_on();
+    getinfo(p, status);
+}
+
+/*
+ * Return from execution when the given signal is pending.
+ */
+
+public psigtrace(p, sig, sw)
+Process p;
+int sig;
+Boolean sw;
+{
+    if (sw) {
+	p->sigset |= setrep(sig);
+    } else {
+	p->sigset &= ~setrep(sig);
+    }
+}
+
+/*
+ * Don't catch any signals.
+ * Particularly useful when letting a process finish uninhibited.
+ */
+
+public unsetsigtraces(p)
+Process p;
+{
+    p->sigset = 0;
+}
+
+/*
+ * Turn off attention to signals not being caught.
+ */
+
+private Intfunc *sigfunc[NSIG];
+
+private sigs_off()
+{
+    register int i;
+
+    for (i = FIRSTSIG; i < LASTSIG; i++) {
+	if (i != SIGKILL) {
+	    sigfunc[i] = signal(i, SIG_IGN);
+	}
+    }
+}
+
+/*
+ * Turn back on attention to signals.
+ */
+
+private sigs_on()
+{
+    register int i;
+
+    for (i = FIRSTSIG; i < LASTSIG; i++) {
+	if (i != SIGKILL) {
+	    signal(i, sigfunc[i]);
+	}
+    }
+}
+
+/*
+ * Get process information from user area.
+ */
+
+private int rloc[] ={
+    R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, AP, FP, SP, PC
+};
+
+private getinfo(p, status)
+register Process p;
+register int status;
+{
+    register int i;
+
+/*    ioctl(fileno(stdout), TIOCSPGRP, getpgrp (0)); */
+    p->signo = (status&0177);
+    p->exitval = ((status >> 8)&0377);
+    if (p->signo != STOPPED) {
+	p->status = FINISHED;
+	p->pid = 0;
+    } else {
+	p->status = p->signo;
+	p->signo = p->exitval;
+	p->exitval = 0;
+	p->mask = ptrace(UREAD, p->pid, regloc(PS), 0);
+	for (i = 0; i < NREG; i++) {
+	    p->reg[i] = ptrace(UREAD, p->pid, regloc(rloc[i]), 0);
+	    p->oreg[i] = p->reg[i];
+	}
+    }
+}
+
+/*
+ * Set process's user area information from given process structure.
+ */
+
+private setinfo(p, signo)
+register Process p;
+int signo;
+{
+    register int i;
+    register int r;
+
+    if (signo == DEFSIG) {
+	if (istraced(p)) {
+	    p->signo = 0;
+	}
+    } else {
+	p->signo = signo;
+    }
+    for (i = 0; i < NREG; i++) {
+	if ((r = p->reg[i]) != p->oreg[i]) {
+	    ptrace(UWRITE, p->pid, regloc(rloc[i]), r);
+	}
+    }
+/*    ioctl(fileno(stdout), TIOCSPGRP, getpgrp (p->pid));  */
+}
+
+/*
+ * Structure for reading and writing by words, but dealing with bytes.
+ */
+
+typedef union {
+    Word pword;
+    Byte pbyte[sizeof(Word)];
+} Pword;
+
+/*
+ * Read (write) from (to) the process' address space.
+ * We must deal with ptrace's inability to look anywhere other
+ * than at a word boundary.
+ */
+
+private Word fetch();
+private store();
+
+private pio(p, op, seg, buff, addr, nbytes)
+Process p;
+PioOp op;
+PioSeg seg;
+char *buff;
+Address addr;
+int nbytes;
+{
+    register int i;
+    register Address newaddr;
+    register char *cp;
+    char *bufend;
+    Pword w;
+    Address wordaddr;
+    int byteoff;
+
+    if (p->status != STOPPED) {
+	error("program is not active");
+    }
+    cp = buff;
+    newaddr = addr;
+    wordaddr = (newaddr&WMASK);
+    if (wordaddr != newaddr) {
+	w.pword = fetch(p, seg, wordaddr);
+	for (i = newaddr - wordaddr; i < sizeof(Word) and nbytes > 0; i++) {
+	    if (op == PREAD) {
+		*cp++ = w.pbyte[i];
+	    } else {
+		w.pbyte[i] = *cp++;
+	    }
+	    nbytes--;
+	}
+	if (op == PWRITE) {
+	    store(p, seg, wordaddr, w.pword);
+	}
+	newaddr = wordaddr + sizeof(Word);
+    }
+    byteoff = (nbytes&(~WMASK));
+    nbytes -= byteoff;
+    bufend = cp + nbytes;
+    while (cp < bufend) {
+	if (op == PREAD) {
+	    *((Word *) cp) = fetch(p, seg, newaddr);
+	} else {
+	    store(p, seg, newaddr, *((Word *) cp));
+	}
+	cp += sizeof(Word);
+	newaddr += sizeof(Word);
+    }
+    if (byteoff > 0) {
+	w.pword = fetch(p, seg, newaddr);
+	for (i = 0; i < byteoff; i++) {
+	    if (op == PREAD) {
+		*cp++ = w.pbyte[i];
+	    } else {
+		w.pbyte[i] = *cp++;
+	    }
+	}
+	if (op == PWRITE) {
+	    store(p, seg, newaddr, w.pword);
+	}
+    }
+}
+
+/*
+ * Get a word from a process at the given address.
+ * The address is assumed to be on a word boundary.
+ *
+ * A simple cache scheme is used to avoid redundant ptrace calls
+ * to the instruction space since it is assumed to be pure.
+ *
+ * It is necessary to use a write-through scheme so that
+ * breakpoints right next to each other don't interfere.
+ */
+
+private Integer nfetchs, nreads, nwrites;
+
+private Word fetch(p, seg, addr)
+Process p;
+PioSeg seg;
+register int addr;
+{
+    register CacheWord *wp;
+    register Word w;
+
+    switch (seg) {
+	case TEXTSEG:
+	    ++nfetchs;
+	    wp = &p->word[cachehash(addr)];
+	    if (addr == 0 or wp->addr != addr) {
+		++nreads;
+		w = ptrace(IREAD, p->pid, addr, 0);
+		wp->addr = addr;
+		wp->val = w;
+	    } else {
+		w = wp->val;
+	    }
+	    break;
+
+	case DATASEG:
+	    w = ptrace(DREAD, p->pid, addr, 0);
+	    break;
+
+	default:
+	    panic("fetch: bad seg %d", seg);
+	    /* NOTREACHED */
+    }
+    return w;
+}
+
+/*
+ * Put a word into the process' address space at the given address.
+ * The address is assumed to be on a word boundary.
+ */
+
+private store(p, seg, addr, data)
+Process p;
+PioSeg seg;
+int addr;
+Word data;
+{
+    register CacheWord *wp;
+
+    switch (seg) {
+	case TEXTSEG:
+	    ++nwrites;
+	    wp = &p->word[cachehash(addr)];
+	    wp->addr = addr;
+	    wp->val = data;
+	    ptrace(IWRITE, p->pid, addr, data);
+	    break;
+
+	case DATASEG:
+	    ptrace(DWRITE, p->pid, addr, data);
+	    break;
+
+	default:
+	    panic("store: bad seg %d", seg);
+	    /* NOTREACHED */
+    }
+}
+
+public printptraceinfo()
+{
+    printf("%d fetchs, %d reads, %d writes\n", nfetchs, nreads, nwrites);
+}
+
+/*
+ * Swap file numbers so as to redirect standard input and output.
+ */
+
+private fswap(oldfd, newfd)
+int oldfd;
+int newfd;
+{
+    if (oldfd != newfd) {
+	close(oldfd);
+	dup(newfd);
+	close(newfd);
+    }
+}
diff --git a/dbx/process.h b/dbx/process.h
new file mode 100644
index 0000000..d846954
--- /dev/null
+++ b/dbx/process.h
@@ -0,0 +1,41 @@
+#ifndef process_h
+#define process_h
+
+typedef struct Process *Process;
+
+Process process;
+
+#define DEFSIG -1
+
+#include "machine.h"
+
+process_init(/*  */);
+Word reg(/* n */);
+setreg(/* n, w */);
+start(/* argv, infile, outfile */);
+arginit(/*  */);
+newarg(/* arg */);
+inarg(/* filename */);
+outarg(/* filename */);
+run(/*  */);
+cont(/* signo */);
+fixintr(/*  */);
+resume(/* signo */);
+stepc(/*  */);
+next(/*  */);
+stepto(/* addr */);
+printstatus(/*  */);
+printloc(/*  */);
+Boolean notstarted(/* p */);
+Boolean isfinished(/* p */);
+Integer errnum(/* p */);
+Integer exitcode(/* p */);
+iread(/* buff, addr, nbytes */);
+iwrite(/* buff, addr, nbytes */);
+dread(/* buff, addr, nbytes */);
+dwrite(/* buff, addr, nbytes */);
+pstep(/* p */);
+psigtrace(/* p, sig, sw */);
+unsetsigtraces(/* p */);
+printptraceinfo(/*  */);
+#endif
diff --git a/dbx/runtime.c b/dbx/runtime.c
new file mode 100644
index 0000000..0a72982
--- /dev/null
+++ b/dbx/runtime.c
@@ -0,0 +1,662 @@
+
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)runtime.c 1.9 8/14/83";
+
+/*
+ * Runtime organization dependent routines, mostly dealing with
+ * activation records.
+ */
+
+#include "defs.h"
+#include "runtime.h"
+#include "process.h"
+#include "machine.h"
+#include "events.h"
+#include "mappings.h"
+#include "symbols.h"
+#include "tree.h"
+#include "eval.h"
+#include "operators.h"
+#include "object.h"
+#include <sys/param.h>
+
+#ifndef public
+typedef struct Frame *Frame;
+
+#include "machine.h"
+#endif
+
+#define NSAVEREG 12
+
+struct Frame {
+    Integer condition_handler;
+    Integer mask;
+    Address save_ap;		/* argument pointer */
+    Address save_fp;		/* frame pointer */
+    Address save_pc;		/* program counter */
+    Word save_reg[NSAVEREG];	/* not necessarily there */
+};
+
+private Boolean walkingstack = false;
+
+/*
+ * Set a frame to the current activation record.
+ */
+
+private getcurframe(frp)
+register Frame frp;
+{
+    register int i;
+
+    checkref(frp);
+    frp->mask = reg(NREG);
+    frp->save_ap = reg(ARGP);
+    frp->save_fp = reg(FRP);
+    frp->save_pc = reg(PROGCTR) + 1;
+    for (i = 0; i < NSAVEREG; i++) {
+	frp->save_reg[i] = reg(i);
+    }
+}
+
+/*
+ * Return a pointer to the next activation record up the stack.
+ * Return nil if there is none.
+ * Writes over space pointed to by given argument.
+ */
+
+#define bis(b, n) ((b & (1 << (n))) != 0)
+
+private Frame nextframe(frp)
+Frame frp;
+{
+    register Frame newfrp;
+    struct Frame frame;
+    register Integer i, j, mask;
+    Address prev_frame, callpc; 
+    static Integer ntramp = 0;
+
+    newfrp = frp;
+    prev_frame = frp->save_fp;
+
+/*
+ *  The check for interrupt generated frames is taken from adb with only
+ *  partial understanding.  If you're in "sub" and on a sigxxx "sigsub"
+ *  gets control, then the stack does NOT look like <main, sub, sigsub>.
+ *
+ *  As best I can make out it looks like:
+ *
+ *     <main, (machine check exception block + sub), sysframe, sigsub>.
+ *
+ *  When the signal occurs an exception block and a frame for the routine
+ *  in which it occured are pushed on the user stack.  Then another frame
+ *  is pushed corresponding to a call from the kernel to sigsub.
+ *
+ *  The addr in sub at which the exception occured is not in sub.save_pc
+ *  but in the machine check exception block.  It is at the magic address
+ *  fp + 84.
+ *
+ *  The current approach ignores the sys_frame (what adb reports as sigtramp)
+ *  and takes the pc for sub from the exception block.  This allows the
+ *  "where" command to report <main, sub, sigsub>, which seems reasonable.
+ */
+
+nextf:
+    dread(&frame, prev_frame, sizeof(struct Frame));
+    if (ntramp == 1) {
+	dread(&callpc, prev_frame + 84, sizeof(callpc));
+    } else {
+	callpc = frame.save_pc;
+    }
+    if (frame.save_fp == nil) {
+	newfrp = nil;
+    } else if (callpc > 0x80000000 - 0x200 * UPAGES ) {
+	 ntramp++;
+	 prev_frame = frame.save_fp;
+	 goto nextf;
+    } else {
+	frame.save_pc = callpc;
+        ntramp = 0;
+	mask = ((frame.mask >> 16) & 0x0fff);
+	j = 0;
+	for (i = 0; i < NSAVEREG; i++) {
+	    if (bis(mask, i)) {
+		newfrp->save_reg[i] = frame.save_reg[j];
+		++j;
+	    }
+	}
+	newfrp->condition_handler = frame.condition_handler;
+	newfrp->mask = mask;
+	newfrp->save_ap = frame.save_ap;
+	newfrp->save_fp = frame.save_fp;
+	newfrp->save_pc = frame.save_pc;
+    }
+    return newfrp;
+}
+
+/*
+ * Return the frame associated with the given function.
+ * If the function is nil, return the most recently activated frame.
+ *
+ * Static allocation for the frame.
+ */
+
+public Frame findframe(f)
+Symbol f;
+{
+    register Frame frp;
+    static struct Frame frame;
+    Symbol p;
+    Boolean done;
+
+    frp = &frame;
+    getcurframe(frp);
+    if (f != nil) {
+	done = false;
+	do {
+	    p = whatblock(frp->save_pc);
+	    if (p == f) {
+		done = true;
+	    } else if (p == program) {
+		done = true;
+		frp = nil;
+	    } else {
+		frp = nextframe(frp);
+		if (frp == nil) {
+		    done = true;
+		}
+	    }
+	} while (not done);
+    }
+    return frp;
+}
+
+/*
+ * Find the return address of the current procedure/function.
+ */
+
+public Address return_addr()
+{
+    Frame frp;
+    Address addr;
+    struct Frame frame;
+
+    frp = &frame;
+    getcurframe(frp);
+    frp = nextframe(frp);
+    if (frp == nil) {
+	addr = 0;
+    } else {
+	addr = frp->save_pc;
+    }
+    return addr;
+}
+
+/*
+ * Push the value associated with the current function.
+ */
+
+public pushretval(len, isindirect)
+Integer len;
+Boolean isindirect;
+{
+    Word r0;
+
+    r0 = reg(0);
+    if (isindirect) {
+	rpush((Address) r0, len);
+    } else {
+	switch (len) {
+	    case sizeof(char):
+		push(char, r0);
+		break;
+
+	    case sizeof(short):
+		push(short, r0);
+		break;
+
+	    default:
+		if (len == sizeof(Word)) {
+		    push(Word, r0);
+		} else if (len == 2*sizeof(Word)) {
+		    push(Word, r0);
+		    push(Word, reg(1));
+		} else {
+		    panic("not indirect in pushretval?");
+		}
+		break;
+	}
+    }
+}
+
+/*
+ * Return the base address for locals in the given frame.
+ */
+
+public Address locals_base(frp)
+register Frame frp;
+{
+    return (frp == nil) ? reg(FRP) : frp->save_fp;
+}
+
+/*
+ * Return the base address for arguments in the given frame.
+ */
+
+public Address args_base(frp)
+register Frame frp;
+{
+    return (frp == nil) ? reg(ARGP) : frp->save_ap;
+}
+
+/*
+ * Return saved register n from the given frame.
+ */
+
+public Word savereg(n, frp)
+register Integer n;
+register Frame frp;
+{
+    register Word w;
+
+    if (frp == nil) {
+	w = reg(n);
+    } else {
+	switch (n) {
+	    case ARGP:
+		w = frp->save_ap;
+		break;
+
+	    case FRP:
+		w = frp->save_fp;
+		break;
+
+	    case STKP:
+		w = reg(STKP);
+		break;
+
+	    case PROGCTR:
+		w = frp->save_pc;
+		break;
+
+	    default:
+		assert(n >= 0 and n < NSAVEREG);
+		w = frp->save_reg[n];
+		break;
+	}
+    }
+    return w;
+}
+
+/*
+ * Return the nth argument to the current procedure.
+ */
+
+public Word argn(n, frp)
+Integer n;
+Frame frp;
+{
+    Word w;
+
+    dread(&w, args_base(frp) + (n * sizeof(Word)), sizeof(w));
+    return w;
+}
+
+/*
+ * Calculate the entry address for a procedure or function parameter,
+ * given the address of the descriptor.
+ */
+
+public Address fparamaddr(a)
+Address a;
+{
+    Address r;
+
+    dread(&r, a, sizeof(r));
+    return r;
+}
+
+/*
+ * Print a list of currently active blocks starting with most recent.
+ */
+
+public wherecmd()
+{
+    walkstack(false);
+}
+
+/*
+ * Dump the world to the given file.
+ * Like "where", but variables are dumped also.
+ */
+
+public dump()
+{
+    walkstack(true);
+}
+
+/*
+ * Walk the stack of active procedures printing information
+ * about each active procedure.
+ */
+
+private walkstack(dumpvariables)
+Boolean dumpvariables;
+{
+    register Frame frp;
+    register Symbol f;
+    register Boolean save;
+    register Lineno line;
+    struct Frame frame;
+
+    if (notstarted(process)) {
+	error("program is not active");
+    } else {
+	save = walkingstack;
+	walkingstack = true;
+	frp = &frame;
+	getcurframe(frp);
+	f = whatblock(frp->save_pc);
+	do {
+	    printf("%s", symname(f));
+	    if (not isinline(f)) {
+		printparams(f, frp);
+	    }
+	    line = srcline(frp->save_pc - 1);
+	    if (line != 0) {
+		printf(", line %d", line);
+		printf(" in \"%s\"\n", srcfilename(frp->save_pc - 1));
+	    } else {
+		printf(" at 0x%x\n", frp->save_pc);
+	    }
+	    if (dumpvariables) {
+		dumpvars(f, frp);
+		putchar('\n');
+	    }
+	    if (isinline(f)) {
+		f = container(f);
+	    } else {
+		frp = nextframe(frp);
+		if (frp != nil) {
+		    f = whatblock(frp->save_pc);
+		}
+	    }
+	} while (frp != nil and f != program);
+	if (dumpvariables) {
+	    printf("in \"%s\":\n", symname(program));
+	    dumpvars(program, nil);
+	    putchar('\n');
+	}
+	walkingstack = save;
+    }
+}
+
+/*
+ * Find the entry point of a procedure or function.
+ */
+
+public findbeginning(f)
+Symbol f;
+{
+    f->symvalue.funcv.beginaddr += 2;
+}
+
+/*
+ * Return the address corresponding to the first line in a function.
+ */
+
+public Address firstline(f)
+Symbol f;
+{
+    Address addr;
+
+    addr = codeloc(f);
+    while (linelookup(addr) == 0 and addr < objsize) {
+	++addr;
+    }
+    if (addr == objsize) {
+	addr = -1;
+    }
+    return addr;
+}
+
+/*
+ * Catcher drops strike three ...
+ */
+
+public runtofirst()
+{
+    Address addr;
+
+    addr = pc;
+    while (linelookup(addr) == 0 and addr < objsize) {
+	++addr;
+    }
+    if (addr < objsize) {
+	stepto(addr);
+    }
+}
+
+/*
+ * Return the address corresponding to the end of the program.
+ *
+ * We look for the entry to "exit".
+ */
+
+public Address lastaddr()
+{
+    register Symbol s;
+
+    s = lookup(identname("exit", true));
+    if (s == nil) {
+	panic("can't find exit");
+    }
+    return codeloc(s);
+}
+
+/*
+ * Decide if the given function is currently active.
+ *
+ * We avoid calls to "findframe" during a stack trace for efficiency.
+ * Presumably information evaluated while walking the stack is active.
+ */
+
+public Boolean isactive(f)
+Symbol f;
+{
+    register Boolean b;
+
+    if (isfinished(process)) {
+	b = false;
+    } else {
+	if (walkingstack or f == program or
+	  (ismodule(f) and isactive(container(f)))) {
+	    b = true;
+	} else {
+	    b = (Boolean) (findframe(f) != nil);
+	}
+    }
+    return b;
+}
+
+/*
+ * Evaluate a call to a procedure.
+ */
+
+public callproc(procnode, arglist)
+Node procnode;
+Node arglist;
+{
+    Symbol proc;
+    Integer argc;
+
+    if (procnode->op != O_SYM) {
+	beginerrmsg();
+	fprintf(stderr, "can't call \"");
+	prtree(stderr, procnode);
+	fprintf(stderr, "\"");
+	enderrmsg();
+    }
+    assert(procnode->op == O_SYM);
+    proc = procnode->value.sym;
+    if (not isblock(proc)) {
+	error("\"%s\" is not a procedure or function", symname(proc));
+    }
+    pushenv();
+    pc = codeloc(proc);
+    argc = pushargs(proc, arglist);
+    beginproc(proc, argc);
+    isstopped = true;
+    event_once(build(O_EQ, build(O_SYM, pcsym), build(O_SYM, retaddrsym)),
+	buildcmdlist(build(O_PROCRTN, proc)));
+    cont();
+    /* NOTREACHED */
+}
+
+/*
+ * Push the arguments on the process' stack.  We do this by first
+ * evaluating them on the "eval" stack, then copying into the process'
+ * space.
+ */
+
+private Integer pushargs(proc, arglist)
+Symbol proc;
+Node arglist;
+{
+    Stack *savesp;
+    int argc, args_size;
+
+    savesp = sp;
+    argc = evalargs(proc, arglist);
+    args_size = sp - savesp;
+    setreg(STKP, reg(STKP) - args_size);
+    dwrite(savesp, reg(STKP), args_size);
+    sp = savesp;
+    return argc;
+}
+
+/*
+ * Evaluate arguments left-to-right.
+ */
+
+private Integer evalargs(proc, arglist)
+Symbol proc;
+Node arglist;
+{
+    Node p, exp;
+    Symbol arg;
+    Stack *savesp;
+    Address addr;
+    Integer count;
+
+    savesp = sp;
+    count = 0;
+    arg = proc->chain;
+    for (p = arglist; p != nil; p = p->value.arg[1]) {
+	if (p->op != O_COMMA) {
+	    panic("evalargs: arglist missing comma");
+	}
+	if (arg == nil) {
+	    sp = savesp;
+	    error("too many parameters to %s", symname(proc));
+	}
+	exp = p->value.arg[0];
+	if (not compatible(arg->type, exp->nodetype)) {
+	    sp = savesp;
+	    error("expression for parameter %s is of wrong type", symname(arg));
+	}
+	if (arg->class == REF) {
+	    if (exp->op != O_RVAL) {
+		sp = savesp;
+		error("variable expected for parameter \"%s\"", symname(arg));
+	    }
+	    addr = lval(exp->value.arg[0]);
+	    push(Address, addr);
+	} else {
+	    eval(exp);
+	}
+	arg = arg->chain;
+	++count;
+    }
+    if (arg != nil) {
+	sp = savesp;
+	error("not enough parameters to %s", symname(proc));
+    }
+    return count;
+}
+
+public procreturn(f)
+Symbol f;
+{
+    flushoutput();
+    putchar('\n');
+    printname(stdout, f);
+    printf(" returns successfully\n", symname(f));
+    popenv();
+    erecover();
+}
+
+/*
+ * Push the current environment.
+ */
+
+private pushenv()
+{
+    push(Address, pc);
+    push(Lineno, curline);
+    push(String, cursource);
+    push(Boolean, isstopped);
+    push(Symbol, curfunc);
+    push(Word, reg(PROGCTR));
+    push(Word, reg(STKP));
+}
+
+/*
+ * Pop back to the real world.
+ */
+
+public popenv()
+{
+    register String filename;
+
+    setreg(STKP, pop(Word));
+    setreg(PROGCTR, pop(Word));
+    curfunc = pop(Symbol);
+    isstopped = pop(Boolean);
+    filename = pop(String);
+    curline = pop(Lineno);
+    pc = pop(Address);
+    setsource(filename);
+}
+
+/*
+ * Flush the debuggee's standard output.
+ *
+ * This is VERY dependent on the use of stdio.
+ */
+
+public flushoutput()
+{
+    register Symbol p, iob;
+    register Stack *savesp;
+
+    p = lookup(identname("fflush", true));
+    while (p != nil and not isblock(p)) {
+	p = p->next_sym;
+    }
+    if (p != nil) {
+	iob = lookup(identname("_iob", true));
+	if (iob != nil) {
+	    pushenv();
+	    pc = codeloc(p);
+	    savesp = sp;
+	    push(long, address(iob, nil) + sizeof(struct _iobuf));
+	    setreg(STKP, reg(STKP) - sizeof(long));
+	    dwrite(savesp, reg(STKP), sizeof(long));
+	    sp = savesp;
+	    beginproc(p, 1);
+	    stepto(return_addr());
+	    popenv();
+	}
+    }
+}
diff --git a/dbx/runtime.h b/dbx/runtime.h
new file mode 100644
index 0000000..5d4a644
--- /dev/null
+++ b/dbx/runtime.h
@@ -0,0 +1,25 @@
+#ifndef runtime_h
+#define runtime_h
+typedef struct Frame *Frame;
+
+#include "machine.h"
+Frame findframe(/* f */);
+Address return_addr(/*  */);
+pushretval(/* len, isindirect */);
+Address locals_base(/* frp */);
+Address args_base(/* frp */);
+Word savereg(/* n, frp */);
+Word argn(/* n, frp */);
+Address fparamaddr(/* a */);
+wherecmd(/*  */);
+dump(/*  */);
+findbeginning(/* f */);
+Address firstline(/* f */);
+runtofirst(/*  */);
+Address lastaddr(/*  */);
+Boolean isactive(/* f */);
+callproc(/* procnode, arglist */);
+procreturn(/* f */);
+popenv(/*  */);
+flushoutput(/*  */);
+#endif
diff --git a/dbx/scanner.c b/dbx/scanner.c
new file mode 100644
index 0000000..30dc17f
--- /dev/null
+++ b/dbx/scanner.c
@@ -0,0 +1,641 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)scanner.c 1.8 8/5/83";
+
+/*
+ * Debugger scanner.
+ */
+
+#include "defs.h"
+#include "scanner.h"
+#include "main.h"
+#include "keywords.h"
+#include "tree.h"
+#include "symbols.h"
+#include "names.h"
+#include "y.tab.h"
+
+#ifndef public
+typedef int Token;
+#endif
+
+public String initfile = ".dbxinit";
+
+typedef enum { WHITE, ALPHA, NUM, OTHER } Charclass;
+
+private Charclass class[256 + 1];
+private Charclass *lexclass = class + 1;
+
+#define isdigit(c) (lexclass[c] == NUM)
+#define isalnum(c) (lexclass[c] == ALPHA or lexclass[c] == NUM)
+#define ishexdigit(c) ( \
+    isdigit(c) or (c >= 'a' and c <= 'f') or (c >= 'A' and c <= 'F') \
+)
+
+#define MAXLINESIZE 1024
+
+private File in;
+private Char linebuf[MAXLINESIZE];
+private Char *curchar;
+
+#define MAXINCLDEPTH 10
+
+private struct {
+    File savefile;
+    Filename savefn;
+    int savelineno;
+} inclinfo[MAXINCLDEPTH];
+
+private unsigned int curinclindex;
+
+private Token getident();
+private Token getnum();
+private Token getstring();
+private Boolean eofinput();
+private Char charcon();
+private Char charlookup();
+
+private enterlexclass(class, s)
+Charclass class;
+String s;
+{
+    register char *p;
+
+    for (p = s; *p != '\0'; p++) {
+	lexclass[*p] = class;
+    }
+}
+
+public scanner_init()
+{
+    register Integer i;
+
+    for (i = 0; i < 257; i++) {
+	class[i] = OTHER;
+    }
+    enterlexclass(WHITE, " \t");
+    enterlexclass(ALPHA, "abcdefghijklmnopqrstuvwxyz");
+    enterlexclass(ALPHA, "ABCDEFGHIJKLMNOPQRSTUVWXYZ_$");
+    enterlexclass(NUM, "0123456789");
+    in = stdin;
+    errfilename = nil;
+    errlineno = 0;
+    curchar = linebuf;
+    linebuf[0] = '\0';
+}
+
+/*
+ * Read a single token.
+ *
+ * Input is line buffered.
+ *
+ * There are two "modes" of operation:  one as in a compiler,
+ * and one for reading shell-like syntax.
+ */
+
+private Boolean shellmode;
+
+public Token yylex()
+{
+    register int c;
+    register char *p;
+    register Token t;
+    String line;
+
+    p = curchar;
+    if (*p == '\0') {
+	do {
+	    if (isterm(in)) {
+		printf("(%s) ", cmdname);
+		fflush(stdout);
+	    }
+	    line = fgets(linebuf, MAXLINESIZE, in);
+	} while (line == nil and not eofinput());
+	if (line == nil) {
+	    c = EOF;
+	} else {
+	    p = linebuf;
+	    while (lexclass[*p] == WHITE) {
+		p++;
+	    }
+	    shellmode = false;
+	}
+    } else {
+	while (lexclass[*p] == WHITE) {
+	    p++;
+	}
+    }
+    curchar = p;
+    c = *p;
+    if (lexclass[c] == ALPHA) {
+	t = getident();
+    } else if (lexclass[c] == NUM) {
+	if (shellmode) {
+	    t = getident();
+	} else {
+	    t = getnum();
+	}
+    } else {
+	++curchar;
+	switch (c) {
+	    case '\n':
+		t = '\n';
+		if (errlineno != 0) {
+		    errlineno++;
+		}
+		break;
+
+	    case '"':
+	    case '\'':
+		t = getstring();
+		break;
+
+	    case '.':
+		if (shellmode) {
+		    --curchar;
+		    t = getident();
+		} else if (isdigit(*curchar)) {
+		    --curchar;
+		    t = getnum();
+		} else {
+		    t = '.';
+		}
+		break;
+
+	    case '<':
+		if (not shellmode and *curchar == '<') {
+		    ++curchar;
+		    t = LFORMER;
+		} else {
+		    t = '<';
+		}
+		break;
+
+	    case '>':
+		if (not shellmode and *curchar == '>') {
+		    ++curchar;
+		    t = RFORMER;
+		} else {
+		    t = '>';
+		}
+		break;
+
+	    case '#':
+		if (*curchar == '^') {
+		    ++curchar;
+		    t = ABSTRACTION;
+		} else {
+		    t = '#';
+		}
+		break;
+
+	    case '-':
+		if (shellmode) {
+		    --curchar;
+		    t = getident();
+		} else if (*curchar == '>') {
+		    ++curchar;
+		    t = ARROW;
+		} else {
+		    t = '-';
+		}
+		break;
+
+	    case EOF:
+		t = 0;
+		break;
+
+	    default:
+		if (shellmode and index("!&*()[]", c) == nil) {
+		    --curchar;
+		    t = getident();
+		} else {
+		    t = c;
+		}
+		break;
+	}
+    }
+#   ifdef LEXDEBUG
+	if (lexdebug) {
+	    fprintf(stderr, "yylex returns ");
+	    print_token(stderr, t);
+	    fprintf(stderr, "\n");
+	}
+#   endif
+    return t;
+}
+
+/*
+ * Parser error handling.
+ */
+
+public yyerror(s)
+String s;
+{
+    register Char *p, *tokenbegin, *tokenend;
+    register Integer len;
+
+    if (streq(s, "syntax error")) {
+	beginerrmsg();
+	tokenend = curchar - 1;
+	tokenbegin = tokenend;
+	while (lexclass[*tokenbegin] != WHITE and tokenbegin > &linebuf[0]) {
+	    --tokenbegin;
+	}
+	len = tokenend - tokenbegin + 1;
+	p = tokenbegin;
+	if (p > &linebuf[0]) {
+	    while (lexclass[*p] == WHITE and p > &linebuf[0]) {
+		--p;
+	    }
+	}
+	if (p == &linebuf[0]) {
+	    fprintf(stderr, "unrecognized command \"%.*s\"", len, tokenbegin);
+	} else {
+	    fprintf(stderr, "syntax error");
+	    if (len != 0) {
+		fprintf(stderr, " on \"%.*s\"", len, tokenbegin);
+	    }
+	}
+	enderrmsg();
+    } else {
+	error(s);
+    }
+}
+
+/*
+ * Eat the current line.
+ */
+
+public gobble()
+{
+    curchar = linebuf;
+    linebuf[0] = '\0';
+}
+
+/*
+ * Scan an identifier and check to see if it's a keyword.
+ */
+
+private Token getident()
+{
+    char buf[256];
+    register Char *p, *q;
+    register Token t;
+
+    p = curchar;
+    q = buf;
+    if (shellmode) {
+	do {
+	    *q++ = *p++;
+	} while (index(" \t\n!&<>*[]()", *p) == nil);
+    } else {
+	do {
+	    *q++ = *p++;
+	} while (isalnum(*p));
+    }
+    curchar = p;
+    *q = '\0';
+    yylval.y_name = identname(buf, false);
+    if (not shellmode) {
+	t = findkeyword(yylval.y_name);
+	if (t == nil) {
+	    t = NAME;
+	}
+    } else {
+	t = NAME;
+    }
+    return t;
+}
+
+/*
+ * Scan a number.
+ */
+
+private Token getnum()
+{
+    char buf[256];
+    register Char *p, *q;
+    register Token t;
+    Integer base;
+
+    p = curchar;
+    q = buf;
+    if (*p == '0') {
+	if (*(p+1) == 'x') {
+	    p += 2;
+	    base = 16;
+	} else {
+	    base = 8;
+	}
+    } else {
+	base = 10;
+    }
+    if (base == 16) {
+	do {
+	    *q++ = *p++;
+	} while (ishexdigit(*p));
+    } else {
+	do {
+	    *q++ = *p++;
+	} while (isdigit(*p));
+    }
+    if (*p == '.') {
+	do {
+	    *q++ = *p++;
+	} while (isdigit(*p));
+	if (*p == 'e' or *p == 'E') {
+	    p++;
+	    if (*p == '+' or *p == '-' or isdigit(*p)) {
+		*q++ = 'e';
+		do {
+		    *q++ = *p++;
+		} while (isdigit(*p));
+	    }
+	}
+	*q = '\0';
+	yylval.y_real = atof(buf);
+	t = REAL;
+    } else {
+	*q = '\0';
+	switch (base) {
+	    case 10:
+		yylval.y_int = atol(buf);
+		break;
+
+	    case 8:
+		yylval.y_int = octal(buf);
+		break;
+
+	    case 16:
+		yylval.y_int = hex(buf);
+		break;
+
+	    default:
+		badcaseval(base);
+	}
+	t = INT;
+    }
+    curchar = p;
+    return t;
+}
+
+/*
+ * Convert a string of octal digits to an integer.
+ */
+
+private int octal(s)
+String s;
+{
+    register Char *p;
+    register Integer n;
+
+    n = 0;
+    for (p = s; *p != '\0'; p++) {
+	n = 8*n + (*p - '0');
+    }
+    return n;
+}
+
+/*
+ * Convert a string of hexadecimal digits to an integer.
+ */
+
+private int hex(s)
+String s;
+{
+    register Char *p;
+    register Integer n;
+
+    n = 0;
+    for (p = s; *p != '\0'; p++) {
+	n *= 16;
+	if (*p >= 'a' and *p <= 'f') {
+	    n += (*p - 'a' + 10);
+	} else if (*p >= 'A' and *p <= 'F') {
+	    n += (*p - 'A' + 10);
+	} else {
+	    n += (*p - '0');
+	}
+    }
+    return n;
+}
+
+/*
+ * Scan a string.
+ */
+
+private Token getstring()
+{
+    char buf[256];
+    register Char *p, *q;
+    Boolean endofstring;
+
+    p = curchar;
+    q = buf;
+    endofstring = false;
+    while (not endofstring) {
+	if (*p == '\n' or *p == '\0') {
+	    error("non-terminated string");
+	    endofstring = true;
+	} else if (*p == '"' or *p == '\'') {
+	    if (*(p+1) != *p) {
+		endofstring = true;
+	    } else {
+		*q++ = *p;
+	    }
+	} else {
+	    curchar = p;
+	    *q++ = charcon(p);
+	    p = curchar;
+	}
+	p++;
+    }
+    curchar = p;
+    *q = '\0';
+    yylval.y_string = strdup(buf);
+    return STRING;
+}
+
+/*
+ * Process a character constant.
+ * Watch out for backslashes.
+ */
+
+private Char charcon(p)
+char *p;
+{
+    char c, buf[10], *q;
+
+    if (*p == '\\') {
+	++p;
+	if (*p != '\\') {
+	    q = buf;
+	    do {
+		*q++ = *p++;
+	    } while (*p != '\\' and *p != '\'' and *p != '\n' and *p != '\0');
+	    *q = '\0';
+	    if (isdigit(buf[0])) {
+		c = (Char) octal(buf);
+	    } else {
+		c = charlookup(buf);
+	    }
+	    curchar = p - 1;
+	} else {
+	    c = '\\';
+	}
+    } else {
+	c = *p;
+    }
+    return c;
+}
+
+/*
+ * Do a lookup for a ASCII character name.
+ */
+
+private String ascii[] = {
+    "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
+    "BS",  "HT",  "NL",  "VT",  "NP",  "CR",  "SO",  "SI",
+    "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
+    "CAN", "EM",  "SUB", "ESC", "FS",  "GS",  "RS",  "US",
+    "SP", nil
+};
+
+private char charlookup(s)
+String s;
+{
+    register int i;
+
+    for (i = 0; ascii[i] != NULL; i++) {
+	if (streq(s, ascii[i])) {
+	    return i;
+	}
+    }
+    if (streq(s, "DEL")) {
+	return 0177;
+    }
+    error("unknown ascii name \"%s\"", s);
+    return '?';
+}
+
+/*
+ * Input file management routines.
+ */
+
+public setinput(filename)
+Filename filename;
+{
+    File f;
+
+    f = fopen(filename, "r");
+    if (f == nil) {
+	error("can't open %s", filename);
+    } else {
+	if (curinclindex >= MAXINCLDEPTH) {
+	    error("unreasonable input nesting on \"%s\"", filename);
+	}
+	inclinfo[curinclindex].savefile = in;
+	inclinfo[curinclindex].savefn = errfilename;
+	inclinfo[curinclindex].savelineno = errlineno;
+	curinclindex++;
+	in = f;
+	errfilename = filename;
+	errlineno = 1;
+    }
+}
+
+private Boolean eofinput()
+{
+    register Boolean b;
+
+    if (curinclindex == 0) {
+	if (isterm(in)) {
+	    putchar('\n');
+	    clearerr(in);
+	    b = false;
+	} else {
+	    b = true;
+	}
+    } else {
+	fclose(in);
+	--curinclindex;
+	in = inclinfo[curinclindex].savefile;
+	errfilename = inclinfo[curinclindex].savefn;
+	errlineno = inclinfo[curinclindex].savelineno;
+	b = false;
+    }
+    return b;
+}
+
+/*
+ * Pop the current input.  Return whether successful.
+ */
+
+public Boolean popinput()
+{
+    Boolean b;
+
+    if (curinclindex == 0) {
+	b = false;
+    } else {
+	b = (Boolean) (not eofinput());
+    }
+    return b;
+}
+
+/*
+ * Return whether we are currently reading from standard input.
+ */
+
+public Boolean isstdin()
+{
+    return (Boolean) (in == stdin);
+}
+
+/*
+ * Send the current line to the shell.
+ */
+
+public shellline()
+{
+    register char *p;
+
+    p = curchar;
+    while (*p != '\0' and (*p == '\n' or lexclass[*p] == WHITE)) {
+	++p;
+    }
+    shell(p);
+    if (*p == '\0' and isterm(in)) {
+	putchar('\n');
+    }
+    erecover();
+}
+
+/*
+ * Read the rest of the current line in "shell mode".
+ */
+
+public beginshellmode()
+{
+    shellmode = true;
+}
+
+/*
+ * Print out a token for debugging.
+ */
+
+public print_token(f, t)
+File f;
+Token t;
+{
+    if (t == '\n') {
+	fprintf(f, "char '\\n'");
+    } else if (t == EOF) {
+	fprintf(f, "EOF");
+    } else if (t < 256) {
+	fprintf(f, "char '%c'", t);
+    } else {
+	fprintf(f, "\"%s\"", keywdstring(t));
+    }
+}
diff --git a/dbx/scanner.h b/dbx/scanner.h
new file mode 100644
index 0000000..ee61054
--- /dev/null
+++ b/dbx/scanner.h
@@ -0,0 +1,15 @@
+#ifndef scanner_h
+#define scanner_h
+typedef int Token;
+String initfile ;
+scanner_init(/*  */);
+Token yylex(/*  */);
+yyerror(/* s */);
+gobble(/*  */);
+setinput(/* filename */);
+Boolean popinput(/*  */);
+Boolean isstdin(/*  */);
+shellline(/*  */);
+beginshellmode(/*  */);
+print_token(/* f, t */);
+#endif
diff --git a/dbx/source.c b/dbx/source.c
new file mode 100644
index 0000000..ab99709
--- /dev/null
+++ b/dbx/source.c
@@ -0,0 +1,313 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)source.c 1.9 8/5/83";
+
+/*
+ * Source file management.
+ */
+
+#include "defs.h"
+#include "source.h"
+#include "object.h"
+#include "mappings.h"
+#include "machine.h"
+
+#ifndef public
+typedef int Lineno;
+
+String cursource;
+Lineno curline;
+Lineno cursrcline;
+
+#define LASTLINE 0		/* recognized by printlines */
+
+#include "lists.h"
+
+List sourcepath;
+#endif
+
+private Lineno lastlinenum;
+private String prevsource = nil;
+
+/*
+ * Data structure for indexing source seek addresses by line number.
+ *
+ * The constraints are:
+ *
+ *  we want an array so indexing is fast and easy
+ *  we don't want to waste space for small files
+ *  we don't want an upper bound on # of lines in a file
+ *  we don't know how many lines there are
+ *
+ * The solution is a "dirty" hash table.  We have NSLOTS pointers to
+ * arrays of NLINESPERSLOT addresses.  To find the source address of
+ * a particular line we find the slot, allocate space if necessary,
+ * and then find its location within the pointed to array.
+ */
+
+typedef long Seekaddr;
+
+#define NSLOTS 20
+#define NLINESPERSLOT 500
+
+#define slotno(line)    ((line) div NLINESPERSLOT)
+#define index(line)	((line) mod NLINESPERSLOT)
+#define slot_alloc()    newarr(Seekaddr, NLINESPERSLOT)
+#define srcaddr(line)	seektab[slotno(line)][index(line)]
+
+private File srcfp;
+private Seekaddr *seektab[NSLOTS];
+
+/*
+ * Print out the given lines from the source.
+ */
+
+public printlines(l1, l2)
+Lineno l1, l2;
+{
+    register int c;
+    register Lineno i, lb, ub;
+    register File f;
+
+    if (cursource == nil) {
+	beginerrmsg();
+	fprintf(stderr, "no source file\n");
+    } else {
+	if (cursource != prevsource) {
+	    skimsource();
+	}
+	if (lastlinenum == 0) {
+	    beginerrmsg();
+	    fprintf(stderr, "couldn't read \"%s\"\n", cursource);
+	} else {
+	    lb = (l1 == 0) ? lastlinenum : l1;
+	    ub = (l2 == 0) ? lastlinenum : l2;
+	    if (lb < 1) {
+		beginerrmsg();
+		fprintf(stderr, "line number must be positive\n");
+	    } else if (lb > lastlinenum) {
+		beginerrmsg();
+		if (lastlinenum == 1) {
+		    fprintf(stderr, "\"%s\" has only 1 line\n", cursource);
+		} else {
+		    fprintf(stderr, "\"%s\" has only %d lines\n",
+			cursource, lastlinenum);
+		}
+	    } else if (ub < lb) {
+		beginerrmsg();
+		fprintf(stderr, "second number must be greater than first\n");
+	    } else {
+		if (ub > lastlinenum) {
+		    ub = lastlinenum;
+		}
+		f = srcfp;
+		fseek(f, srcaddr(lb), 0);
+		for (i = lb; i <= ub; i++) {
+		    printf("%5d   ", i);
+		    while ((c = getc(f)) != '\n') {
+			putchar(c);
+		    }
+		    putchar('\n');
+		}
+		cursrcline = ub + 1;
+	    }
+	}
+    }
+}
+
+/*
+ * Search the sourcepath for a file.
+ */
+
+static char fileNameBuf[1024];
+
+public String findsource(filename)
+String filename;
+{
+    register File f;
+    register String src, dir;
+
+    if (filename[0] == '/') {
+	src = filename;
+    } else {
+	src = nil;
+	foreach (String, dir, sourcepath)
+	    sprintf(fileNameBuf, "%s/%s", dir, filename);
+	    f = fopen(fileNameBuf, "r");
+	    if (f != nil) {
+		fclose(f);
+		src = fileNameBuf;
+		break;
+	    }
+	endfor
+    }
+    return src;
+}
+
+/*
+ * Open a source file looking in the appropriate places.
+ */
+
+public File opensource(filename)
+String filename;
+{
+    String s;
+    File f;
+
+    s = findsource(filename);
+    if (s == nil) {
+	f = nil;
+    } else {
+	f = fopen(s, "r");
+    }
+    return f;
+}
+
+/*
+ * Set the current source file.
+ */
+
+public setsource(filename)
+String filename;
+{
+    if (filename != nil and filename != cursource) {
+	prevsource = cursource;
+	cursource = filename;
+	cursrcline = 1;
+    }
+}
+
+/*
+ * Read the source file getting seek pointers for each line.
+ */
+
+private skimsource()
+{
+    register int c;
+    register Seekaddr count;
+    register File f;
+    register Lineno linenum;
+    register Seekaddr lastaddr;
+    register int slot;
+
+    f = opensource(cursource);
+    if (f == nil) {
+	lastlinenum = 0;
+    } else {
+	if (prevsource != nil) {
+	    free_seektab();
+	    if (srcfp != nil) {
+		fclose(srcfp);
+	    }
+	}
+	prevsource = cursource;
+	linenum = 0;
+	count = 0;
+	lastaddr = 0;
+	while ((c = getc(f)) != EOF) {
+	    ++count;
+	    if (c == '\n') {
+		slot = slotno(++linenum);
+		if (slot >= NSLOTS) {
+		    panic("skimsource: too many lines");
+		}
+		if (seektab[slot] == nil) {
+		    seektab[slot] = slot_alloc();
+		}
+		seektab[slot][index(linenum)] = lastaddr;
+		lastaddr = count;
+	    }
+	}
+	lastlinenum = linenum;
+	srcfp = f;
+    }
+}
+
+/*
+ * Erase information and release space in the current seektab.
+ * This is in preparation for reading in seek pointers for a
+ * new file.  It is possible that seek pointers for all files
+ * should be kept around, but the current concern is space.
+ */
+
+private free_seektab()
+{
+    register int slot;
+
+    for (slot = 0; slot < NSLOTS; slot++) {
+	if (seektab[slot] != nil) {
+	    dispose(seektab[slot]);
+	}
+    }
+}
+
+/*
+ * Figure out current source position.
+ */
+
+public getsrcpos()
+{
+    String filename;
+
+    curline = srcline(pc);
+    filename = srcfilename(pc);
+    setsource(filename);
+    if (curline != 0) {
+	cursrcline = curline;
+    }
+}
+
+/*
+ * Print out the current source position.
+ */
+
+public printsrcpos()
+{
+    printf("at line %d", curline);
+    if (nlhdr.nfiles > 1) {
+	printf(" in file \"%s\"", cursource);
+    }
+}
+
+#define DEF_EDITOR  "vi"
+
+/*
+ * Invoke an editor on the given file.  Which editor to use might change
+ * installation to installation.  For now, we use "vi".  In any event,
+ * the environment variable "EDITOR" overrides any default.
+ */
+
+public edit(filename)
+String filename;
+{
+    extern String getenv();
+    String ed, src, s;
+    Symbol f;
+    Address addr;
+    char lineno[10];
+
+    ed = getenv("EDITOR");
+    if (ed == nil) {
+	ed = DEF_EDITOR;
+    }
+    src = findsource((filename != nil) ? filename : cursource);
+    if (src == nil) {
+	f = which(identname(filename, true));
+	if (not isblock(f)) {
+	    error("can't read \"%s\"", filename);
+	}
+	addr = firstline(f);
+	if (addr == NOADDR) {
+	    error("no source for \"%s\"", filename);
+	}
+	src = srcfilename(addr);
+	s = findsource(src);
+	if (s != nil) {
+	    src = s;
+	}
+	sprintf(lineno, "+%d", srcline(addr));
+    } else {
+	sprintf(lineno, "+1");
+    }
+    call(ed, stdin, stdout, lineno, src, nil);
+}
diff --git a/dbx/source.h b/dbx/source.h
new file mode 100644
index 0000000..d2451ec
--- /dev/null
+++ b/dbx/source.h
@@ -0,0 +1,21 @@
+#ifndef source_h
+#define source_h
+typedef int Lineno;
+
+String cursource;
+Lineno curline;
+Lineno cursrcline;
+
+#define LASTLINE 0		/* recognized by printlines */
+
+#include "lists.h"
+
+List sourcepath;
+printlines(/* l1, l2 */);
+String findsource(/* filename */);
+File opensource(/* filename */);
+setsource(/* filename */);
+getsrcpos(/*  */);
+printsrcpos(/*  */);
+edit(/* filename */);
+#endif
diff --git a/dbx/symbols.c b/dbx/symbols.c
new file mode 100644
index 0000000..d54ecad
--- /dev/null
+++ b/dbx/symbols.c
@@ -0,0 +1,1314 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)symbols.c 1.11 8/16/83";
+
+/*
+ * Symbol management.
+ */
+
+#include "defs.h"
+#include "symbols.h"
+#include "languages.h"
+#include "printsym.h"
+#include "tree.h"
+#include "operators.h"
+#include "eval.h"
+#include "mappings.h"
+#include "events.h"
+#include "process.h"
+#include "runtime.h"
+#include "machine.h"
+#include "names.h"
+
+#ifndef public
+typedef struct Symbol *Symbol;
+
+#include "machine.h"
+#include "names.h"
+#include "languages.h"
+
+/*
+ * Symbol classes
+ */
+
+typedef enum {
+    BADUSE, CONST, TYPE, VAR, ARRAY, PTRFILE, RECORD, FIELD,
+    PROC, FUNC, FVAR, REF, PTR, FILET, SET, RANGE, 
+    LABEL, WITHPTR, SCAL, STR, PROG, IMPROPER, VARNT,
+    FPROC, FFUNC, MODULE, TAG, COMMON, TYPEREF
+} Symclass;
+
+typedef enum { R_CONST, R_TEMP, R_ARG, R_ADJUST } Rangetype; 
+
+struct Symbol {
+    Name name;
+    Language language;
+    Symclass class : 8;
+    Integer level : 8;
+    Symbol type;
+    Symbol chain;
+    union {
+	int offset;		/* variable address */
+	long iconval;		/* integer constant value */
+	double fconval;		/* floating constant value */
+	struct {		/* field offset and size (both in bits) */
+	    int offset;
+	    int length;
+	} field;
+	struct {		/* common offset and chain; used to relocate */
+	    int offset;         /* vars in global BSS */
+	    Symbol chain;
+	} common;
+	struct {		/* range bounds */
+            Rangetype lowertype : 16; 
+            Rangetype uppertype : 16;  
+	    long lower;
+	    long upper;
+	} rangev;
+	struct {
+	    int offset : 16;	/* offset for of function value */
+	    Boolean src : 8;	/* true if there is source line info */
+	    Boolean inline : 8;	/* true if no separate act. rec. */
+	    Address beginaddr;	/* address of function code */
+	} funcv;
+	struct {		/* variant record info */
+	    int size;
+	    Symbol vtorec;
+	    Symbol vtag;
+	} varnt;
+    } symvalue;
+    Symbol block;		/* symbol containing this symbol */
+    Symbol next_sym;		/* hash chain */
+};
+
+/*
+ * Basic types.
+ */
+
+Symbol t_boolean;
+Symbol t_char;
+Symbol t_int;
+Symbol t_real;
+Symbol t_nil;
+
+Symbol program;
+Symbol curfunc;
+
+#define symname(s) ident(s->name)
+#define codeloc(f) ((f)->symvalue.funcv.beginaddr)
+#define isblock(s) (Boolean) ( \
+    s->class == FUNC or s->class == PROC or \
+    s->class == MODULE or s->class == PROG \
+)
+
+#define nosource(f) (not (f)->symvalue.funcv.src)
+#define isinline(f) ((f)->symvalue.funcv.inline)
+
+#include "tree.h"
+
+/*
+ * Some macros to make finding a symbol with certain attributes.
+ */
+
+#define find(s, withname) \
+{ \
+    s = lookup(withname); \
+    while (s != nil and not (s->name == (withname) and
+
+#define where /* qualification */
+
+#define endfind(s) )) { \
+	s = s->next_sym; \
+    } \
+}
+
+#endif
+
+/*
+ * Symbol table structure currently does not support deletions.
+ */
+
+#define HASHTABLESIZE 2003
+
+private Symbol hashtab[HASHTABLESIZE];
+
+#define hash(name) ((((unsigned) name) >> 2) mod HASHTABLESIZE)
+
+/*
+ * Allocate a new symbol.
+ */
+
+#define SYMBLOCKSIZE 300
+
+typedef struct Sympool {
+    struct Symbol sym[SYMBLOCKSIZE];
+    struct Sympool *prevpool;
+} *Sympool;
+
+private Sympool sympool = nil;
+private Integer nleft = 0;
+
+public Symbol symbol_alloc()
+{
+    register Sympool newpool;
+
+    if (nleft <= 0) {
+	newpool = new(Sympool);
+	bzero(newpool, sizeof(newpool));
+	newpool->prevpool = sympool;
+	sympool = newpool;
+	nleft = SYMBLOCKSIZE;
+    }
+    --nleft;
+    return &(sympool->sym[nleft]);
+}
+
+
+public symbol_dump(func)
+Symbol func;
+{
+    register Symbol s;
+    register Integer i;
+
+    printf(" symbols in %s \n",symname(func));
+    for (i = 0; i< HASHTABLESIZE; i++) {
+	for (s = hashtab[i]; s != nil; s = s->next_sym) {
+	    if (s->block == func) {
+		psym(s);
+	    }
+	}
+    }
+}
+
+/*
+ * Free all the symbols currently allocated.
+ */
+
+public symbol_free()
+{
+    Sympool s, t;
+    register Integer i;
+
+    s = sympool;
+    while (s != nil) {
+	t = s->prevpool;
+	dispose(s);
+	s = t;
+    }
+    for (i = 0; i < HASHTABLESIZE; i++) {
+	hashtab[i] = nil;
+    }
+    sympool = nil;
+    nleft = 0;
+}
+
+/*
+ * Create a new symbol with the given attributes.
+ */
+
+public Symbol newSymbol(name, blevel, class, type, chain)
+Name name;
+Integer blevel;
+Symclass class;
+Symbol type;
+Symbol chain;
+{
+    register Symbol s;
+
+    s = symbol_alloc();
+    s->name = name;
+    s->level = blevel;
+    s->class = class;
+    s->type = type;
+    s->chain = chain;
+    return s;
+}
+
+/*
+ * Insert a symbol into the hash table.
+ */
+
+public Symbol insert(name)
+Name name;
+{
+    register Symbol s;
+    register unsigned int h;
+
+    h = hash(name);
+    s = symbol_alloc();
+    s->name = name;
+    s->next_sym = hashtab[h];
+    hashtab[h] = s;
+    return s;
+}
+
+/*
+ * Symbol lookup.
+ */
+
+public Symbol lookup(name)
+Name name;
+{
+    register Symbol s;
+    register unsigned int h;
+
+    h = hash(name);
+    s = hashtab[h];
+    while (s != nil and s->name != name) {
+	s = s->next_sym;
+    }
+    return s;
+}
+
+/*
+ * Dump out all the variables associated with the given
+ * procedure, function, or program at the given recursive level.
+ *
+ * This is quite inefficient.  We traverse the entire symbol table
+ * each time we're called.  The assumption is that this routine
+ * won't be called frequently enough to merit improved performance.
+ */
+
+public dumpvars(f, frame)
+Symbol f;
+Frame frame;
+{
+    register Integer i;
+    register Symbol s;
+
+    for (i = 0; i < HASHTABLESIZE; i++) {
+	for (s = hashtab[i]; s != nil; s = s->next_sym) {
+	    if (container(s) == f) {
+		if (should_print(s)) {
+		    printv(s, frame);
+		    putchar('\n');
+		} else if (s->class == MODULE) {
+		    dumpvars(s, frame);
+		}
+	    }
+	}
+    }
+}
+
+/*
+ * Create base types.
+ */
+
+public symbols_init()
+{
+    t_boolean = maketype("$boolean", 0L, 1L);
+    t_int = maketype("$integer", 0x80000000L, 0x7fffffffL);
+    t_char = maketype("$char", 0L, 127L);
+    t_real = maketype("$real", 8L, 0L);
+    t_nil = maketype("$nil", 0L, 0L);
+}
+
+/*
+ * Create a builtin type.
+ * Builtin types are circular in that btype->type->type = btype.
+ */
+
+public Symbol maketype(name, lower, upper)
+String name;
+long lower;
+long upper;
+{
+    register Symbol s;
+
+    s = newSymbol(identname(name, true), 0, TYPE, nil, nil);
+    s->language = findlanguage(".c");
+    s->type = newSymbol(nil, 0, RANGE, s, nil);
+    s->type->symvalue.rangev.lower = lower;
+    s->type->symvalue.rangev.upper = upper;
+    return s;
+}
+
+/*
+ * These functions are now compiled inline.
+ *
+ * public String symname(s)
+Symbol s;
+{
+    checkref(s);
+    return ident(s->name);
+}
+
+ *
+ * public Address codeloc(f)
+Symbol f;
+{
+    checkref(f);
+    if (not isblock(f)) {
+	panic("codeloc: \"%s\" is not a block", ident(f->name));
+    }
+    return f->symvalue.funcv.beginaddr;
+}
+ *
+ */
+
+/*
+ * Reduce type to avoid worrying about type names.
+ */
+
+public Symbol rtype(type)
+Symbol type;
+{
+    register Symbol t;
+
+    t = type;
+    if (t != nil) {
+	if (t->class == VAR or t->class == FIELD or t->class == REF ) {
+	    t = t->type;
+	}
+	while (t->class == TYPE or t->class == TAG) {
+	    t = t->type;
+	}
+    }
+    return t;
+}
+
+public Integer level(s)
+Symbol s;
+{
+    checkref(s);
+    return s->level;
+}
+
+public Symbol container(s)
+Symbol s;
+{
+    checkref(s);
+    return s->block;
+}
+
+/*
+ * Return the object address of the given symbol.
+ *
+ * There are the following possibilities:
+ *
+ *	globals		- just take offset
+ *	locals		- take offset from locals base
+ *	arguments	- take offset from argument base
+ *	register	- offset is register number
+ */
+
+#define isglobal(s)		(s->level == 1 or s->level == 2)
+#define islocaloff(s)		(s->level >= 3 and s->symvalue.offset < 0)
+#define isparamoff(s)		(s->level >= 3 and s->symvalue.offset >= 0)
+#define isreg(s)		(s->level < 0)
+
+public Address address(s, frame)
+Symbol s;
+Frame frame;
+{
+    register Frame frp;
+    register Address addr;
+    register Symbol cur;
+
+    checkref(s);
+    if (not isactive(s->block)) {
+	error("\"%s\" is not currently defined", symname(s));
+    } else if (isglobal(s)) {
+	addr = s->symvalue.offset;
+    } else {
+	frp = frame;
+	if (frp == nil) {
+	    cur = s->block;
+	    while (cur != nil and cur->class == MODULE) {
+		cur = cur->block;
+	    }
+	    if (cur == nil) {
+		cur = whatblock(pc);
+	    }
+	    frp = findframe(cur);
+	    if (frp == nil) {
+		panic("unexpected nil frame for \"%s\"", symname(s));
+	    }
+	}
+	if (islocaloff(s)) {
+	    addr = locals_base(frp) + s->symvalue.offset;
+	} else if (isparamoff(s)) {
+	    addr = args_base(frp) + s->symvalue.offset;
+	} else if (isreg(s)) {
+	    addr = savereg(s->symvalue.offset, frp);
+	} else {
+	    panic("address: bad symbol \"%s\"", symname(s));
+	}
+    }
+    return addr;
+}
+
+/*
+ * Define a symbol used to access register values.
+ */
+
+public defregname(n, r)
+Name n;
+Integer r;
+{
+    register Symbol s, t;
+
+    s = insert(n);
+    t = newSymbol(nil, 0, PTR, t_int, nil);
+    t->language = findlanguage(".s");
+    s->language = t->language;
+    s->class = VAR;
+    s->level = -3;
+    s->type = t;
+    s->block = program;
+    s->symvalue.offset = r;
+}
+
+/*
+ * Resolve an "abstract" type reference.
+ *
+ * It is possible in C to define a pointer to a type, but never define
+ * the type in a particular source file.  Here we try to resolve
+ * the type definition.  This is problematic, it is possible to
+ * have multiple, different definitions for the same name type.
+ */
+
+public findtype(s)
+Symbol s;
+{
+    register Symbol t, u, prev;
+
+    u = s;
+    prev = nil;
+    while (u != nil and u->class != BADUSE) {
+	if (u->name != nil) {
+	    prev = u;
+	}
+	u = u->type;
+    }
+    if (prev == nil) {
+	error("couldn't find link to type reference");
+    }
+    find(t, prev->name) where
+	t->type != nil and t->class == prev->class and
+	t->type->class != BADUSE and t->block->class == MODULE
+    endfind(t);
+    if (t == nil) {
+	error("couldn't resolve reference");
+    } else {
+	prev->type = t->type;
+    }
+}
+
+/*
+ * Find the size in bytes of the given type.
+ *
+ * This is probably the WRONG thing to do.  The size should be kept
+ * as an attribute in the symbol information as is done for structures
+ * and fields.  I haven't gotten around to cleaning this up yet.
+ */
+
+#define MAXUCHAR 255
+#define MAXUSHORT 65535L
+#define MINCHAR -128
+#define MAXCHAR 127
+#define MINSHORT -32768
+#define MAXSHORT 32767
+
+public Integer size(sym)
+Symbol sym;
+{
+    register Symbol s, t;
+    register int nel, elsize;
+    long lower, upper;
+    int r;
+
+    t = sym;
+    checkref(t);
+    switch (t->class) {
+	case RANGE:
+	    lower = t->symvalue.rangev.lower;
+	    upper = t->symvalue.rangev.upper;
+	    if (upper == 0 and lower > 0) {		/* real */
+		r = lower;
+	    } else if (
+  		(lower >= MINCHAR and upper <= MAXCHAR) or
+  		(lower >= 0 and upper <= MAXUCHAR)
+  	      ) {
+		r = sizeof(char);
+  	    } else if (
+  		(lower >= MINSHORT and upper <= MAXSHORT) or
+  		(lower >= 0 and upper <= MAXUSHORT)
+  	      ) {
+		r = sizeof(short);
+	    } else {
+		r = sizeof(long);
+	    }
+	    break;
+
+	case ARRAY:
+	    elsize = size(t->type);
+	    nel = 1;
+	    for (t = t->chain; t != nil; t = t->chain) {
+		if (t->symvalue.rangev.lowertype == R_ARG or
+		  t->symvalue.rangev.lowertype == R_TEMP)  {
+		    if (not getbound(t, t->symvalue.rangev.lower,
+		      t->symvalue.rangev.lowertype, &lower)) {
+			error("dynamic bounds not currently available");
+		    }
+		} else {
+		    lower = t->symvalue.rangev.lower;
+		}
+		if (t->symvalue.rangev.uppertype == R_ARG or
+		  t->symvalue.rangev.uppertype == R_TEMP) {
+		    if (not getbound(t, t->symvalue.rangev.upper,
+		      t->symvalue.rangev.uppertype, &upper)) {
+			error("dynamic bounds nor currently available");
+		    }
+		} else {
+		    upper = t->symvalue.rangev.upper;
+		}
+		nel *= (upper-lower+1);
+	    }
+	    r = nel*elsize;
+	    break;
+
+	case REF:
+	case VAR:
+	case FVAR:
+	    r = size(t->type);
+	    /*
+	     *
+	    if (r < sizeof(Word) and isparam(t)) {
+		r = sizeof(Word);
+	    }
+	    */
+	    break;
+
+	case CONST:
+	    r = size(t->type);
+	    break;
+
+	case TYPE:
+	    if (t->type->class == PTR and t->type->type->class == BADUSE) {
+		findtype(t);
+	    }
+	    r = size(t->type);
+	    break;
+
+	case TAG:
+	    r = size(t->type);
+	    break;
+
+	case FIELD:
+	    r = (t->symvalue.field.length + 7) div 8;
+	    break;
+
+	case RECORD:
+	case VARNT:
+	    r = t->symvalue.offset;
+	    if (r == 0 and t->chain != nil) {
+		panic("missing size information for record");
+	    }
+	    break;
+
+	case PTR:
+	case FILET:
+	    r = sizeof(Word);
+	    break;
+
+	case SCAL:
+	    r = sizeof(Word);
+	    /*
+	     *
+	    if (t->symvalue.iconval > 255) {
+		r = sizeof(short);
+	    } else {
+		r = sizeof(char);
+	    }
+	     *
+	     */
+	    break;
+
+	case FPROC:
+	case FFUNC:
+	    r = sizeof(Word);
+	    break;
+
+	case PROC:
+	case FUNC:
+	case MODULE:
+	case PROG:
+	    r = sizeof(Symbol);
+	    break;
+
+	default:
+	    if (ord(t->class) > ord(TYPEREF)) {
+		panic("size: bad class (%d)", ord(t->class));
+	    } else {
+		error("improper operation on a %s", classname(t));
+	    }
+	    /* NOTREACHED */
+    }
+    return r;
+}
+
+/*
+ * Test if a symbol is a parameter.  This is true if there
+ * is a cycle from s->block to s via chain pointers.
+ */
+
+public Boolean isparam(s)
+Symbol s;
+{
+    register Symbol t;
+
+    t = s->block;
+    while (t != nil and t != s) {
+	t = t->chain;
+    }
+    return (Boolean) (t != nil);
+}
+
+/*
+ * Test if a symbol is a var parameter, i.e. has class REF.
+ */
+
+public Boolean isvarparam(s)
+Symbol s;
+{
+    return (Boolean) (s->class == REF);
+}
+
+/*
+ * Test if a symbol is a variable (actually any addressible quantity
+ * with do).
+ */
+
+public Boolean isvariable(s)
+register Symbol s;
+{
+    return (Boolean) (s->class == VAR or s->class == FVAR or s->class == REF);
+}
+
+/*
+ * Test if a symbol is a block, e.g. function, procedure, or the
+ * main program.
+ *
+ * This function is now expanded inline for efficiency.
+ *
+ * public Boolean isblock(s)
+register Symbol s;
+{
+    return (Boolean) (
+	s->class == FUNC or s->class == PROC or
+	s->class == MODULE or s->class == PROG
+    );
+}
+ *
+ */
+
+/*
+ * Test if a symbol is a module.
+ */
+
+public Boolean ismodule(s)
+register Symbol s;
+{
+    return (Boolean) (s->class == MODULE);
+}
+
+/*
+ * Test if a symbol is builtin, that is, a predefined type or
+ * reserved word.
+ */
+
+public Boolean isbuiltin(s)
+register Symbol s;
+{
+    return (Boolean) (s->level == 0 and s->class != PROG and s->class != VAR);
+}
+
+/*
+ * Test if two types match.
+ * Equivalent names implies a match in any language.
+ *
+ * Special symbols must be handled with care.
+ */
+
+public Boolean compatible(t1, t2)
+register Symbol t1, t2;
+{
+    Boolean b;
+
+    if (t1 == t2) {
+	b = true;
+    } else if (t1 == nil or t2 == nil) {
+	b = false;
+    } else if (t1 == procsym) {
+	b = isblock(t2);
+    } else if (t2 == procsym) {
+	b = isblock(t1);
+    } else if (t1->language == nil) {
+	b = (Boolean) (t2->language == nil or
+	    (*language_op(t2->language, L_TYPEMATCH))(t1, t2));
+    } else if (t2->language == nil) {
+	b = (Boolean) (*language_op(t1->language, L_TYPEMATCH))(t1, t2);
+    } else if ( isbuiltin(t1) or isbuiltin(t1->type) ) {
+	b = (Boolean) (*language_op(t2->language, L_TYPEMATCH))(t1, t2);
+    } else {
+	b = (Boolean) (*language_op(t1->language, L_TYPEMATCH))(t1, t2);
+    }
+    return b;
+}
+
+/*
+ * Check for a type of the given name.
+ */
+
+public Boolean istypename(type, name)
+Symbol type;
+String name;
+{
+    Symbol t;
+    Boolean b;
+
+    t = type;
+    checkref(t);
+    b = (Boolean) (
+	t->class == TYPE and t->name == identname(name, true)
+    );
+    return b;
+}
+
+/*
+ * Test if the name of a symbol is uniquely defined or not.
+ */
+
+public Boolean isambiguous(s)
+register Symbol s;
+{
+    register Symbol t;
+
+    find(t, s->name) where t != s endfind(t);
+    return (Boolean) (t != nil);
+}
+
+typedef char *Arglist;
+
+#define nextarg(type)  ((type *) (ap += sizeof(type)))[-1]
+
+private Symbol mkstring();
+private Symbol namenode();
+
+/*
+ * Determine the type of a parse tree.
+ * Also make some symbol-dependent changes to the tree such as
+ * changing removing RVAL nodes for constant symbols.
+ */
+
+public assigntypes(p)
+register Node p;
+{
+    register Node p1;
+    register Symbol s;
+
+    switch (p->op) {
+	case O_SYM:
+	    p->nodetype = namenode(p);
+	    break;
+
+	case O_LCON:
+	    p->nodetype = t_int;
+	    break;
+
+	case O_FCON:
+	    p->nodetype = t_real;
+	    break;
+
+	case O_SCON:
+	    p->value.scon = strdup(p->value.scon);
+	    s = mkstring(p->value.scon);
+	    if (s == t_char) {
+		p->op = O_LCON;
+		p->value.lcon = p->value.scon[0];
+	    }
+	    p->nodetype = s;
+	    break;
+
+	case O_INDIR:
+	    p1 = p->value.arg[0];
+	    chkclass(p1, PTR);
+	    p->nodetype = rtype(p1->nodetype)->type;
+	    break;
+
+	case O_DOT:
+	    p->nodetype = p->value.arg[1]->value.sym;
+	    break;
+
+	case O_RVAL:
+	    p1 = p->value.arg[0];
+	    p->nodetype = p1->nodetype;
+	    if (p1->op == O_SYM) {
+		if (p1->nodetype->class == FUNC) {
+		    p->op = O_CALL;
+		    p->value.arg[1] = nil;
+		} else if (p1->value.sym->class == CONST) {
+		    if (compatible(p1->value.sym->type, t_real)) {
+			p->op = O_FCON;
+			p->value.fcon = p1->value.sym->symvalue.fconval;
+			p->nodetype = t_real;
+			dispose(p1);
+		    } else {
+			p->op = O_LCON;
+			p->value.lcon = p1->value.sym->symvalue.iconval;
+			p->nodetype = p1->value.sym->type;
+			dispose(p1);
+		    }
+		} else if (isreg(p1->value.sym)) {
+		    p->op = O_SYM;
+		    p->value.sym = p1->value.sym;
+		    dispose(p1);
+		}
+	    } else if (p1->op == O_INDIR and p1->value.arg[0]->op == O_SYM) {
+		s = p1->value.arg[0]->value.sym;
+		if (isreg(s)) {
+		    p1->op = O_SYM;
+		    dispose(p1->value.arg[0]);
+		    p1->value.sym = s;
+		    p1->nodetype = s;
+		}
+	    }
+	    break;
+
+	case O_CALL:
+	    p1 = p->value.arg[0];
+	    p->nodetype = rtype(p1->nodetype)->type;
+	    break;
+
+	case O_TYPERENAME:
+	    p->nodetype = p->value.arg[1]->nodetype;
+	    break;
+
+	case O_ITOF:
+	    p->nodetype = t_real;
+	    break;
+
+	case O_NEG:
+	    s = p->value.arg[0]->nodetype;
+	    if (not compatible(s, t_int)) {
+		if (not compatible(s, t_real)) {
+		    beginerrmsg();
+		    prtree(stderr, p->value.arg[0]);
+		    fprintf(stderr, "is improper type");
+		    enderrmsg();
+		} else {
+		    p->op = O_NEGF;
+		}
+	    }
+	    p->nodetype = s;
+	    break;
+
+	case O_ADD:
+	case O_SUB:
+	case O_MUL:
+	case O_LT:
+	case O_LE:
+	case O_GT:
+	case O_GE:
+	case O_EQ:
+	case O_NE:
+	{
+	    Boolean t1real, t2real;
+	    Symbol t1, t2;
+
+	    t1 = rtype(p->value.arg[0]->nodetype);
+	    t2 = rtype(p->value.arg[1]->nodetype);
+	    t1real = compatible(t1, t_real);
+	    t2real = compatible(t2, t_real);
+	    if (t1real or t2real) {
+		p->op = (Operator) (ord(p->op) + 1);
+		if (not t1real) {
+		    p->value.arg[0] = build(O_ITOF, p->value.arg[0]);
+		} else if (not t2real) {
+		    p->value.arg[1] = build(O_ITOF, p->value.arg[1]);
+		}
+	    } else {
+		if (t1real) {
+		    convert(&(p->value.arg[0]), t_int, O_NOP);
+		}
+		if (t2real) {
+		    convert(&(p->value.arg[1]), t_int, O_NOP);
+		}
+	    }
+	    if (ord(p->op) >= ord(O_LT)) {
+		p->nodetype = t_boolean;
+	    } else {
+		if (t1real or t2real) {
+		    p->nodetype = t_real;
+		} else {
+		    p->nodetype = t_int;
+		}
+	    }
+	    break;
+	}
+
+	case O_DIVF:
+	    convert(&(p->value.arg[0]), t_real, O_ITOF);
+	    convert(&(p->value.arg[1]), t_real, O_ITOF);
+	    p->nodetype = t_real;
+	    break;
+
+	case O_DIV:
+	case O_MOD:
+	    convert(&(p->value.arg[0]), t_int, O_NOP);
+	    convert(&(p->value.arg[1]), t_int, O_NOP);
+	    p->nodetype = t_int;
+	    break;
+
+	case O_AND:
+	case O_OR:
+	    chkboolean(p->value.arg[0]);
+	    chkboolean(p->value.arg[1]);
+	    p->nodetype = t_boolean;
+	    break;
+
+	case O_QLINE:
+	    p->nodetype = t_int;
+	    break;
+
+	default:
+	    p->nodetype = nil;
+	    break;
+    }
+}
+
+/*
+ * Create a node for a name.  The symbol for the name has already
+ * been chosen, either implicitly with "which" or explicitly from
+ * the dot routine.
+ */
+
+private Symbol namenode(p)
+Node p;
+{
+    register Symbol r, s;
+    register Node np;
+
+    s = p->value.sym;
+    if (s->class == REF) {
+	np = new(Node);
+	np->op = p->op;
+	np->nodetype = s;
+	np->value.sym = s;
+	p->op = O_INDIR;
+	p->value.arg[0] = np;
+    }
+/*
+ * Old way
+ *
+    if (s->class == CONST or s->class == VAR or s->class == FVAR) {
+	r = s->type;
+    } else {
+	r = s;
+    }
+ *
+ */
+    return s;
+}
+
+/*
+ * Convert a tree to a type via a conversion operator;
+ * if this isn't possible generate an error.
+ *
+ * Note the tree is call by address, hence the #define below.
+ */
+
+private convert(tp, typeto, op)
+Node *tp;
+Symbol typeto;
+Operator op;
+{
+#define tree    (*tp)
+
+    Symbol s;
+
+    s = rtype(tree->nodetype);
+    typeto = rtype(typeto);
+    if (compatible(typeto, t_real) and compatible(s, t_int)) {
+	tree = build(op, tree);
+    } else if (not compatible(s, typeto)) {
+	beginerrmsg();
+	prtree(stderr, s);
+	fprintf(stderr, " is improper type");
+	enderrmsg();
+    } else if (op != O_NOP and s != typeto) {
+	tree = build(op, tree);
+    }
+
+#undef tree
+}
+
+/*
+ * Construct a node for the dot operator.
+ *
+ * If the left operand is not a record, but rather a procedure
+ * or function, then we interpret the "." as referencing an
+ * "invisible" variable; i.e. a variable within a dynamically
+ * active block but not within the static scope of the current procedure.
+ */
+
+public Node dot(record, fieldname)
+Node record;
+Name fieldname;
+{
+    register Node p;
+    register Symbol s, t;
+
+    if (isblock(record->nodetype)) {
+	find(s, fieldname) where
+	    s->block == record->nodetype and
+	    s->class != FIELD and s->class != TAG
+	endfind(s);
+	if (s == nil) {
+	    beginerrmsg();
+	    fprintf(stderr, "\"%s\" is not defined in ", ident(fieldname));
+	    printname(stderr, record->nodetype);
+	    enderrmsg();
+	}
+	p = new(Node);
+	p->op = O_SYM;
+	p->value.sym = s;
+	p->nodetype = namenode(p);
+    } else {
+	p = record;
+	t = rtype(p->nodetype);
+	if (t->class == PTR) {
+	    s = findfield(fieldname, t->type);
+	} else {
+	    s = findfield(fieldname, t);
+	}
+	if (s == nil) {
+	    beginerrmsg();
+	    fprintf(stderr, "\"%s\" is not a field in ", ident(fieldname));
+	    prtree(stderr, record);
+	    enderrmsg();
+	}
+	if (t->class == PTR and not isreg(record->nodetype)) {
+	    p = build(O_INDIR, record);
+	}
+	p = build(O_DOT, p, build(O_SYM, s));
+    }
+    return p;
+}
+
+/*
+ * Return a tree corresponding to an array reference and do the
+ * error checking.
+ */
+
+public Node subscript(a, slist)
+Node a, slist;
+{
+Symbol t;
+
+   t = rtype(a->nodetype);
+   if(t->language == nil) {
+	error("unknown language");
+   }
+   else {
+        return ( (Node)
+        (*language_op(t->language, L_BUILDAREF)) (a,slist)
+               );
+   }
+}
+
+/*
+ * Evaluate a subscript index.
+ */
+
+public int evalindex(s, i)
+Symbol s;
+long i;
+{
+Symbol t;
+
+   t = rtype(s);
+   if(t->language == nil) {
+	error("unknown language");
+   }
+   else {
+        return (
+             (*language_op(t->language, L_EVALAREF)) (s,i)
+               );
+   }
+}
+
+/*
+ * Check to see if a tree is boolean-valued, if not it's an error.
+ */
+
+public chkboolean(p)
+register Node p;
+{
+    if (p->nodetype != t_boolean) {
+	beginerrmsg();
+	fprintf(stderr, "found ");
+	prtree(stderr, p);
+	fprintf(stderr, ", expected boolean expression");
+	enderrmsg();
+    }
+}
+
+/*
+ * Check to make sure the given tree has a type of the given class.
+ */
+
+private chkclass(p, class)
+Node p;
+Symclass class;
+{
+    struct Symbol tmpsym;
+
+    tmpsym.class = class;
+    if (rtype(p->nodetype)->class != class) {
+	beginerrmsg();
+	fprintf(stderr, "\"");
+	prtree(stderr, p);
+	fprintf(stderr, "\" is not a %s", classname(&tmpsym));
+	enderrmsg();
+    }
+}
+
+/*
+ * Construct a node for the type of a string.  While we're at it,
+ * scan the string for '' that collapse to ', and chop off the ends.
+ */
+
+private Symbol mkstring(str)
+String str;
+{
+    register char *p, *q;
+    register Symbol s;
+
+    p = str;
+    q = str;
+    while (*p != '\0') {
+	if (*p == '\\') {
+	    ++p;
+	}
+	*q = *p;
+	++p;
+	++q;
+    }
+    *q = '\0';
+    s = newSymbol(nil, 0, ARRAY, t_char, nil);
+    s->language = findlanguage(".s");
+    s->chain = newSymbol(nil, 0, RANGE, t_int, nil);
+    s->chain->language = s->language;
+    s->chain->symvalue.rangev.lower = 1;
+    s->chain->symvalue.rangev.upper = p - str + 1;
+    return s;
+}
+
+/*
+ * Free up the space allocated for a string type.
+ */
+
+public unmkstring(s)
+Symbol s;
+{
+    dispose(s->chain);
+}
+
+/*
+ * Figure out the "current" variable or function being referred to,
+ * this is either the active one or the most visible from the
+ * current scope.
+ */
+
+public Symbol which(n)
+Name n;
+{
+    register Symbol s, p, t, f;
+
+    find(s, n) where s->class != FIELD and s->class != TAG endfind(s);
+    if (s == nil) {
+	s = lookup(n);
+    }
+    if (s == nil) {
+	error("\"%s\" is not defined", ident(n));
+    } else if (s == program or isbuiltin(s)) {
+	t = s;
+    } else {
+    /*
+     * Old way
+     *
+	if (not isactive(program)) {
+	    f = program;
+	} else {
+	    f = whatblock(pc);
+	    if (f == nil) {
+		panic("no block for addr 0x%x", pc);
+	    }
+	}
+     *
+     * Now start with curfunc.
+     */
+	p = curfunc;
+	do {
+	    find(t, n) where
+		t->block == p and t->class != FIELD and t->class != TAG
+	    endfind(t);
+	    p = p->block;
+	} while (t == nil and p != nil);
+	if (t == nil) {
+	    t = s;
+	}
+    }
+    return t;
+}
+
+/*
+ * Find the symbol which is has the same name and scope as the
+ * given symbol but is of the given field.  Return nil if there is none.
+ */
+
+public Symbol findfield(fieldname, record)
+Name fieldname;
+Symbol record;
+{
+    register Symbol t;
+
+    t = rtype(record)->chain;
+    while (t != nil and t->name != fieldname) {
+	t = t->chain;
+    }
+    return t;
+}
+
+public Boolean getbound(s,off,type,valp)
+Symbol s;
+int off;
+Rangetype type;
+int *valp;
+{
+    Frame frp;
+    Address addr;
+    Symbol cur;
+
+    if (not isactive(s->block)) {
+	return(false);
+    }
+    cur = s->block;
+    while (cur != nil and cur->class == MODULE) {  /* WHY*/
+    		cur = cur->block;
+    }
+    if(cur == nil) {
+		cur = whatblock(pc);
+    }
+    frp = findframe(cur);
+    if (frp == nil) {
+	return(false);
+    }
+    if(type == R_TEMP) addr = locals_base(frp) + off;
+    else if (type == R_ARG) addr = args_base(frp) + off;
+    else return(false);
+    dread(valp,addr,sizeof(long));
+    return(true);
+}
diff --git a/dbx/symbols.h b/dbx/symbols.h
new file mode 100644
index 0000000..3233a77
--- /dev/null
+++ b/dbx/symbols.h
@@ -0,0 +1,137 @@
+#ifndef symbols_h
+#define symbols_h
+typedef struct Symbol *Symbol;
+
+#include "machine.h"
+#include "names.h"
+#include "languages.h"
+
+/*
+ * Symbol classes
+ */
+
+typedef enum {
+    BADUSE, CONST, TYPE, VAR, ARRAY, PTRFILE, RECORD, FIELD,
+    PROC, FUNC, FVAR, REF, PTR, FILET, SET, RANGE, 
+    LABEL, WITHPTR, SCAL, STR, PROG, IMPROPER, VARNT,
+    FPROC, FFUNC, MODULE, TAG, COMMON, TYPEREF
+} Symclass;
+
+typedef enum { R_CONST, R_TEMP, R_ARG, R_ADJUST } Rangetype; 
+
+struct Symbol {
+    Name name;
+    Language language;
+    Symclass class : 8;
+    Integer level : 8;
+    Symbol type;
+    Symbol chain;
+    union {
+	int offset;		/* variable address */
+	long iconval;		/* integer constant value */
+	double fconval;		/* floating constant value */
+	struct {		/* field offset and size (both in bits) */
+	    int offset;
+	    int length;
+	} field;
+	struct {		/* common offset and chain; used to relocate */
+	    int offset;         /* vars in global BSS */
+	    Symbol chain;
+	} common;
+	struct {		/* range bounds */
+            Rangetype lowertype : 16; 
+            Rangetype uppertype : 16;  
+	    long lower;
+	    long upper;
+	} rangev;
+	struct {
+	    int offset : 16;	/* offset for of function value */
+	    Boolean src : 8;	/* true if there is source line info */
+	    Boolean inline : 8;	/* true if no separate act. rec. */
+	    Address beginaddr;	/* address of function code */
+	} funcv;
+	struct {		/* variant record info */
+	    int size;
+	    Symbol vtorec;
+	    Symbol vtag;
+	} varnt;
+    } symvalue;
+    Symbol block;		/* symbol containing this symbol */
+    Symbol next_sym;		/* hash chain */
+};
+
+/*
+ * Basic types.
+ */
+
+Symbol t_boolean;
+Symbol t_char;
+Symbol t_int;
+Symbol t_real;
+Symbol t_nil;
+
+Symbol program;
+Symbol curfunc;
+
+#define symname(s) ident(s->name)
+#define codeloc(f) ((f)->symvalue.funcv.beginaddr)
+#define isblock(s) (Boolean) ( \
+    s->class == FUNC or s->class == PROC or \
+    s->class == MODULE or s->class == PROG \
+)
+
+#define nosource(f) (not (f)->symvalue.funcv.src)
+#define isinline(f) ((f)->symvalue.funcv.inline)
+
+#include "tree.h"
+
+/*
+ * Some macros to make finding a symbol with certain attributes.
+ */
+
+#define find(s, withname) \
+{ \
+    s = lookup(withname); \
+    while (s != nil and not (s->name == (withname) and
+
+#define where /* qualification */
+
+#define endfind(s) )) { \
+	s = s->next_sym; \
+    } \
+}
+
+Symbol symbol_alloc(/*  */);
+symbol_dump(/* func */);
+symbol_free(/*  */);
+Symbol newSymbol(/* name, blevel, class, type, chain */);
+Symbol insert(/* name */);
+Symbol lookup(/* name */);
+dumpvars(/* f, frame */);
+symbols_init(/*  */);
+Symbol maketype(/* name, lower, upper */);
+Symbol rtype(/* type */);
+Integer level(/* s */);
+Symbol container(/* s */);
+Address address(/* s, frame */);
+defregname(/* n, r */);
+findtype(/* s */);
+Integer size(/* sym */);
+Boolean isparam(/* s */);
+Boolean isvarparam(/* s */);
+Boolean isvariable(/* s */);
+Boolean ismodule(/* s */);
+Boolean isbuiltin(/* s */);
+Boolean compatible(/* t1, t2 */);
+Boolean istypename(/* type, name */);
+Boolean isambiguous(/* s */);
+assigntypes(/* p */);
+Node dot(/* record, fieldname */);
+Node subscript(/* a, slist */);
+int evalindex(/* s, i */);
+chkboolean(/* p */);
+unmkstring(/* s */);
+Symbol which(/* n */);
+Symbol findfield(/* fieldname, record */);
+Boolean getbound(/* s,off,type,valp */);
+#endif
diff --git a/dbx/tdbx b/dbx/tdbx
new file mode 100755
index 0000000..807f618
Binary files /dev/null and b/dbx/tdbx differ
diff --git a/dbx/tree.c b/dbx/tree.c
new file mode 100644
index 0000000..4ea9b8f
--- /dev/null
+++ b/dbx/tree.c
@@ -0,0 +1,645 @@
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)tree.c 1.5 8/10/83";
+
+/*
+ * Parse tree management.
+ */
+
+#include "defs.h"
+#include "tree.h"
+#include "operators.h"
+#include "eval.h"
+#include "events.h"
+#include "symbols.h"
+#include "scanner.h"
+#include "source.h"
+#include "object.h"
+#include "mappings.h"
+#include "process.h"
+#include "machine.h"
+
+#ifndef public
+#include "lists.h"
+
+typedef struct Node *Node;
+typedef Node Command;
+typedef List Cmdlist;
+
+#include "operators.h"
+#include "symbols.h"
+#include "events.h"
+
+#define MAXNARGS 5
+
+struct Node {
+    Operator op;
+    Symbol nodetype;
+    union treevalue {
+	Symbol sym;
+	Name name;
+	long lcon;
+	double fcon;
+	String scon;
+	Node arg[MAXNARGS];
+	struct {
+	    Node cond;
+	    Cmdlist actions;
+	} event;
+	struct {
+	    Boolean inst;
+	    Event event;
+	    Cmdlist actions;
+	} trace;
+	struct {
+	    Boolean source;
+	    Boolean skipcalls;
+	} step;
+	struct {
+	    String mode;
+	    Node beginaddr;
+	    Node endaddr;
+	    Integer count;
+	} examine;
+    } value;
+};
+
+#define evalcmd(cmd) eval(cmd)
+#define cmdlist_append(cmd, cl) list_append(list_item(cmd), nil, cl)
+
+#endif
+
+typedef char *Arglist;
+
+#define nextarg(type)  ((type *) (ap += sizeof(type)))[-1]
+
+/*
+ * Build a tree.
+ */
+
+/* VARARGS1 */
+public Node build(op, args)
+Operator op;
+{
+    register Node p, q;
+    register Arglist ap;
+    Integer i;
+
+    p = new(Node);
+    p->op = op;
+    p->nodetype = nil;
+    ap = (Arglist) &args;
+    switch (op) {
+	case O_NAME:
+	    p->value.name = nextarg(Name);
+	    break;
+
+	case O_SYM:
+	case O_PRINTCALL:
+	case O_PRINTRTN:
+	case O_PROCRTN:
+	    p->value.sym = nextarg(Symbol);
+	    break;
+
+	case O_DEBUG:
+	case O_LCON:
+	case O_CONT:
+	case O_DELETE:
+	case O_CATCH:
+	case O_IGNORE:
+	case O_TRACEOFF:
+	    p->value.lcon = nextarg(long);
+	    break;
+
+	case O_FCON:
+	    p->value.fcon = nextarg(double);
+	    break;
+
+	case O_SCON:
+	case O_CHFILE:
+	case O_EDIT:
+	case O_SOURCE:
+	    p->value.scon = nextarg(String);
+	    break;
+
+	case O_RVAL:
+	    q = nextarg(Node);
+	    if (q->op == O_CALL) {
+		*p = *q;
+		dispose(q);
+	    } else {
+		p->value.arg[0] = q;
+	    }
+	    break;
+
+	case O_INDIR:
+	    q = nextarg(Node);
+	    if (q != nil and q->op == O_RVAL) {
+		p->value.arg[0] = q->value.arg[0];
+		dispose(q);
+	    } else {
+		p->value.arg[0] = q;
+	    }
+	    break;
+
+	case O_ADDEVENT:
+	case O_ONCE:
+	case O_IF:
+	    p->value.event.cond = nextarg(Node);
+	    p->value.event.actions = nextarg(Cmdlist);
+	    break;
+
+	case O_TRACEON:
+	    p->value.trace.inst = nextarg(Boolean);
+	    p->value.trace.event = nil;
+	    p->value.trace.actions = nextarg(Cmdlist);
+	    break;
+
+	case O_STEP:
+	    p->value.step.source = nextarg(Boolean);
+	    p->value.step.skipcalls = nextarg(Boolean);
+	    break;
+
+	case O_EXAMINE:
+	    p->value.examine.mode = nextarg(String);
+	    p->value.examine.beginaddr = nextarg(Node);
+	    p->value.examine.endaddr = nextarg(Node);
+	    p->value.examine.count = nextarg(Integer);
+	    break;
+
+	default:
+	    for (i = 0; i < nargs(op); i++) {
+		p->value.arg[i] = nextarg(Node);
+	    }
+	    break;
+    }
+    check(p);
+    assigntypes(p);
+    if(debug_flag[5]) {     
+  	fprintf(stderr," built %s node %d with arg0 %d arg1 %d \n",
+  	        showoperator(p->op), p, p->value.arg[0],p->value.arg[1]);
+    }
+    return p;
+}
+
+/*
+ * Create a command list from a single command.
+ */
+
+public Cmdlist buildcmdlist(cmd)
+Command cmd;
+{
+    Cmdlist cmdlist;
+
+    cmdlist = list_alloc();
+    cmdlist_append(cmd, cmdlist);
+    return cmdlist;
+}
+
+/*
+ * Return the tree for a unary ampersand operator.
+ */
+
+public Node amper(p)
+Node p;
+{
+    Node r;
+
+    checkref(p);
+    switch (p->op) {
+	case O_RVAL:
+	    r = p->value.arg[0];
+	    break;
+
+	case O_CALL:
+	    r = build(O_LCON, codeloc(p->value.arg[0]->value.sym));
+	    tfree(p);
+	    break;
+
+	case O_SYM:
+	    if (isblock(p->value.sym)) {
+		r = build(O_LCON, codeloc(p->value.sym));
+	    } else {
+		r = build(O_LCON, address(p->value.sym, nil));
+	    }
+	    tfree(p);
+	    break;
+
+	case O_DOT:
+	    r = p;
+	    break;
+
+	case O_INDIR:
+	    r = p->value.arg[0];
+	    dispose(p);
+	    break;
+
+	default:
+	    beginerrmsg();
+	    fprintf(stderr, "expected variable, found ");
+	    prtree(stderr, p);
+	    tfree(p);
+	    enderrmsg();
+	    /* NOTREACHED */
+    }
+    r->nodetype = t_int;
+    return r;
+}
+
+/*
+ * Create a "concrete" version of a node.
+ * This is necessary when the type of the node contains
+ * an unresolved type reference.
+ */
+
+public Node concrete(p)
+Node p;
+{
+    findtype(p->nodetype);
+    return build(O_INDIR, p);
+}
+
+/*
+ * Print out a command.
+ */
+
+public printcmd(f, cmd)
+File f;
+Command cmd;
+{
+    register Integer i;
+    register Command c;
+    register Node p;
+
+    switch (cmd->op) {
+	case O_PRINTIFCHANGED:
+	case O_PRINTSRCPOS:
+	case O_STOPIFCHANGED:
+	case O_TRACEON:
+	    break;
+
+	case O_STEP:
+	    if (cmd->value.step.skipcalls) {
+		fprintf(f, "next");
+	    } else {
+		fprintf(f, "step");
+	    }
+	    if (not cmd->value.step.source) {
+		fprintf(f, "i");
+	    }
+	    break;
+
+	default:
+	    fprintf(f, "%s", opinfo[ord(cmd->op)].opstring);
+	    if (nargs(cmd->op) != 0) {
+		fprintf(f, " ");
+	    }
+	    break;
+    }
+    switch (cmd->op) {
+	case O_PRINTCALL:
+	case O_PRINTRTN:
+	case O_PROCRTN:
+	    fprintf(f, "%s", symname(cmd->value.sym));
+	    break;
+
+	case O_PRINTSRCPOS:
+	    p = cmd->value.arg[0];
+	    if (p != nil and p->op != O_QLINE) {
+		printf("trace ");
+		prtree(f, p);
+	    }
+	    break;
+
+	case O_CHFILE:
+	case O_EDIT:
+	case O_SOURCE:
+	    fprintf(f, "%s", cmd->value.scon);
+	    break;
+
+	case O_DELETE:
+	case O_CATCH:
+	case O_IGNORE:
+	case O_TRACEOFF:
+	    fprintf(f, "%d", cmd->value.lcon);
+	    break;
+
+	case O_ADDEVENT:
+	case O_ONCE:
+	case O_IF:
+	    fprintf(f, " ");
+	    prtree(f, cmd->value.event.cond);
+	    fprintf(f, " { ");
+	    foreach (Command, c, cmd->value.event.actions)
+		printcmd(f, c);
+		if (not list_islast()) {
+		    fprintf(f, ";");
+		}
+	    endfor
+	    fprintf(f, " }", opinfo[ord(cmd->op)].opstring);
+	    break;
+
+	case O_TRACEON:
+	    print_tracestop(f, cmd);
+	    break;
+
+	case O_EXAMINE:
+	    prtree(f, cmd->value.examine.beginaddr);
+	    if (cmd->value.examine.endaddr != nil) {
+		fprintf(f, ",");
+		prtree(f, cmd->value.examine.endaddr);
+	    }
+	    fprintf(f, "/");
+	    if (cmd->value.examine.count > 1) {
+		fprintf(f, "%d", cmd->value.examine.count);
+	    }
+	    fprintf("%s", cmd->value.examine.mode);
+	    break;
+
+	default:
+	    if (nargs(cmd->op) != 0) {
+		i = 0;
+		for (;;) {
+		    prtree(f, cmd->value.arg[i]);
+		    ++i;
+		if (i >= nargs(cmd->op)) break;
+		    fprintf(f, " ");
+		}
+	    }
+	    break;
+    }
+}
+
+/*
+ * Print out a trace/stop command name.
+ */
+
+#define fprintI(f, b) { if (b) fprintf(f, "i"); }
+
+private print_tracestop(f, cmd)
+File f;
+Command cmd;
+{
+    register Command c, ifcmd, stopcmd;
+    Boolean done;
+
+    done = false;
+    ifcmd = list_element(Command, list_head(cmd->value.trace.actions));
+    checkref(ifcmd);
+    if (ifcmd->op == O_IF) {
+	stopcmd = list_element(Command, list_head(ifcmd->value.event.actions));
+	checkref(stopcmd);
+	if (stopcmd->op == O_STOPX) {
+	    fprintf(f, "stop");
+	    fprintI(f, cmd->value.trace.inst);
+	    fprintf(f, " if ");
+	    prtree(f, ifcmd->value.event.cond);
+	    done = true;
+	}
+    } else if (ifcmd->op == O_STOPIFCHANGED) {
+	fprintf(f, "stop");
+	fprintI(f, cmd->value.trace.inst);
+	fprintf(f, " ");
+	prtree(f, ifcmd->value.arg[0]);
+	done = true;
+    }
+    if (not done) {
+	fprintf(f, "%s ", cmd->value.trace.inst ? "tracei" : "trace");
+	foreach (Command, c, cmd->value.trace.actions)
+	    printcmd(f, c);
+	    if (not list_islast()) {
+		fprintf(f, ";");
+	    }
+	endfor
+    }
+}
+
+/*
+ * Print out a tree.
+ */
+
+public prtree(f, p)
+File f;
+register Node p;
+{
+    register Node q;
+    Operator op;
+
+    if (p != nil) {
+	op = p->op;
+	if (ord(op) > ord(O_LASTOP)) {
+	    panic("bad op %d in prtree", p->op);
+	}
+	switch (op) {
+	    case O_NAME:
+		fprintf(f, "%s", ident(p->value.name));
+		break;
+
+	    case O_SYM:
+		printname(f, p->value.sym);
+		break;
+
+	    case O_QLINE:
+		if (nlhdr.nfiles > 1) {
+		    prtree(f, p->value.arg[0]);
+		    fprintf(f, ":");
+		}
+		prtree(f, p->value.arg[1]);
+		break;
+
+	    case O_LCON:
+		if (compatible(p->nodetype, t_char)) {
+		    fprintf(f, "'%c'", p->value.lcon);
+		} else {
+		    fprintf(f, "%d", p->value.lcon);
+		}
+		break;
+
+	    case O_FCON:
+		fprintf(f, "%g", p->value.fcon);
+		break;
+
+	    case O_SCON:
+		fprintf(f, "\"%s\"", p->value.scon);
+		break;
+
+	    case O_INDEX:
+		prtree(f, p->value.arg[0]);
+		fprintf(f, "[");
+		prtree(f, p->value.arg[1]);
+		fprintf(f, "]");
+		break;
+
+	    case O_COMMA:
+		prtree(f, p->value.arg[0]);
+		if (p->value.arg[1] != nil) {
+		    fprintf(f, ", ");
+		    prtree(f, p->value.arg[1]);
+		}
+		break;
+
+	    case O_RVAL:
+		if (p->value.arg[0]->op == O_SYM) {
+		    printname(f, p->value.arg[0]->value.sym);
+		} else {
+		    prtree(f, p->value.arg[0]);
+		}
+		break;
+
+	    case O_ITOF:
+		prtree(f, p->value.arg[0]);
+		break;
+
+	    case O_CALL:
+		prtree(f, p->value.arg[0]);
+		if (p->value.arg[1]!= nil) {
+		    fprintf(f, "(");
+		    prtree(f, p->value.arg[1]);
+		    fprintf(f, ")");
+		}
+		break;
+
+	    case O_INDIR:
+		q = p->value.arg[0];
+		if (isvarparam(q->nodetype)) {
+		    prtree(f, q);
+		} else {
+		    if (q->op == O_SYM or q->op == O_LCON or q->op == O_DOT) {
+			prtree(f, q);
+			fprintf(f, "^");
+		    } else {
+			fprintf(f, "*(");
+			prtree(f, q);
+			fprintf(f, ")");
+		    }
+		}
+		break;
+
+	    case O_DOT:
+		q = p->value.arg[0];
+		if (q->op == O_INDIR) {
+		    prtree(f, q->value.arg[0]);
+		} else {
+		    prtree(f, q);
+		}
+		fprintf(f, ".%s", symname(p->value.arg[1]->value.sym));
+		break;
+
+	    default:
+		switch (degree(op)) {
+		    case BINARY:
+			prtree(f, p->value.arg[0]);
+			fprintf(f, "%s", opinfo[ord(op)].opstring);
+			prtree(f, p->value.arg[1]);
+			break;
+
+		    case UNARY:
+			fprintf(f, "%s", opinfo[ord(op)].opstring);
+			prtree(f, p->value.arg[0]);
+			break;
+
+		    default:
+			error("internal error: bad op %d in prtree", op);
+		}
+		break;
+	}
+    }
+}
+
+/*
+ * Free storage associated with a tree.
+ */
+
+public tfree(p)
+Node p;
+{
+    Integer i;
+
+    if (p == nil) {
+	return;
+    }
+    switch (p->op) {
+	case O_QLINE:
+	    dispose(p->value.arg[0]->value.scon);
+	    dispose(p->value.arg[0]);
+	    tfree(p->value.arg[1]);
+	    break;
+
+	case O_SCON:
+	    unmkstring(p->nodetype);
+	    dispose(p->nodetype);
+	    dispose(p->value.scon);
+	    break;
+
+	default:
+	    for (i = 0; i < nargs(p->op); i++) {
+		tfree(p->value.arg[i]);
+	    }
+	    break;
+    }
+    dispose(p);
+}
+
+/*
+ * A recursive tree search routine to test if two trees * are equivalent.
+ */
+
+public Boolean tr_equal(t1, t2)
+register Node t1;
+register Node t2;
+{
+    register Boolean b;
+
+    if (t1 == nil and t2 == nil) {
+	b = true;
+    } else if (t1 == nil or t2 == nil) {
+	b = false;
+    } else if (t1->op != t2->op or degree(t1->op) != degree(t2->op)) {
+	b = false;
+    } else {
+	switch (degree(t1->op)) {
+	    case LEAF:
+		switch (t1->op) {
+		    case O_NAME:
+			b = (Boolean) (t1->value.name == t2->value.name);
+			break;
+
+		    case O_SYM:
+			b = (Boolean) (t1->value.sym == t2->value.sym);
+			break;
+
+		    case O_LCON:
+			b = (Boolean) (t1->value.lcon == t2->value.lcon);
+			break;
+
+		    case O_FCON:
+			b = (Boolean) (t1->value.fcon == t2->value.fcon);
+			break;
+
+		    case O_SCON:
+			b = (Boolean) (t1->value.scon == t2->value.scon);
+			break;
+
+		    default:
+			panic("tr_equal: leaf %d\n", t1->op);
+		}
+		/*NOTREACHED*/
+
+	    case BINARY:
+		if (not tr_equal(t1->value.arg[0], t2->value.arg[0])) {
+		    b = false;
+		} else {
+		    b = tr_equal(t1->value.arg[1], t2->value.arg[1]);
+		}
+		break;
+
+	    case UNARY:
+		b = tr_equal(t1->value.arg[0], t2->value.arg[0]);
+		break;
+
+	    default:
+		panic("tr_equal: bad degree for op %d\n", t1->op);
+	}
+    }
+    return b;
+}
diff --git a/dbx/tree.h b/dbx/tree.h
new file mode 100644
index 0000000..af5e65f
--- /dev/null
+++ b/dbx/tree.h
@@ -0,0 +1,58 @@
+#ifndef tree_h
+#define tree_h
+#include "lists.h"
+
+typedef struct Node *Node;
+typedef Node Command;
+typedef List Cmdlist;
+
+#include "operators.h"
+#include "symbols.h"
+#include "events.h"
+
+#define MAXNARGS 5
+
+struct Node {
+    Operator op;
+    Symbol nodetype;
+    union treevalue {
+	Symbol sym;
+	Name name;
+	long lcon;
+	double fcon;
+	String scon;
+	Node arg[MAXNARGS];
+	struct {
+	    Node cond;
+	    Cmdlist actions;
+	} event;
+	struct {
+	    Boolean inst;
+	    Event event;
+	    Cmdlist actions;
+	} trace;
+	struct {
+	    Boolean source;
+	    Boolean skipcalls;
+	} step;
+	struct {
+	    String mode;
+	    Node beginaddr;
+	    Node endaddr;
+	    Integer count;
+	} examine;
+    } value;
+};
+
+#define evalcmd(cmd) eval(cmd)
+#define cmdlist_append(cmd, cl) list_append(list_item(cmd), nil, cl)
+
+Node build(/* op, args */);
+Cmdlist buildcmdlist(/* cmd */);
+Node amper(/* p */);
+Node concrete(/* p */);
+printcmd(/* f, cmd */);
+prtree(/* f, p */);
+tfree(/* p */);
+Boolean tr_equal(/* t1, t2 */);
+#endif
diff --git a/dbx/y.tab.c b/dbx/y.tab.c
new file mode 100644
index 0000000..99ed389
--- /dev/null
+++ b/dbx/y.tab.c
@@ -0,0 +1,1370 @@
+
+# line 2 "commands.y"
+
+/* Copyright (c) 1982 Regents of the University of California */
+
+static char sccsid[] = "@(#)commands.y 1.9 8/17/83";
+
+/*
+ * Yacc grammar for debugger commands.
+ */
+
+#include "defs.h"
+#include "symbols.h"
+#include "operators.h"
+#include "tree.h"
+#include "process.h"
+#include "source.h"
+#include "scanner.h"
+#include "names.h"
+#include "lists.h"
+
+private String curformat = "X";
+
+
+# line 44 "commands.y"
+typedef union  {
+    Name y_name;
+    Symbol y_sym;
+    Node y_node;
+    Integer y_int;
+    Operator y_op;
+    long y_long;
+    double y_real;
+    String y_string;
+    Boolean y_bool;
+    Cmdlist y_cmdlist;
+    List y_list;
+} YYSTYPE;
+# define ALIAS 257
+# define AND 258
+# define ASSIGN 259
+# define AT 260
+# define CALL 261
+# define CATCH 262
+# define CONT 263
+# define DEBUG 264
+# define DELETE 265
+# define DIV 266
+# define DUMP 267
+# define EDIT 268
+# define FILE 269
+# define FUNC 270
+# define GRIPE 271
+# define HELP 272
+# define IF 273
+# define IGNORE 274
+# define IN 275
+# define LIST 276
+# define MOD 277
+# define NEXT 278
+# define NEXTI 279
+# define NIL 280
+# define NOT 281
+# define OR 282
+# define PRINT 283
+# define PSYM 284
+# define QUIT 285
+# define RUN 286
+# define SH 287
+# define SKIP 288
+# define SOURCE 289
+# define STATUS 290
+# define STEP 291
+# define STEPI 292
+# define STOP 293
+# define STOPI 294
+# define TRACE 295
+# define TRACEI 296
+# define USE 297
+# define WHATIS 298
+# define WHEN 299
+# define WHERE 300
+# define WHEREIS 301
+# define WHICH 302
+# define INT 303
+# define REAL 304
+# define NAME 305
+# define STRING 306
+# define LFORMER 307
+# define RFORMER 308
+# define ABSTRACTION 309
+# define ARROW 310
+# define REDIRECT 311
+# define UNARYSIGN 312
+#define yyclearin yychar = -1
+#define yyerrok yyerrflag = 0
+extern int yychar;
+extern short yyerrflag;
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 150
+#endif
+YYSTYPE yylval, yyval;
+# define YYERRCODE 256
+short yyexca[] ={
+-1, 1,
+	0, -1,
+	-2, 0,
+-1, 41,
+	10, 44,
+	59, 44,
+	-2, 42,
+-1, 125,
+	275, 0,
+	-2, 169,
+-1, 254,
+	60, 0,
+	61, 0,
+	62, 0,
+	33, 0,
+	-2, 127,
+-1, 257,
+	60, 0,
+	61, 0,
+	62, 0,
+	33, 0,
+	-2, 129,
+-1, 259,
+	60, 0,
+	61, 0,
+	62, 0,
+	33, 0,
+	-2, 131,
+-1, 281,
+	60, 0,
+	61, 0,
+	62, 0,
+	33, 0,
+	-2, 128,
+-1, 282,
+	60, 0,
+	61, 0,
+	62, 0,
+	33, 0,
+	-2, 133,
+-1, 283,
+	60, 0,
+	61, 0,
+	62, 0,
+	33, 0,
+	-2, 130,
+-1, 284,
+	60, 0,
+	61, 0,
+	62, 0,
+	33, 0,
+	-2, 132,
+-1, 285,
+	60, 0,
+	61, 0,
+	62, 0,
+	33, 0,
+	-2, 134,
+	};
+# define YYNPROD 197
+# define YYLAST 1745
+short yyact[]={
+
+  64, 274, 273, 133, 269, 134, 236,  63, 131, 183,
+ 132, 166, 152, 119, 115, 114, 113, 214, 177, 140,
+ 165,  62,  50, 188, 174, 217, 255, 256, 181, 182,
+ 140, 277, 213, 193, 122,  60, 118, 261, 290, 172,
+ 164, 162, 160, 163,  57, 159, 288, 244, 206, 221,
+  64, 146, 147, 133, 164, 134, 116,  63, 131, 161,
+ 132, 138, 155, 143, 278, 123, 222, 158, 177, 173,
+ 117, 268, 176,   6, 174, 267, 260,   5, 169,  41,
+ 121, 164, 162,  21, 163,   3, 276,   2, 148,   1,
+ 218, 265, 137,  58,  18,   7, 130, 241, 142,  34,
+  64,  24,  67, 133,  59, 134,  25,  63, 131, 167,
+ 132,  26,   0,   0,   0,   0,   0, 171,   0, 173,
+   0,   0, 176,   0,   0,   0, 258,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0, 184,   0,   0,   0,
+  64, 185,   0, 133,   0, 134,   0,  63, 131,   0,
+ 132,   0,   0,   0, 216,   0,   0,   0,   0,   0,
+   0,   0, 211,   0,   0,   0,   0,   0,   0,   0,
+ 227,   0,   0, 228,   0, 231, 232, 233,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+  64,   0,   0, 133,   0, 134, 157,  63, 131,  54,
+ 132,  56, 266,  55, 157, 245,   0,   0,   0,   0,
+   0,   0,  68,  69,  70,  71,  72,  73,  74,  75,
+  76,  77,  78,  79,  80,  81,  82,  83,   0,  84,
+  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,
+  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+ 105, 106, 107, 108, 109, 110, 111, 112, 135, 136,
+  66, 145,  68,  69,  70,  71,  72,  73,  74,  75,
+  76,  77,  78,  79,  80,  81,  82,  83, 175,  84,
+  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,
+  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+ 105, 106, 107, 108, 109, 110, 111, 112, 135, 136,
+  66, 145,  68,  69,  70,  71,  72,  73,  74,  75,
+  76,  77,  78,  79,  80,  81,  82,  83, 175,  84,
+  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,
+  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+ 105, 106, 107, 108, 109, 110, 111, 112, 135, 136,
+  66, 145,  68,  69,  70, 126,  72,  73,  74,  75,
+  76,  77,  78,  79,  80,  81,  82,  83, 140,  84,
+ 125,  86,  87,  88,  89,  90,  91,  92,  93,  94,
+  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+ 105, 106, 107, 108, 109, 110, 111, 112, 135, 136,
+  66, 128,  68,  69,  70, 126,  72,  73,  74,  75,
+  76,  77,  78,  79,  80,  81,  82,  83, 124,  84,
+ 125,  86,  87,  88,  89,  90,  91,  92,  93,  94,
+  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+ 105, 106, 107, 108, 109, 110, 111, 112, 135, 136,
+  66, 128,  64, 156,  53, 133, 192, 134, 287,  63,
+ 131, 156, 132,   0,   0,   0,   0, 223,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0, 225,   0, 226,   0,   0,
+   0,   0,  64,   0,   0, 133,   0, 134,   0,  63,
+ 131,   0, 132,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,  64,   0,   0,   0,   0, 179,   0,  63,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,  64,   0,   0,   0,   0,   0,   0,  63,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0, 157,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,  68,  69,  70,  71,  72,  73,
+  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,
+ 272,  84,  85,  86,  87,  88,  89,  90,  91,  92,
+  93,  94,  95,  96,  97,  98,  99, 100, 101, 102,
+ 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
+ 135, 136,  66, 145,  68,  69,  70, 126,  72,  73,
+  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,
+ 224,  84, 125,  86,  87,  88,  89,  90,  91,  92,
+  93,  94,  95,  96,  97,  98,  99, 100, 101, 102,
+ 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
+ 135, 136,  66, 145,  68,  69,  70,  71,  72,  73,
+  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,
+   0,  84,  85,  86,  87,  88,  89,  90,  91,  92,
+  93,  94,  95,  96,  97,  98,  99, 100, 101, 102,
+ 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
+ 229, 149,  66,  68,  69,  70,  71,  72,  73,  74,
+  75,  76,  77,  78,  79,  80,  81,  82,  83,   0,
+  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,
+  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
+ 104, 105, 106, 107, 108, 109, 110, 111, 112,   0,
+   0,  66,  68,  69,  70,  71,  72,  73,  74,  75,
+  76,  77,  78,  79,  80,  81,  82,  83, 139,  84,
+  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,
+  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+ 105, 106, 107, 108, 109, 110, 111, 112, 156,  64,
+  66,   0,   0,   0,   0,   0,  63,  68,  69,  70,
+  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,
+  81,  82,  83,   0,  84,  85,  86,  87,  88,  89,
+  90,  91,  92,  93,  94,  95,  96,  97,  98,  99,
+ 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
+ 110, 111, 112,   0,  54,  66,  56,   0,  55,   0,
+ 129,   0,   0,  51,   0,   0, 234,   0,   0,  61,
+   0,   0,   0,   4,   0, 238,   0,   0,   0, 242,
+ 120,   0,   0,   0,   0,   0,   0,   0, 141,   0,
+   0, 186, 187,   0,   0,   0, 151,   0,   0,   0,
+   0,  54,   0,  56,   0,  55, 212, 215,   0,   0,
+  51,   0,   0,   0,   0, 168,   0,   0,   0,   0,
+   0, 270,   0,   0, 178, 180,   0,   0, 275,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0, 286,   0,   0,   0,   0,   0,   0,  54,   0,
+  56,   0,  55,   0,   0,   0,   0,  51,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0, 289,   0,   0,
+ 264,   0,   0,   0,   0,   0, 190,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,  68,  69,  70,  71,  72,  73,  74,  75,  76,
+  77,  78,  79,  80,  81,  82,  83,   0,  84,   0,
+  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
+  96,  97,  98,  99, 100, 101, 102, 103, 104, 105,
+ 106, 107, 108, 109, 110, 111, 112,   0,   0,  66,
+   0,   0,   0,  39, 190,   8,   0,  35,   9,  10,
+  36,  11,   0,  37,  12,  13,  14,  15,  16,   0,
+  17,   0,  40, 196,  44,  45,   0,   0, 197,  32,
+  19,  20,  52,  22,   0,  23,  38,  42,  43,  46,
+  47,  48,  49,  31,  27,  28,  33,  29,  30,  53,
+  39,   0,   8,   0,  35,   9,  10,  36,  11, 191,
+  37,  12,  13,  14,  15,  16,   0,  17,   0,  40,
+   0,  44,  45, 193,   0,   0,  32,  19,  20,  52,
+  22,   0,  23,  38,  42,  43,  46,  47,  48,  49,
+  31,  27,  28,  33,  29,  30,  53,  39,   0,   8,
+ 154,  35,   9,  10,  36,  11,   0,  37,  12,  13,
+  14,  15,  16,   0,  17,   0,  40,  65,  44,  45,
+   0,   0,   0,  32,  19,  20,  52,  22,   0,  23,
+  38,  42,  43,  46,  47,  48,  49,  31,  27,  28,
+  33,  29,  30,  53, 205,   0,   0,   0,   0,   0,
+   0, 205, 279, 196, 194,   0, 195, 153, 197, 263,
+ 196, 194,   0, 195,   0, 197,   0,   0,   0,   0,
+   0, 202, 204, 203,   0,   0,   0, 205, 202, 204,
+ 203,   0,   0,   0, 205, 235, 196, 194,   0, 195,
+   0, 197,   0, 196, 194, 219, 195,   0, 197,   0,
+   0,   0,   0, 193, 202, 204, 203,   0,   0,   0,
+ 193, 202, 204, 203,   0,   0,   0, 205,   0, 196,
+ 194,   0, 195,   0, 197,   0, 196, 194,   0, 195,
+   0, 197,   0,   0,   0,   0, 193,   0,   0, 200,
+   0,   0,   0, 193, 202, 204, 203, 198,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0, 199,   0,
+   0,   0,   0,   0,   0,   0, 262,   0,   0, 193,
+   0, 220, 150,   0,   0,   0, 193,   0,   0, 230,
+   0, 271,   0, 230,   0,   0,   0,   0,   0,   0,
+   0,   0, 239, 240,   0,   0,   0,   0, 127, 127,
+   0, 144,   0,   0, 280,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0, 170,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0, 230,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0, 200,
+   0,   0,   0,   0,   0,   0, 200, 198,   0,   0,
+   0,   0,   0,   0, 198,   0,   0,   0, 199,   0,
+   0,   0,   0, 201, 230, 199,   0, 189,   0,   0,
+ 201,   0, 200,   0, 207, 208, 209, 210,   0, 200,
+ 198,   0,   0, 189,   0,   0,   0, 198,   0,   0,
+   0, 199,   0,   0,   0,   0, 201,   0, 199,   0,
+   0,   0,   0, 201,   0, 200,   0,   0,   0,   0,
+   0,   0, 200, 198,   0, 237,   0,   0,   0,   0,
+ 198,   0, 243,   0, 199,   0,   0,   0,   0, 201,
+   0, 199,   0,   0,   0,   0, 201, 246, 247, 248,
+ 249, 250, 251, 252, 253, 254, 257, 259,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0, 281, 282,
+   0, 283,   0, 284, 285 };
+short yypact[]={
+
+-1000,1003,-1000,  34,-1000,-1000, -27,-1000, 586,-287,
+-288,-289,-1000,-1000, 690,-1000,-1000,-290,-1000, 586,
+-1000,-1000,-1000,-1000,-1000, 165, 115, 586, 487, 690,
+ 690,-1000, 437,-1000,-1000, 586,-291,-1000,-1000, 690,
+ 635,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
+  -2,-292,-1000,-1000, 586, 171, 437,-1000,-1000,-1000,
+-1000, -22,-1000, 537, 586,-1000,-1000,-1000,-1000,-1000,
+-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
+-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
+-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
+-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
+-1000,-1000,-1000,-1000,-1000,-1000,-296,-296,-1000,-1000,
+  28,-296,-254,-254, 437, 904, 170,1394, -10,  28,
+-1000, 437, 437, 437, 437,-1000,-1000,-243,-254,-1000,
+ 437,  28, -98,-1000,1394,-1000,-1000,-1000,-1000,-1000,
+1361,  28,-1000, 690,   5,-1000,-1000,-1000, 455,-292,
+ 171, 690, 171, 171, 171, 690,-1000,-1000,  28,  12,
+1354,-299, 437, 437, 690, 690,-1000, 437,  28, 437,
+  28,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,1394,
+  28,-1000, -11, 690, 437, 437, 437, 437, 437, 437,
+ 437, 437, -35,  65,  15, -24, 178,1191,1191,1191,
+1328,-254,-1000, 586, 170,-1000,-1000,1050,-301, 437,
+-1000, 178, 455,-1000,-1000,-303,-304, 690,  39,-1000,
+-1000,  12,  12,-1000,-1000,-1000,-1000,1394, -62,-1000,
+-1000,  23,-1000,1321, 178,-1000,1191,1191, -59, -59,
+ -59, -59, -59,1191,1387, 437, 437,1387, 437,1387,
+ 437, 437,-1000,-1000,-1000, 956, -13,-1000,-1000,-1000,
+-1000,-1000,-1000,-1000,-1000,-1000, 690,-1000,-1000,-1000,
+-1000,1387,1387,1387,1387,1387,-1000, -21,-1000,-1000,
+-1000 };
+short yypgo[]={
+
+   0, 111, 106,  20, 104,  29,  28, 840,1327, 102,
+  21,  75,  71, 212, 101,  65,  34,  99,  98,  97,
+ 908, 841,1482,1000,  23,  96,  22,  95,  94,1269,
+  91,  90,  89,  87,  85,  56,  83,  79,  67,  66,
+ 487 };
+short yyr1[]={
+
+   0,  32,  32,  33,  33,  33,  34,  34,   4,   4,
+  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
+  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
+  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
+  11,  11,  38,  36,  36,  37,  39,  39,  40,  40,
+  40,  14,  14,  14,  14,  35,  31,  31,  18,  18,
+  30,  30,  13,  13,  12,  12,  12,  12,  12,  12,
+  12,  27,  27,  27,   1,   1,   2,   2,  15,  15,
+  16,  16,  16,   5,   6,   6,  19,  19,  28,  28,
+  28,  28,  29,  29,  17,  17,  17,  17,  26,  26,
+  26,  26,  26,  26,  26,   3,   3,   7,   7,  20,
+  20,  21,  21,  22,  22,  22,  22,  22,  22,  22,
+  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,
+  22,  22,  22,  22,  22,  22,  23,  23,  23,  23,
+  23,  23,  23,  23,  23,  24,  25,  25,  25,  10,
+   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,
+   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,
+   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,
+   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,
+   9,   9,   9,   9,   9,   9,   9 };
+short yyr2[]={
+
+   0,   2,   0,   2,   2,   1,   1,   2,   3,   0,
+   1,   4,   2,   1,   2,   2,   3,   3,   1,   2,
+   1,   1,   2,   1,   2,   1,   1,   1,   3,   1,
+   3,   3,   3,   4,   3,   3,   2,   2,   5,   2,
+   2,   3,   0,   3,   1,   2,   2,   1,   1,   2,
+   2,   1,   1,   1,   1,   0,   2,   0,   1,   1,
+   3,   2,   1,   1,   2,   1,   1,   2,   2,   1,
+   1,   3,   2,   1,   1,   1,   1,   1,   1,   3,
+   2,   2,   4,   1,   0,   1,   1,   0,   1,   2,
+   4,   2,   1,   1,   4,   5,   3,   3,   1,   2,
+   3,   3,   3,   2,   3,   0,   1,   1,   0,   0,
+   2,   1,   3,   1,   1,   3,   2,   2,   2,   3,
+   3,   3,   3,   3,   3,   3,   3,   3,   4,   3,
+   4,   3,   4,   4,   4,   3,   1,   4,   3,   3,
+   2,   4,   2,   2,   4,   1,   1,   1,   1,   1,
+   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+   1,   1,   1,   1,   1,   1,   1 };
+short yychk[]={
+
+-1000, -32, -33, -34,  10, -11, -12, -27, 259, 262,
+ 263, 265, 268, 269, 270, 271, 272, 274, -28, 284,
+ 285, -36, 287, 289, -14,  -2,  -1, 298, 299, 301,
+ 302, 297, 283, 300, -17, 261, 264, 267, 290, 257,
+ 276, -37, 291, 292, 278, 279, 293, 294, 295, 296,
+ -26,  47, 286, 303,  38,  42,  40,  10,  59,  -4,
+  62, -23, -10,  42,  35,  -8, 305,  -9, 257, 258,
+ 259, 260, 261, 262, 263, 264, 265, 266, 267, 268,
+ 269, 270, 271, 272, 274, 275, 276, 277, 278, 279,
+ 280, 281, 282, 283, 284, 285, 286, 287, 288, 289,
+ 290, 291, 292, 293, 294, 295, 296, 297, 298, 299,
+ 300, 301, 302, 303, 303, 303, -35, -35, -10, 303,
+ -23, -35, -16, -15, 273, 275, 260, -22, 306, -23,
+ -25,  43,  45,  38,  40, 303, 304, -15, -16, -20,
+ 273, -23, -18, -16, -22, 306, -10, -10, -35, -21,
+ -22, -23, 303,  -8, -29, -10, 303,  36, -38,  47,
+  44,  61,  43,  45,  42,  -3, 303, -35, -23, -26,
+ -22, -35,  61,  91,  46, 310,  94,  40, -23,  40,
+ -23,  -6,  -5, 305,  -6,  -5, -20, -20, -24, -22,
+ -23, -29, 306,  92,  43,  45,  42,  47, 266, 277,
+ 258, 282,  60,  62,  61,  33,  58, -22, -22, -22,
+ -22, -16, -20, 275, 260, -20, -24, 123, -31,  44,
+  -8,  44, -39, -40, 305,  60,  62,  -3, -26,  -7,
+  -8, -26, -26, -26,  -7,  41, 305, -22, -21,  -8,
+  -8, -19, -21, -22,  58, -10, -22, -22, -22, -22,
+ -22, -22, -22, -22, -22,  61,  62, -22,  61, -22,
+  61,  61, -29,  41, -20, -30, -13, -11, -12, 305,
+ -21, -29, -40, 305, 305,  -7,  47,  93,  41,  41,
+ -29, -22, -22, -22, -22, -22, 125, -13,  59,  -7,
+  59 };
+short yydef[]={
+
+   2,  -2,   1,   0,   5,   6,   9,  10,   0,   0,
+  13,   0,  55,  55,  18,  20,  21,   0,  23,   0,
+  25,  26,  27,  55,  29,   0, 109,   0,   0,   0,
+   0,  55,   0,  65,  66,   0,   0,  69,  70,  73,
+  88,  -2,  51,  52,  53,  54,  76,  77,  74,  75,
+   0, 105,  55,  98,   0,   0,   0,   3,   4,   7,
+  55,   0, 136,   0,   0, 149, 150, 151, 152, 153,
+ 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
+ 164, 165, 166, 167, 168, 169, 170, 171, 172, 173,
+ 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
+ 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
+ 194, 195, 196,  12,  14,  15,  84,  84,  19,  22,
+  24,   0, 109, 109,   0,  -2, 155,  78, 148, 113,
+ 114,   0,   0,   0,   0, 146, 147, 109, 109,  36,
+   0,  37,   0,  58,  59, 148,  39,  40,  57,  64,
+ 111,  67,  68,  72,  89,  91,  92,  93,   0, 105,
+   0, 108,   0,   0,   0, 108, 106,  45,  99, 103,
+   0,   0,   0,   0,   0,   0, 142,  87, 140,   0,
+ 143,  16,  85,  83,  17,  28,  30,  31,  32, 145,
+  80,  81,   0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0, 116, 117, 118,
+   0, 109,  35,   0,   0,  34, 110,   0,  41,   0,
+  71,   0,  43,  47,  48,   0,   0, 108,   0,  97,
+ 107, 100, 101, 102,  96, 104,   8,  11,   0, 138,
+ 139,   0,  86,   0,   0, 115, 119, 120, 121, 122,
+ 123, 124, 125, 126,  -2,   0,   0,  -2,   0,  -2,
+   0,   0,  79, 135,  33,   0,   0,  62,  63,  56,
+ 112,  90,  46,  49,  50,  94, 108, 137, 144, 141,
+  82,  -2,  -2,  -2,  -2,  -2,  38,   0,  61,  95,
+  60 };
+#ifndef lint
+static char yaccpar_sccsid[] = "@(#)yaccpar	4.1	(Berkeley)	2/11/83";
+#endif not lint
+
+#
+# define YYFLAG -1000
+# define YYERROR goto yyerrlab
+# define YYACCEPT return(0)
+# define YYABORT return(1)
+
+/*	parser for yacc output	*/
+
+#ifdef YYDEBUG
+int yydebug = 0; /* 1 for debugging */
+#endif
+YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
+int yychar = -1; /* current input token number */
+int yynerrs = 0;  /* number of errors */
+short yyerrflag = 0;  /* error recovery flag */
+
+yyparse() {
+
+	short yys[YYMAXDEPTH];
+	short yyj, yym;
+	register YYSTYPE *yypvt;
+	register short yystate, *yyps, yyn;
+	register YYSTYPE *yypv;
+	register short *yyxi;
+
+	yystate = 0;
+	yychar = -1;
+	yynerrs = 0;
+	yyerrflag = 0;
+	yyps= &yys[-1];
+	yypv= &yyv[-1];
+
+ yystack:    /* put a state and value onto the stack */
+
+#ifdef YYDEBUG
+	if( yydebug  ) printf( "state %d, char 0%o\n", yystate, yychar );
+#endif
+		if( ++yyps> &yys[YYMAXDEPTH] ) { yyerror( "yacc stack overflow" ); return(1); }
+		*yyps = yystate;
+		++yypv;
+		*yypv = yyval;
+
+ yynewstate:
+
+	yyn = yypact[yystate];
+
+	if( yyn<= YYFLAG ) goto yydefault; /* simple state */
+
+	if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
+	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;
+
+	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
+		yychar = -1;
+		yyval = yylval;
+		yystate = yyn;
+		if( yyerrflag > 0 ) --yyerrflag;
+		goto yystack;
+		}
+
+ yydefault:
+	/* default state action */
+
+	if( (yyn=yydef[yystate]) == -2 ) {
+		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
+		/* look through exception table */
+
+		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */
+
+		while( *(yyxi+=2) >= 0 ){
+			if( *yyxi == yychar ) break;
+			}
+		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
+		}
+
+	if( yyn == 0 ){ /* error */
+		/* error ... attempt to resume parsing */
+
+		switch( yyerrflag ){
+
+		case 0:   /* brand new error */
+
+			yyerror( "syntax error" );
+		yyerrlab:
+			++yynerrs;
+
+		case 1:
+		case 2: /* incompletely recovered error ... try again */
+
+			yyerrflag = 3;
+
+			/* find a state where "error" is a legal shift action */
+
+			while ( yyps >= yys ) {
+			   yyn = yypact[*yyps] + YYERRCODE;
+			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
+			      yystate = yyact[yyn];  /* simulate a shift of "error" */
+			      goto yystack;
+			      }
+			   yyn = yypact[*yyps];
+
+			   /* the current yyps has no shift onn "error", pop stack */
+
+#ifdef YYDEBUG
+			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
+#endif
+			   --yyps;
+			   --yypv;
+			   }
+
+			/* there is no state on the stack with an error shift ... abort */
+
+	yyabort:
+			return(1);
+
+
+		case 3:  /* no shift yet; clobber input char */
+
+#ifdef YYDEBUG
+			if( yydebug ) printf( "error recovery discards char %d\n", yychar );
+#endif
+
+			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
+			yychar = -1;
+			goto yynewstate;   /* try again in the same state */
+
+			}
+
+		}
+
+	/* reduction by production yyn */
+
+#ifdef YYDEBUG
+		if( yydebug ) printf("reduce %d\n",yyn);
+#endif
+		yyps -= yyr2[yyn];
+		yypvt = yypv;
+		yypv -= yyr2[yyn];
+		yyval = yypv[1];
+		yym=yyn;
+			/* consult goto table to find next state */
+		yyn = yyr1[yyn];
+		yyj = yypgo[yyn] + *yyps + 1;
+		if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
+		switch(yym){
+			
+case 6:
+# line 94 "commands.y"
+{
+	if (yypvt[-0].y_node != nil) {
+            if(debug_flag[2]) {dumptree(stderr,yypvt[-0].y_node); fflush (stderr);}
+	    eval(yypvt[-0].y_node);
+	}
+} break;
+case 7:
+# line 102 "commands.y"
+{
+	if (yypvt[-1].y_node != nil) {
+	    if (yypvt[-0].y_string != nil) {
+		setout(yypvt[-0].y_string);
+                if(debug_flag[2]) {dumptree(stderr,yypvt[-1].y_node); fflush (stderr);}
+		eval(yypvt[-1].y_node);
+		unsetout();
+	    } else {
+                if(debug_flag[2]) {dumptree(stderr,yypvt[-1].y_node); fflush (stderr);}
+		eval(yypvt[-1].y_node);
+	    }
+	}
+} break;
+case 8:
+# line 118 "commands.y"
+{
+	yyval.y_string = ident(yypvt[-0].y_name);
+} break;
+case 9:
+# line 123 "commands.y"
+{
+	yyval.y_string = nil;
+} break;
+case 10:
+# line 133 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 11:
+# line 138 "commands.y"
+{
+	yyval.y_node = build(O_ASSIGN, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 12:
+# line 143 "commands.y"
+{
+	yyval.y_node = build(O_CATCH, yypvt[-0].y_long);
+} break;
+case 13:
+# line 148 "commands.y"
+{
+	yyval.y_node = build(O_CONT, (long) DEFSIG);
+} break;
+case 14:
+# line 153 "commands.y"
+{
+	yyval.y_node = build(O_CONT, yypvt[-0].y_long);
+} break;
+case 15:
+# line 158 "commands.y"
+{
+	yyval.y_node = build(O_DELETE, yypvt[-0].y_long);
+} break;
+case 16:
+# line 163 "commands.y"
+{
+	yyval.y_node = build(O_EDIT, yypvt[-0].y_string);
+} break;
+case 17:
+# line 168 "commands.y"
+{
+	yyval.y_node = build(O_CHFILE, yypvt[-0].y_string);
+} break;
+case 18:
+# line 173 "commands.y"
+{
+	yyval.y_node = build(O_FUNC, nil);
+} break;
+case 19:
+# line 178 "commands.y"
+{
+	yyval.y_node = build(O_FUNC, yypvt[-0].y_node);
+} break;
+case 20:
+# line 183 "commands.y"
+{
+	yyval.y_node = build(O_GRIPE);
+} break;
+case 21:
+# line 188 "commands.y"
+{
+	yyval.y_node = build(O_HELP);
+} break;
+case 22:
+# line 193 "commands.y"
+{
+	yyval.y_node = build(O_IGNORE, yypvt[-0].y_long);
+} break;
+case 23:
+# line 198 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 24:
+# line 203 "commands.y"
+{
+	yyval.y_node = build(O_PSYM, yypvt[-0].y_node);
+} break;
+case 25:
+# line 208 "commands.y"
+{
+	if (not popinput()) {
+	    quit(0);
+	} else {
+	    yyval.y_node = nil;
+	}
+} break;
+case 26:
+# line 217 "commands.y"
+{
+	run();
+	/* NOTREACHED */
+} break;
+case 27:
+# line 223 "commands.y"
+{
+	shellline();
+	yyval.y_node = nil;
+} break;
+case 28:
+# line 229 "commands.y"
+{
+	yyval.y_node = build(O_SOURCE, yypvt[-0].y_string);
+} break;
+case 29:
+# line 234 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 30:
+# line 239 "commands.y"
+{
+	yyval.y_node = build(yypvt[-2].y_op, nil, yypvt[-1].y_node, yypvt[-0].y_node);
+} break;
+case 31:
+# line 244 "commands.y"
+{
+	yyval.y_node = build(yypvt[-2].y_op, yypvt[-1].y_node, nil, yypvt[-0].y_node);
+} break;
+case 32:
+# line 249 "commands.y"
+{
+	yyval.y_node = build(yypvt[-2].y_op, nil, nil, yypvt[-0].y_node);
+} break;
+case 33:
+# line 254 "commands.y"
+{
+	yyval.y_node = build(yypvt[-3].y_op, yypvt[-2].y_node, yypvt[-1].y_node, yypvt[-0].y_node);
+} break;
+case 34:
+# line 259 "commands.y"
+{
+	yyval.y_node = build(yypvt[-2].y_op, nil, yypvt[-1].y_node, yypvt[-0].y_node);
+} break;
+case 35:
+# line 264 "commands.y"
+{
+	yyval.y_node = build(yypvt[-2].y_op, yypvt[-1].y_node, nil, yypvt[-0].y_node);
+} break;
+case 36:
+# line 269 "commands.y"
+{
+	yyval.y_node = build(yypvt[-1].y_op, nil, nil, yypvt[-0].y_node);
+} break;
+case 37:
+# line 274 "commands.y"
+{
+	yyval.y_node = build(O_WHATIS, yypvt[-0].y_node);
+} break;
+case 38:
+# line 279 "commands.y"
+{
+	yyval.y_node = build(O_ADDEVENT, yypvt[-3].y_node, yypvt[-1].y_cmdlist);
+} break;
+case 39:
+# line 284 "commands.y"
+{
+	yyval.y_node = build(O_WHEREIS, yypvt[-0].y_node);
+} break;
+case 40:
+# line 289 "commands.y"
+{
+	yyval.y_node = build(O_WHICH, yypvt[-0].y_node);
+} break;
+case 41:
+# line 294 "commands.y"
+{
+	String dir;
+
+	yyval.y_node = nil;
+	if (list_size(yypvt[-0].y_list) == 0) {
+	    foreach (String, dir, sourcepath)
+		printf("%s ", dir);
+	    endfor
+	    printf("\n");
+	} else {
+	    foreach (String, dir, sourcepath)
+		list_delete(list_curitem(sourcepath), sourcepath);
+	    endfor
+	    sourcepath = yypvt[-0].y_list;
+	}
+} break;
+case 42:
+# line 312 "commands.y"
+{ arginit(); } break;
+case 45:
+# line 318 "commands.y"
+{
+	fflush(stdout);
+} break;
+case 48:
+# line 329 "commands.y"
+{
+	newarg(ident(yypvt[-0].y_name));
+} break;
+case 49:
+# line 334 "commands.y"
+{
+	inarg(ident(yypvt[-0].y_name));
+} break;
+case 50:
+# line 339 "commands.y"
+{
+	outarg(ident(yypvt[-0].y_name));
+} break;
+case 51:
+# line 345 "commands.y"
+{
+	yyval.y_node = build(O_STEP, true, false);
+} break;
+case 52:
+# line 350 "commands.y"
+{
+	yyval.y_node = build(O_STEP, false, false);
+} break;
+case 53:
+# line 355 "commands.y"
+{
+	yyval.y_node = build(O_STEP, true, true);
+} break;
+case 54:
+# line 360 "commands.y"
+{
+	yyval.y_node = build(O_STEP, false, true);
+} break;
+case 55:
+# line 366 "commands.y"
+{
+	beginshellmode();
+} break;
+case 56:
+# line 372 "commands.y"
+{
+	yyval.y_list = yypvt[-1].y_list;
+	list_append(list_item(ident(yypvt[-0].y_name)), nil, yyval.y_list);
+} break;
+case 57:
+# line 378 "commands.y"
+{
+	yyval.y_list = list_alloc();
+} break;
+case 60:
+# line 389 "commands.y"
+{
+	yyval.y_cmdlist = yypvt[-2].y_cmdlist;
+	cmdlist_append(yypvt[-1].y_node, yyval.y_cmdlist);
+} break;
+case 61:
+# line 395 "commands.y"
+{
+	yyval.y_cmdlist = list_alloc();
+	cmdlist_append(yypvt[-1].y_node, yyval.y_cmdlist);
+} break;
+case 64:
+# line 411 "commands.y"
+{
+	yyval.y_node = build(O_PRINT, yypvt[-0].y_node);
+} break;
+case 65:
+# line 416 "commands.y"
+{
+	yyval.y_node = build(O_WHERE);
+} break;
+case 66:
+# line 421 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 67:
+# line 426 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 68:
+# line 431 "commands.y"
+{
+ 	yyval.y_node = build(O_DEBUG, yypvt[-0].y_long);
+} break;
+case 69:
+# line 436 "commands.y"
+{
+	yyval.y_node = build(O_DUMP);
+} break;
+case 70:
+# line 441 "commands.y"
+{
+	yyval.y_node = build(O_STATUS);
+} break;
+case 71:
+# line 447 "commands.y"
+{
+	yyval.y_node = build(O_ALIAS, build(O_NAME, yypvt[-1].y_name), build(O_NAME, yypvt[-0].y_name));
+} break;
+case 72:
+# line 452 "commands.y"
+{
+	yyval.y_node = build(O_ALIAS, build(O_NAME, yypvt[-0].y_name), nil);
+} break;
+case 73:
+# line 457 "commands.y"
+{
+	yyval.y_node = build(O_ALIAS, nil, nil);
+} break;
+case 74:
+# line 463 "commands.y"
+{
+	yyval.y_op = O_TRACE;
+} break;
+case 75:
+# line 468 "commands.y"
+{
+	yyval.y_op = O_TRACEI;
+} break;
+case 76:
+# line 474 "commands.y"
+{
+	yyval.y_op = O_STOP;
+} break;
+case 77:
+# line 479 "commands.y"
+{
+	yyval.y_op = O_STOPI;
+} break;
+case 78:
+# line 485 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 79:
+# line 490 "commands.y"
+{
+	yyval.y_node = build(O_QLINE, build(O_SCON, yypvt[-2].y_string), yypvt[-0].y_node);
+} break;
+case 80:
+# line 496 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 81:
+# line 501 "commands.y"
+{
+	yyval.y_node = build(O_QLINE, build(O_SCON, cursource), yypvt[-0].y_node);
+} break;
+case 82:
+# line 506 "commands.y"
+{
+	yyval.y_node = build(O_QLINE, build(O_SCON, yypvt[-2].y_string), yypvt[-0].y_node);
+} break;
+case 83:
+# line 512 "commands.y"
+{
+	yyval.y_string = ident(yypvt[-0].y_name);
+} break;
+case 84:
+# line 518 "commands.y"
+{
+	yyval.y_string = nil;
+} break;
+case 85:
+# line 523 "commands.y"
+{
+	yyval.y_string = yypvt[-0].y_string;
+} break;
+case 86:
+# line 529 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 87:
+# line 534 "commands.y"
+{
+	yyval.y_node = nil;
+} break;
+case 88:
+# line 540 "commands.y"
+{
+	yyval.y_node = build(O_LIST,
+	    build(O_LCON, (long) cursrcline),
+	    build(O_LCON, (long) cursrcline + 9)
+	);
+} break;
+case 89:
+# line 548 "commands.y"
+{
+	yyval.y_node = build(O_LIST, yypvt[-0].y_node, yypvt[-0].y_node);
+} break;
+case 90:
+# line 553 "commands.y"
+{
+	yyval.y_node = build(O_LIST, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 91:
+# line 558 "commands.y"
+{
+	yyval.y_node = build(O_LIST, yypvt[-0].y_node);
+} break;
+case 92:
+# line 564 "commands.y"
+{
+	yyval.y_node = build(O_LCON, yypvt[-0].y_long);
+} break;
+case 93:
+# line 569 "commands.y"
+{
+	yyval.y_node = build(O_LCON, (long) LASTLINE);
+} break;
+case 94:
+# line 575 "commands.y"
+{
+	yyval.y_node = build(O_EXAMINE, yypvt[-0].y_string, yypvt[-3].y_node, nil, yypvt[-1].y_long);
+} break;
+case 95:
+# line 580 "commands.y"
+{
+	yyval.y_node = build(O_EXAMINE, yypvt[-0].y_string, yypvt[-4].y_node, yypvt[-2].y_node, 0);
+} break;
+case 96:
+# line 585 "commands.y"
+{
+	yyval.y_node = build(O_EXAMINE, yypvt[-0].y_string, build(O_LCON, (long) prtaddr), nil, yypvt[-1].y_long);
+} break;
+case 97:
+# line 590 "commands.y"
+{
+	yyval.y_node = build(O_EXAMINE, yypvt[-0].y_string, yypvt[-2].y_node, nil, 0);
+} break;
+case 98:
+# line 596 "commands.y"
+{
+	yyval.y_node = build(O_LCON, yypvt[-0].y_long);
+} break;
+case 99:
+# line 601 "commands.y"
+{
+	yyval.y_node = amper(yypvt[-0].y_node);
+} break;
+case 100:
+# line 606 "commands.y"
+{
+	yyval.y_node = build(O_ADD, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 101:
+# line 611 "commands.y"
+{
+	yyval.y_node = build(O_SUB, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 102:
+# line 616 "commands.y"
+{
+	yyval.y_node = build(O_MUL, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 103:
+# line 621 "commands.y"
+{
+	yyval.y_node = build(O_INDIR, yypvt[-0].y_node);
+} break;
+case 104:
+# line 626 "commands.y"
+{
+	yyval.y_node = yypvt[-1].y_node;
+} break;
+case 105:
+# line 632 "commands.y"
+{
+	yyval.y_long = 1;
+} break;
+case 106:
+# line 637 "commands.y"
+{
+	yyval.y_long = yypvt[-0].y_long;
+} break;
+case 107:
+# line 643 "commands.y"
+{
+	yyval.y_string = ident(yypvt[-0].y_name);
+	curformat = yyval.y_string;
+} break;
+case 108:
+# line 649 "commands.y"
+{
+	yyval.y_string = curformat;
+} break;
+case 109:
+# line 655 "commands.y"
+{
+	yyval.y_node = nil;
+} break;
+case 110:
+# line 660 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 111:
+# line 666 "commands.y"
+{
+	yyval.y_node = build(O_COMMA, yypvt[-0].y_node, nil);
+} break;
+case 112:
+# line 671 "commands.y"
+{
+	yyval.y_node = build(O_COMMA, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 113:
+# line 677 "commands.y"
+{
+	yyval.y_node = build(O_RVAL, yypvt[-0].y_node);
+} break;
+case 114:
+# line 682 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 115:
+# line 687 "commands.y"
+{
+	yyval.y_node = build(O_TYPERENAME, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 116:
+# line 692 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 117:
+# line 697 "commands.y"
+{
+	yyval.y_node = build(O_NEG, yypvt[-0].y_node);
+} break;
+case 118:
+# line 702 "commands.y"
+{
+	yyval.y_node = amper(yypvt[-0].y_node);
+} break;
+case 119:
+# line 707 "commands.y"
+{
+	yyval.y_node = build(O_ADD, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 120:
+# line 712 "commands.y"
+{
+	yyval.y_node = build(O_SUB, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 121:
+# line 717 "commands.y"
+{
+	yyval.y_node = build(O_MUL, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 122:
+# line 722 "commands.y"
+{
+	yyval.y_node = build(O_DIVF, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 123:
+# line 727 "commands.y"
+{
+	yyval.y_node = build(O_DIV, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 124:
+# line 732 "commands.y"
+{
+	yyval.y_node = build(O_MOD, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 125:
+# line 737 "commands.y"
+{
+	yyval.y_node = build(O_AND, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 126:
+# line 742 "commands.y"
+{
+	yyval.y_node = build(O_OR, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 127:
+# line 747 "commands.y"
+{
+	yyval.y_node = build(O_LT, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 128:
+# line 752 "commands.y"
+{
+	yyval.y_node = build(O_LE, yypvt[-3].y_node, yypvt[-0].y_node);
+} break;
+case 129:
+# line 757 "commands.y"
+{
+	yyval.y_node = build(O_GT, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 130:
+# line 762 "commands.y"
+{
+	yyval.y_node = build(O_GE, yypvt[-3].y_node, yypvt[-0].y_node);
+} break;
+case 131:
+# line 767 "commands.y"
+{
+	yyval.y_node = build(O_EQ, yypvt[-2].y_node, yypvt[-0].y_node);
+} break;
+case 132:
+# line 772 "commands.y"
+{
+	yyval.y_node = build(O_EQ, yypvt[-3].y_node, yypvt[-0].y_node);
+} break;
+case 133:
+# line 777 "commands.y"
+{
+	yyval.y_node = build(O_NE, yypvt[-3].y_node, yypvt[-0].y_node);
+} break;
+case 134:
+# line 782 "commands.y"
+{
+	yyval.y_node = build(O_NE, yypvt[-3].y_node, yypvt[-0].y_node);
+} break;
+case 135:
+# line 787 "commands.y"
+{
+	yyval.y_node = yypvt[-1].y_node;
+} break;
+case 136:
+# line 793 "commands.y"
+{
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 137:
+# line 798 "commands.y"
+{
+	yyval.y_node = subscript(yypvt[-3].y_node, yypvt[-1].y_node);
+} break;
+case 138:
+# line 803 "commands.y"
+{
+	yyval.y_node = dot(yypvt[-2].y_node, yypvt[-0].y_name);
+} break;
+case 139:
+# line 808 "commands.y"
+{
+	yyval.y_node = dot(yypvt[-2].y_node, yypvt[-0].y_name);
+} break;
+case 140:
+# line 813 "commands.y"
+{
+	yyval.y_node = build(O_INDIR, yypvt[-0].y_node);
+} break;
+case 141:
+# line 818 "commands.y"
+{
+	yyval.y_node = build(O_INDIR, yypvt[-1].y_node);
+} break;
+case 142:
+# line 823 "commands.y"
+{
+	yyval.y_node = build(O_INDIR, yypvt[-1].y_node);
+} break;
+case 143:
+# line 828 "commands.y"
+{
+	yyval.y_node = concrete(yypvt[-0].y_node);
+} break;
+case 144:
+# line 833 "commands.y"
+{
+	yyval.y_node = build(O_CALL, yypvt[-3].y_node, yypvt[-1].y_node);
+} break;
+case 145:
+# line 839 "commands.y"
+{
+	chkboolean(yypvt[-0].y_node);
+	yyval.y_node = yypvt[-0].y_node;
+} break;
+case 146:
+# line 846 "commands.y"
+{
+	yyval.y_node = build(O_LCON, yypvt[-0].y_long);
+} break;
+case 147:
+# line 851 "commands.y"
+{
+	yyval.y_node = build(O_FCON, yypvt[-0].y_real);
+} break;
+case 148:
+# line 856 "commands.y"
+{
+	yyval.y_node = build(O_SCON, yypvt[-0].y_string);
+} break;
+case 149:
+# line 862 "commands.y"
+{
+	yyval.y_node = build(O_SYM, which(yypvt[-0].y_name));
+} break;
+case 150:
+# line 868 "commands.y"
+{
+	yyval.y_name = yypvt[-0].y_name;
+} break;
+case 151:
+# line 873 "commands.y"
+{
+	yyval.y_name = yypvt[-0].y_name;
+} break;
+		}
+		goto yystack;  /* stack new state and value */
+
+	}
diff --git a/dbx/y.tab.h b/dbx/y.tab.h
new file mode 100644
index 0000000..d328a2d
--- /dev/null
+++ b/dbx/y.tab.h
@@ -0,0 +1,71 @@
+
+typedef union  {
+    Name y_name;
+    Symbol y_sym;
+    Node y_node;
+    Integer y_int;
+    Operator y_op;
+    long y_long;
+    double y_real;
+    String y_string;
+    Boolean y_bool;
+    Cmdlist y_cmdlist;
+    List y_list;
+} YYSTYPE;
+extern YYSTYPE yylval;
+# define ALIAS 257
+# define AND 258
+# define ASSIGN 259
+# define AT 260
+# define CALL 261
+# define CATCH 262
+# define CONT 263
+# define DEBUG 264
+# define DELETE 265
+# define DIV 266
+# define DUMP 267
+# define EDIT 268
+# define FILE 269
+# define FUNC 270
+# define GRIPE 271
+# define HELP 272
+# define IF 273
+# define IGNORE 274
+# define IN 275
+# define LIST 276
+# define MOD 277
+# define NEXT 278
+# define NEXTI 279
+# define NIL 280
+# define NOT 281
+# define OR 282
+# define PRINT 283
+# define PSYM 284
+# define QUIT 285
+# define RUN 286
+# define SH 287
+# define SKIP 288
+# define SOURCE 289
+# define STATUS 290
+# define STEP 291
+# define STEPI 292
+# define STOP 293
+# define STOPI 294
+# define TRACE 295
+# define TRACEI 296
+# define USE 297
+# define WHATIS 298
+# define WHEN 299
+# define WHERE 300
+# define WHEREIS 301
+# define WHICH 302
+# define INT 303
+# define REAL 304
+# define NAME 305
+# define STRING 306
+# define LFORMER 307
+# define RFORMER 308
+# define ABSTRACTION 309
+# define ARROW 310
+# define REDIRECT 311
+# define UNARYSIGN 312
